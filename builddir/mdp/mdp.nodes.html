

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mdp.nodes package &mdash; Modular toolkit for Data Processing (MDP)</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Modular toolkit for Data Processing (MDP)" href="../index.html"/>
        <link rel="up" title="mdp package" href="mdp.html"/>
        <link rel="next" title="mdp.nodes.classifier_nodes module" href="mdp.nodes.classifier_nodes.html"/>
        <link rel="prev" title="mdp.hinet.switchboard_factory module" href="mdp.hinet.switchboard_factory.html"/> 
<meta name="viewport" content="width=740" />


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/logo_animation.gif" class="logo" />
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../tutorial/tutorial.html">Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/examples.html">Examples</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="modules.html">mdp</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="mdp.html">mdp package</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="mdp.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l5"><a class="reference internal" href="mdp.caching.html">mdp.caching package</a></li>
<li class="toctree-l5"><a class="reference internal" href="mdp.graph.html">mdp.graph package</a></li>
<li class="toctree-l5"><a class="reference internal" href="mdp.hinet.html">mdp.hinet package</a></li>
<li class="toctree-l5 current"><a class="current reference internal" href="#">mdp.nodes package</a></li>
<li class="toctree-l5"><a class="reference internal" href="mdp.parallel.html">mdp.parallel package</a></li>
<li class="toctree-l5"><a class="reference internal" href="mdp.test.html">mdp.test package</a></li>
<li class="toctree-l5"><a class="reference internal" href="mdp.utils.html">mdp.utils package</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="mdp.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="mdp.html#module-mdp">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../additional_utilities.html">Additional utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development.html">Development</a></li>
<li class="toctree-l2"><a class="reference external" href="http://mdp-toolkit.sourceforge.net/api/index.html">API documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../how_to_cite_mdp.html">How to cite MDP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MDP</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../documentation.html">Documentation</a> &raquo;</li>
        
          <li><a href="modules.html">mdp</a> &raquo;</li>
        
          <li><a href="mdp.html">mdp package</a> &raquo;</li>
        
      <li>mdp.nodes package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mdp-nodes-package">
<h1>mdp.nodes package<a class="headerlink" href="#mdp-nodes-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.classifier_nodes.html">mdp.nodes.classifier_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.convolution_nodes.html">mdp.nodes.convolution_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.em_nodes.html">mdp.nodes.em_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.expansion_nodes.html">mdp.nodes.expansion_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.fda_nodes.html">mdp.nodes.fda_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.gsfa_nodes.html">mdp.nodes.gsfa_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.ica_nodes.html">mdp.nodes.ica_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.isfa_nodes.html">mdp.nodes.isfa_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.jade.html">mdp.nodes.jade module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.libsvm_classifier.html">mdp.nodes.libsvm_classifier module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.lle_nodes.html">mdp.nodes.lle_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.mca_nodes_online.html">mdp.nodes.mca_nodes_online module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.misc_nodes.html">mdp.nodes.misc_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.neural_gas_nodes.html">mdp.nodes.neural_gas_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.nipals.html">mdp.nodes.nipals module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.pca_nodes.html">mdp.nodes.pca_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.pca_nodes_online.html">mdp.nodes.pca_nodes_online module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.rbm_nodes.html">mdp.nodes.rbm_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.recursive_expansion_nodes.html">mdp.nodes.recursive_expansion_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.regression_nodes.html">mdp.nodes.regression_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.scikits_nodes.html">mdp.nodes.scikits_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.sfa_nodes.html">mdp.nodes.sfa_nodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.sfa_nodes_online.html">mdp.nodes.sfa_nodes_online module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.shogun_svm_classifier.html">mdp.nodes.shogun_svm_classifier module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.stats_nodes_online.html">mdp.nodes.stats_nodes_online module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.svm_classifiers.html">mdp.nodes.svm_classifiers module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.nodes.xsfa_nodes.html">mdp.nodes.xsfa_nodes module</a></li>
</ul>
</div>
</div>
<div class="section" id="module-mdp.nodes">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-mdp.nodes" title="Permalink to this headline">¶</a></h2>
<p><strong>Module content:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.CheckpointFlow</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.CheckpointFunction</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.CheckpointSaveFunction</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.ClassifierCumulator</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.ClassifierNode</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.CrashRecoveryException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.Cumulator</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.ExtensionException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.ExtensionNode</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.ExtensionNodeMetaclass</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.Flow</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.FlowException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.FlowExceptionCR</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.InconsistentDimException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.IsNotInvertibleException</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.IsNotTrainableException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.MDPDeprecationWarning</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">MDPException</span></code></td>
<td>Base class for exceptions in MDP.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.MDPWarning</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.Node</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.NodeException</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.NodeMetaclass</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.PreserveDimNode</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.TrainingException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.TrainingFinishedException</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.VariadicCumulator</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">__loader__</span></code></td>
<td>Concrete implementation of SourceLoader using the file system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">__spec__</span></code></td>
<td>The specification for a module, used for loading.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.activate_extension</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.activate_extensions</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.config</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.deactivate_extension</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.deactivate_extensions</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.extension</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.extension_method</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.extension_setup</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.extension_teardown</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.fastica</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.get_active_extensions</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.get_extensions</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.pca</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.test</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.nodes.with_extension</span></code></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="mdp.nodes.PCANode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">PCANode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>svd=False</em>, <em>reduce=False</em>, <em>var_rel=1e-12</em>, <em>var_abs=1e-15</em>, <em>var_part=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Filter the input data through the most significatives of its
principal components.</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.avg</span></code></dt>
<dd>Mean of the input data (available after training).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.v</span></code></dt>
<dd>Transposed of the projection matrix (available after training).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.d</span></code></dt>
<dd>Variance corresponding to the PCA components (eigenvalues of the
covariance matrix).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.explained_variance</span></code></dt>
<dd>When output_dim has been specified as a fraction of the total
variance, this is the fraction of the total variance that is
actually explained.</dd>
</dl>
</div></blockquote>
<p>More information about Principal Component Analysis, a.k.a. discrete
Karhunen-Loeve transform can be found among others in
I.T. Jolliffe, Principal Component Analysis, Springer-Verlag (1986).</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.PCANode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.PCANode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.PCANode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Filter the input data through the most significatives of its\n    principal components.\n\n    **Internal variables of interest**\n    \n      ``self.avg``\n          Mean of the input data (available after training).\n\n      ``self.v``\n          Transposed of the projection matrix (available after training).\n\n      ``self.d``\n          Variance corresponding to the PCA components (eigenvalues of the\n          covariance matrix).\n\n      ``self.explained_variance``\n          When output_dim has been specified as a fraction of the total\n          variance, this is the fraction of the total variance that is\n          actually explained.\n\n    More information about Principal Component Analysis, a.k.a. discrete\n    Karhunen-Loeve transform can be found among others in\n    I.T. Jolliffe, Principal Component Analysis, Springer-Verlag (1986).\n    ', '__init__': &lt;function PCANode.__init__&gt;, '_set_output_dim': &lt;function PCANode._set_output_dim&gt;, '_check_output': &lt;function PCANode._check_output&gt;, 'get_explained_variance': &lt;function PCANode.get_explained_variance&gt;, '_train': &lt;function PCANode._train&gt;, '_adjust_output_dim': &lt;function PCANode._adjust_output_dim&gt;, '_stop_training': &lt;function PCANode._stop_training&gt;, 'get_projmatrix': &lt;function PCANode.get_projmatrix&gt;, 'get_recmatrix': &lt;function PCANode.get_recmatrix&gt;, '_execute': &lt;function PCANode._execute&gt;, '_inverse': &lt;function PCANode._inverse&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;, 'inverse': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.PCANode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.PCANode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.PCANode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.PCANode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.PCANode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.PCANode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>svd=False</em>, <em>reduce=False</em>, <em>var_rel=1e-12</em>, <em>var_abs=1e-15</em>, <em>var_part=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of principal components to be kept can be specified as
‘output_dim’ directly (e.g. ‘output_dim=10’ means 10 components
are kept) or by the fraction of variance to be explained
(e.g. ‘output_dim=0.95’ means that as many components as necessary
will be kept in order to explain 95% of the input variance).</p>
<p>Other Keyword Arguments:</p>
<dl class="docutils">
<dt>svd – if True use Singular Value Decomposition instead of the</dt>
<dd>standard eigenvalue problem solver. Use it when PCANode
complains about singular covariance matrices</dd>
<dt>reduce – Keep only those principal components which have a variance</dt>
<dd>larger than ‘var_abs’ and a variance relative to the
first principal component larger than ‘var_rel’ and a
variance relative to total variance larger than ‘var_part’
(set var_part to None or 0 for no filtering).
Note: when the ‘reduce’ switch is enabled, the actual number
of principal components (self.output_dim) may be different
from that set when creating the instance.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.PCANode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.PCANode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.PCANode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.PCANode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.PCANode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.PCANode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._adjust_output_dim">
<code class="descname">_adjust_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/pca_nodes.html#PCANode._adjust_output_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PCANode._adjust_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the eigenvector range and set the output dim if required.</p>
<p>This is used if the output dimensions is smaller than the input
dimension (so only the larger eigenvectors have to be kept).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/pca_nodes.html#PCANode._check_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PCANode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/pca_nodes.html#PCANode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PCANode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the input on the first ‘n’ principal components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id1"><span class="problematic" id="id2">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em>, <em>n=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/pca_nodes.html#PCANode._inverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PCANode._inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Project ‘y’ to the input space using the first ‘n’ components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/pca_nodes.html#PCANode._set_output_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PCANode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/pca_nodes.html#PCANode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PCANode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>Keyword arguments:</p>
<dl class="docutils">
<dt>debug=True     if stop_training fails because of singular cov</dt>
<dd>matrices, the singular matrices itselves are stored in
self.cov_mtx and self.dcov_mtx to be examined.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/pca_nodes.html#PCANode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PCANode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.PCANode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.PCANode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the input on the first ‘n’ principal components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.get_explained_variance">
<code class="descname">get_explained_variance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.get_explained_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the fraction of the original variance that can be
explained by self._output_dim PCA components.
If for example output_dim has been set to 0.95, the explained
variance could be something like 0.958…
Note that if output_dim was explicitly set to be a fixed number
of components, there is no way to calculate the explained variance.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.get_projmatrix">
<code class="descname">get_projmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.get_projmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the projection matrix.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.get_recmatrix">
<code class="descname">get_recmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.get_recmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the back-projection matrix (i.e. the reconstruction matrix).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id3"><span class="problematic" id="id4">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.PCANode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Project ‘y’ to the input space using the first ‘n’ components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.PCANode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.PCANode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.PCANode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>Keyword arguments:</p>
<dl class="docutils">
<dt>debug=True     if stop_training fails because of singular cov</dt>
<dd>matrices, the singular matrices itselves are stored in
self.cov_mtx and self.dcov_mtx to be examined.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PCANode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.PCANode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PCANode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PCANode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.WhiteningNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">WhiteningNode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>svd=False</em>, <em>reduce=False</em>, <em>var_rel=1e-12</em>, <em>var_abs=1e-15</em>, <em>var_part=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.PCANode" title="mdp.nodes.PCANode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.PCANode</span></code></a></p>
<p><em>Whiten</em> the input data by filtering it through the most
significatives of its principal components. All output
signals have zero mean, unit variance and are decorrelated.</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.avg</span></code></dt>
<dd>Mean of the input data (available after training).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.v</span></code></dt>
<dd>Transpose of the projection matrix (available after training).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.d</span></code></dt>
<dd>Variance corresponding to the PCA components (eigenvalues of the
covariance matrix).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.explained_variance</span></code></dt>
<dd>When output_dim has been specified as a fraction of the total
variance, this is the fraction of the total variance that is actually
explained.</dd>
</dl>
</div></blockquote>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': '*Whiten* the input data by filtering it through the most\n    significatives of its principal components. All output\n    signals have zero mean, unit variance and are decorrelated.\n\n    **Internal variables of interest**\n\n      ``self.avg``\n          Mean of the input data (available after training).\n\n      ``self.v``\n          Transpose of the projection matrix (available after training).\n\n      ``self.d``\n          Variance corresponding to the PCA components (eigenvalues of the\n          covariance matrix).\n\n      ``self.explained_variance``\n          When output_dim has been specified as a fraction of the total\n          variance, this is the fraction of the total variance that is actually\n          explained.\n    ', '_stop_training': &lt;function WhiteningNode._stop_training&gt;, 'get_eigenvectors': &lt;function WhiteningNode.get_eigenvectors&gt;, 'get_recmatrix': &lt;function WhiteningNode.get_recmatrix&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.WhiteningNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>svd=False</em>, <em>reduce=False</em>, <em>var_rel=1e-12</em>, <em>var_abs=1e-15</em>, <em>var_part=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of principal components to be kept can be specified as
‘output_dim’ directly (e.g. ‘output_dim=10’ means 10 components
are kept) or by the fraction of variance to be explained
(e.g. ‘output_dim=0.95’ means that as many components as necessary
will be kept in order to explain 95% of the input variance).</p>
<p>Other Keyword Arguments:</p>
<dl class="docutils">
<dt>svd – if True use Singular Value Decomposition instead of the</dt>
<dd>standard eigenvalue problem solver. Use it when PCANode
complains about singular covariance matrices</dd>
<dt>reduce – Keep only those principal components which have a variance</dt>
<dd>larger than ‘var_abs’ and a variance relative to the
first principal component larger than ‘var_rel’ and a
variance relative to total variance larger than ‘var_part’
(set var_part to None or 0 for no filtering).
Note: when the ‘reduce’ switch is enabled, the actual number
of principal components (self.output_dim) may be different
from that set when creating the instance.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.WhiteningNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._adjust_output_dim">
<code class="descname">_adjust_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._adjust_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the eigenvector range and set the output dim if required.</p>
<p>This is used if the output dimensions is smaller than the input
dimension (so only the larger eigenvectors have to be kept).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the input on the first ‘n’ principal components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id5"><span class="problematic" id="id6">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Project ‘y’ to the input space using the first ‘n’ components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/pca_nodes.html#WhiteningNode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.WhiteningNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>Keyword arguments:</p>
<dl class="docutils">
<dt>debug=True     if stop_training fails because of singular cov</dt>
<dd>matrices, the singular matrices itselves are stored in
self.cov_mtx and self.dcov_mtx to be examined.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.WhiteningNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the input on the first ‘n’ principal components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.get_eigenvectors">
<code class="descname">get_eigenvectors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.get_eigenvectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the eigenvectors of the covariance matrix.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.get_explained_variance">
<code class="descname">get_explained_variance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.get_explained_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the fraction of the original variance that can be
explained by self._output_dim PCA components.
If for example output_dim has been set to 0.95, the explained
variance could be something like 0.958…
Note that if output_dim was explicitly set to be a fixed number
of components, there is no way to calculate the explained variance.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.get_projmatrix">
<code class="descname">get_projmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.get_projmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the projection matrix.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.get_recmatrix">
<code class="descname">get_recmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.get_recmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the back-projection matrix (i.e. the reconstruction matrix).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id7"><span class="problematic" id="id8">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Project ‘y’ to the input space using the first ‘n’ components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.WhiteningNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.WhiteningNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>Keyword arguments:</p>
<dl class="docutils">
<dt>debug=True     if stop_training fails because of singular cov</dt>
<dd>matrices, the singular matrices itselves are stored in
self.cov_mtx and self.dcov_mtx to be examined.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.WhiteningNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.WhiteningNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.WhiteningNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.WhiteningNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.NIPALSNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">NIPALSNode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>conv=1e-08</em>, <em>max_it=100000</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Cumulator" title="mdp.Cumulator"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Cumulator</span></code></a>, <a class="reference internal" href="../node_list.html#mdp.nodes.PCANode" title="mdp.nodes.PCANode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.PCANode</span></code></a></p>
<p>Perform Principal Component Analysis using the NIPALS algorithm.
This algorithm is particularyl useful if you have more variable than
observations, or in general when the number of variables is huge and
calculating a full covariance matrix may be unfeasable. It’s also more
efficient of the standard PCANode if you expect the number of significant
principal components to be a small. In this case setting output_dim to be
a certain fraction of the total variance, say 90%, may be of some help.</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.avg</span></code></dt>
<dd>Mean of the input data (available after training).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.d</span></code></dt>
<dd>Variance corresponding to the PCA components.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.v</span></code></dt>
<dd>Transposed of the projection matrix (available after training).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.explained_variance</span></code></dt>
<dd>When output_dim has been specified as a fraction of the total
variance, this is the fraction of the total variance that is actually
explained.</dd>
</dl>
</div></blockquote>
<p>Reference for NIPALS (Nonlinear Iterative Partial Least Squares):
Wold, H.
Nonlinear estimation by iterative least squares procedures.
in David, F. (Editor), Research Papers in Statistics, Wiley,
New York, pp 411-444 (1966).</p>
<p>More information about Principal Component Analysis, a.k.a. discrete
Karhunen-Loeve transform can be found among others in
I.T. Jolliffe, Principal Component Analysis, Springer-Verlag (1986).</p>
<p>Original code contributed by:
Michael Schmuker, Susanne Lezius, and Farzad Farkhooi (2008).</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': &quot;Perform Principal Component Analysis using the NIPALS algorithm.\n    This algorithm is particularyl useful if you have more variable than\n    observations, or in general when the number of variables is huge and\n    calculating a full covariance matrix may be unfeasable. It's also more\n    efficient of the standard PCANode if you expect the number of significant\n    principal components to be a small. In this case setting output_dim to be\n    a certain fraction of the total variance, say 90%, may be of some help.\n\n    **Internal variables of interest**\n\n      ``self.avg``\n          Mean of the input data (available after training).\n\n      ``self.d``\n          Variance corresponding to the PCA components.\n\n      ``self.v``\n          Transposed of the projection matrix (available after training).\n          \n      ``self.explained_variance``\n          When output_dim has been specified as a fraction of the total\n          variance, this is the fraction of the total variance that is actually\n          explained.\n\n    Reference for NIPALS (Nonlinear Iterative Partial Least Squares):\n    Wold, H.\n    Nonlinear estimation by iterative least squares procedures.\n    in David, F. (Editor), Research Papers in Statistics, Wiley,\n    New York, pp 411-444 (1966).\n\n    More information about Principal Component Analysis, a.k.a. discrete\n    Karhunen-Loeve transform can be found among others in\n    I.T. Jolliffe, Principal Component Analysis, Springer-Verlag (1986).\n\n    Original code contributed by:\n    Michael Schmuker, Susanne Lezius, and Farzad Farkhooi (2008).\n    &quot;, '__init__': &lt;function NIPALSNode.__init__&gt;, '_train': &lt;function NIPALSNode._train&gt;, '_stop_training': &lt;function NIPALSNode._stop_training&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.NIPALSNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>conv=1e-08</em>, <em>max_it=100000</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of principal components to be kept can be specified as
‘output_dim’ directly (e.g. ‘output_dim=10’ means 10 components
are kept) or by the fraction of variance to be explained
(e.g. ‘output_dim=0.95’ means that as many components as necessary
will be kept in order to explain 95% of the input variance).</p>
<dl class="docutils">
<dt>Other Arguments:</dt>
<dd>conv   - convergence threshold for the residual error.
max_it - maximum number of iterations</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.NIPALSNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._adjust_output_dim">
<code class="descname">_adjust_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._adjust_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the eigenvector range and set the output dim if required.</p>
<p>This is used if the output dimensions is smaller than the input
dimension (so only the larger eigenvectors have to be kept).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the input on the first ‘n’ principal components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id9"><span class="problematic" id="id10">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Project ‘y’ to the input space using the first ‘n’ components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/nipals.html#NIPALSNode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NIPALSNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the collected data in a single array.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/nipals.html#NIPALSNode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NIPALSNode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.NIPALSNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the input on the first ‘n’ principal components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.get_explained_variance">
<code class="descname">get_explained_variance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.get_explained_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the fraction of the original variance that can be
explained by self._output_dim PCA components.
If for example output_dim has been set to 0.95, the explained
variance could be something like 0.958…
Note that if output_dim was explicitly set to be a fixed number
of components, there is no way to calculate the explained variance.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.get_projmatrix">
<code class="descname">get_projmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.get_projmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the projection matrix.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.get_recmatrix">
<code class="descname">get_recmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.get_recmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the back-projection matrix (i.e. the reconstruction matrix).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id11"><span class="problematic" id="id12">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Project ‘y’ to the input space using the first ‘n’ components.
If ‘n’ is not set, use all available components.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NIPALSNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NIPALSNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the collected data in a single array.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NIPALSNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.NIPALSNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NIPALSNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NIPALSNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.FastICANode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">FastICANode</code><span class="sig-paren">(</span><em>approach='defl'</em>, <em>g='pow3'</em>, <em>guess=None</em>, <em>fine_g='pow3'</em>, <em>mu=1</em>, <em>sample_size=1</em>, <em>fine_tanh=1</em>, <em>fine_gaus=1</em>, <em>max_it=5000</em>, <em>max_it_fine=100</em>, <em>failures=5</em>, <em>coarse_limit=None</em>, <em>limit=0.001</em>, <em>verbose=False</em>, <em>whitened=False</em>, <em>white_comp=None</em>, <em>white_parm=None</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.ICANode</span></code></p>
<p>Perform Independent Component Analysis using the FastICA algorithm.
Note that FastICA is a batch-algorithm. This means that it needs
all input data before it can start and compute the ICs.
The algorithm is here given as a Node for convenience, but it
actually accumulates all inputs it receives. Remember that to avoid
running out of memory when you have many components and many time samples.</p>
<p>FastICA does not support the telescope mode (the convergence
criterium is not robust in telescope mode).</p>
<p>Reference:
Aapo Hyvarinen (1999).
Fast and Robust Fixed-Point Algorithms for Independent Component Analysis
IEEE Transactions on Neural Networks, 10(3):626-634.</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.white</span></code></dt>
<dd>The whitening node used for preprocessing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.filters</span></code></dt>
<dd>The ICA filters matrix (this is the transposed of the
projection matrix after whitening).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.convergence</span></code></dt>
<dd>The value of the convergence threshold.</dd>
</dl>
</div></blockquote>
<p>History:</p>
<ul class="simple">
<li>1.4.1998 created for Matlab by Jarmo Hurri, Hugo Gavert, Jaakko Sarela,
and Aapo Hyvarinen</li>
<li>7.3.2003  modified for Python by Thomas Wendler</li>
<li>3.6.2004  rewritten and adapted for scipy and MDP by MDP’s authors</li>
<li>25.5.2005 now independent from scipy. Requires Numeric or numarray</li>
<li>26.6.2006 converted to numpy</li>
<li>14.9.2007 updated to Matlab version 2.5</li>
<li>26.6.2012 added ability to run two stages of optimization [PK]</li>
</ul>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.FastICANode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': &quot;\n    Perform Independent Component Analysis using the FastICA algorithm.\n    Note that FastICA is a batch-algorithm. This means that it needs\n    all input data before it can start and compute the ICs.\n    The algorithm is here given as a Node for convenience, but it\n    actually accumulates all inputs it receives. Remember that to avoid\n    running out of memory when you have many components and many time samples.\n\n    FastICA does not support the telescope mode (the convergence\n    criterium is not robust in telescope mode).\n\n    Reference:\n    Aapo Hyvarinen (1999).\n    Fast and Robust Fixed-Point Algorithms for Independent Component Analysis\n    IEEE Transactions on Neural Networks, 10(3):626-634.\n\n    **Internal variables of interest**\n\n      ``self.white``\n          The whitening node used for preprocessing.\n\n      ``self.filters``\n          The ICA filters matrix (this is the transposed of the\n          projection matrix after whitening).\n\n      ``self.convergence``\n          The value of the convergence threshold.\n\n    History:\n\n    - 1.4.1998 created for Matlab by Jarmo Hurri, Hugo Gavert, Jaakko Sarela,\n      and Aapo Hyvarinen\n    - 7.3.2003  modified for Python by Thomas Wendler\n    - 3.6.2004  rewritten and adapted for scipy and MDP by MDP's authors\n    - 25.5.2005 now independent from scipy. Requires Numeric or numarray\n    - 26.6.2006 converted to numpy\n    - 14.9.2007 updated to Matlab version 2.5\n    - 26.6.2012 added ability to run two stages of optimization [PK]\n    &quot;, '__init__': &lt;function FastICANode.__init__&gt;, '_get_rsamples': &lt;function FastICANode._get_rsamples&gt;, 'core': &lt;function FastICANode.core&gt;})</em><a class="headerlink" href="#mdp.nodes.FastICANode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>approach='defl'</em>, <em>g='pow3'</em>, <em>guess=None</em>, <em>fine_g='pow3'</em>, <em>mu=1</em>, <em>sample_size=1</em>, <em>fine_tanh=1</em>, <em>fine_gaus=1</em>, <em>max_it=5000</em>, <em>max_it_fine=100</em>, <em>failures=5</em>, <em>coarse_limit=None</em>, <em>limit=0.001</em>, <em>verbose=False</em>, <em>whitened=False</em>, <em>white_comp=None</em>, <em>white_parm=None</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Input arguments:</p>
<p>General:</p>
<dl class="docutils">
<dt>whitened – Set whitened == True if input data are already whitened.</dt>
<dd>Otherwise the node will whiten the data itself</dd>
<dt>white_comp – If whitened == False, you can set ‘white_comp’ to the</dt>
<dd>number of whitened components to keep during the
calculation (i.e., the input dimensions are reduced to
white_comp by keeping the components of largest variance).</dd>
<dt>white_parm – a dictionary with additional parameters for whitening.</dt>
<dd>It is passed directly to the WhiteningNode constructor.
Ex: white_parm = { ‘svd’ : True }</dd>
</dl>
<p>limit – convergence threshold.</p>
<p>Specific for FastICA:</p>
<dl class="docutils">
<dt>approach  – Approach to use. Possible values are:</dt>
<dd><blockquote class="first">
<div><blockquote>
<div>‘defl’ –&gt; deflation
‘symm’ –&gt; symmetric</div></blockquote>
<dl class="docutils">
<dt>g  – Nonlinearity to use. Possible values are:</dt>
<dd>‘pow3’ –&gt; x^3
‘tanh’ –&gt; tanh(fine_tanh*x)
‘gaus’ –&gt; x*exp(-fine_gaus*x^2/2)
‘skew’ –&gt; x^2 (for skewed signals)</dd>
</dl>
</div></blockquote>
<dl class="last docutils">
<dt>fine_g – Nonlinearity for fine tuning. Possible values</dt>
<dd><blockquote class="first">
<div>are the same as for ‘g’. Set it to None to disable fine
tuning.</div></blockquote>
<dl class="last docutils">
<dt>mu – Step size. If mu != 1, a stabilization procedure is used:</dt>
<dd>the value of mu can momentarily be halved if the algorithm
is stuck between two points (this is called a stroke).
Also if there is no convergence before half of the maximum
number of iterations has been reached then mu will be halved
for the rest of the rounds.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>sample_size – Percentage of samples used in one iteration. If</dt>
<dd>sample_size &lt; 1, samples are chosen in random order.</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>coarse_limit – initial convergence threshold, to switch to</dt>
<dd><blockquote class="first">
<div><blockquote>
<div>fine_g function (i.e. linear to non-linear) even
before reaching the limit and final tuning. Set
it to a value higher than limit to be in effect.</div></blockquote>
<p>fine_tanh – parameter for ‘tanh’ nonlinearity
fine_gaus – parameter for ‘gaus’ nonlinearity</p>
<blockquote>
<div><blockquote>
<div>guess – initial guess for the mixing matrix (ignored if None)</div></blockquote>
<p>max_it – maximum number of iterations</p>
</div></blockquote>
</div></blockquote>
<p>max_it_fine – maximum number of iterations for fine tuning</p>
<blockquote class="last">
<div>failures – maximum number of failures to allow in deflation mode</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.FastICANode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.FastICANode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._get_rsamples">
<code class="descname">_get_rsamples</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/ica_nodes.html#FastICANode._get_rsamples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FastICANode._get_rsamples" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id13"><span class="problematic" id="id14">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Whiten data if needed and call the ‘core’ routine to perform ICA.
Take care of telescope-mode if needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.FastICANode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.core">
<code class="descname">core</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.core" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the core routine of the ICANode. Each subclass must
define this function to return the achieved convergence value.
This function is also responsible for setting the ICA filters
matrix self.filters.
Note that the matrix self.filters is applied to the right of the
matrix containing input data. This is the transposed of the matrix
defining the linear transformation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.FastICANode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.get_projmatrix">
<code class="descname">get_projmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.get_projmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the projection matrix.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.get_recmatrix">
<code class="descname">get_recmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.get_recmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the back-projection matrix (i.e. the reconstruction matrix).
Note that if the unknown sources are white, this is a good
approximation of the mixing matrix (up to a permutation matrix).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id15"><span class="problematic" id="id16">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.FastICANode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.FastICANode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.FastICANode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.FastICANode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Whiten data if needed and call the ‘core’ routine to perform ICA.
Take care of telescope-mode if needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FastICANode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.FastICANode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FastICANode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FastICANode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.CuBICANode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">CuBICANode</code><span class="sig-paren">(</span><em>limit=0.001</em>, <em>telescope=False</em>, <em>verbose=False</em>, <em>whitened=False</em>, <em>white_comp=None</em>, <em>white_parm=None</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.ICANode</span></code></p>
<p>Perform Independent Component Analysis using the CuBICA algorithm.
Note that CuBICA is a batch-algorithm, which means that it needs
all input data before it can start and compute the ICs.  The
algorithm is here given as a Node for convenience, but it actually
accumulates all inputs it receives. Remember that to avoid running
out of memory when you have many components and many time samples.</p>
<p>As an alternative to this batch mode you might consider the telescope
mode (see the docs of the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method).</p>
<p>Reference:
Blaschke, T. and Wiskott, L. (2003).
CuBICA: Independent Component Analysis by Simultaneous Third- and
Fourth-Order Cumulant Diagonalization.
IEEE Transactions on Signal Processing, 52(5), pp. 1250-1256.</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.white</span></code></dt>
<dd>The whitening node used for preprocessing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.filters</span></code></dt>
<dd>The ICA filters matrix (this is the transposed of the
projection matrix after whitening).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.convergence</span></code></dt>
<dd>The value of the convergence threshold.</dd>
</dl>
</div></blockquote>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.CuBICANode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': '\n    Perform Independent Component Analysis using the CuBICA algorithm.\n    Note that CuBICA is a batch-algorithm, which means that it needs\n    all input data before it can start and compute the ICs.  The\n    algorithm is here given as a Node for convenience, but it actually\n    accumulates all inputs it receives. Remember that to avoid running\n    out of memory when you have many components and many time samples.\n\n    As an alternative to this batch mode you might consider the telescope\n    mode (see the docs of the ``__init__`` method).\n\n    Reference:\n    Blaschke, T. and Wiskott, L. (2003).\n    CuBICA: Independent Component Analysis by Simultaneous Third- and\n    Fourth-Order Cumulant Diagonalization.\n    IEEE Transactions on Signal Processing, 52(5), pp. 1250-1256.\n\n    **Internal variables of interest**\n\n      ``self.white``\n          The whitening node used for preprocessing.\n\n      ``self.filters``\n          The ICA filters matrix (this is the transposed of the\n          projection matrix after whitening).\n\n      ``self.convergence``\n          The value of the convergence threshold.\n    ', 'core': &lt;function CuBICANode.core&gt;})</em><a class="headerlink" href="#mdp.nodes.CuBICANode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>limit=0.001</em>, <em>telescope=False</em>, <em>verbose=False</em>, <em>whitened=False</em>, <em>white_comp=None</em>, <em>white_parm=None</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input arguments:</p>
<dl class="docutils">
<dt>whitened – Set whitened is True if input data are already whitened.</dt>
<dd>Otherwise the node will whiten the data itself.</dd>
<dt>white_comp – If whitened is False, you can set ‘white_comp’ to the</dt>
<dd>number of whitened components to keep during the
calculation (i.e., the input dimensions are reduced to
white_comp by keeping the components of largest variance).</dd>
<dt>white_parm – a dictionary with additional parameters for whitening.</dt>
<dd>It is passed directly to the WhiteningNode constructor.
Ex: white_parm = { ‘svd’ : True }</dd>
</dl>
<p>limit – convergence threshold.</p>
<dl class="docutils">
<dt>telescope – If telescope == True, use Telescope mode: Instead of</dt>
<dd>using all input data in a single batch try larger and larger chunks
of the input data until convergence is achieved. This should lead to
significantly faster convergence for stationary statistics. This mode
has not been thoroughly tested and must be considered beta.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.CuBICANode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.CuBICANode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id17"><span class="problematic" id="id18">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Whiten data if needed and call the ‘core’ routine to perform ICA.
Take care of telescope-mode if needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.CuBICANode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.core">
<code class="descname">core</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.core" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the core routine of the ICANode. Each subclass must
define this function to return the achieved convergence value.
This function is also responsible for setting the ICA filters
matrix self.filters.
Note that the matrix self.filters is applied to the right of the
matrix containing input data. This is the transposed of the matrix
defining the linear transformation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.CuBICANode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.get_projmatrix">
<code class="descname">get_projmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.get_projmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the projection matrix.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.get_recmatrix">
<code class="descname">get_recmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.get_recmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the back-projection matrix (i.e. the reconstruction matrix).
Note that if the unknown sources are white, this is a good
approximation of the mixing matrix (up to a permutation matrix).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id19"><span class="problematic" id="id20">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.CuBICANode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.CuBICANode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.CuBICANode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.CuBICANode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Whiten data if needed and call the ‘core’ routine to perform ICA.
Take care of telescope-mode if needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CuBICANode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.CuBICANode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CuBICANode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CuBICANode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.TDSEPNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">TDSEPNode</code><span class="sig-paren">(</span><em>lags=1</em>, <em>limit=1e-05</em>, <em>max_iter=10000</em>, <em>verbose=False</em>, <em>whitened=False</em>, <em>white_comp=None</em>, <em>white_parm=None</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.ISFANode" title="mdp.nodes.ISFANode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.ISFANode</span></code></a>, <a class="reference internal" href="mdp.nodes.ica_nodes.html#mdp.nodes.ica_nodes.ProjectMatrixMixin" title="mdp.nodes.ica_nodes.ProjectMatrixMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.ica_nodes.ProjectMatrixMixin</span></code></a></p>
<p>Perform Independent Component Analysis using the TDSEP algorithm.
Note that TDSEP, as implemented in this Node, is an online algorithm,
i.e. it is suited to be trained on huge data sets, provided that the
training is done sending small chunks of data for each time.</p>
<p>Reference:
Ziehe, Andreas and Muller, Klaus-Robert (1998).
TDSEP an efficient algorithm for blind separation using time structure.
in Niklasson, L, Boden, M, and Ziemke, T (Editors), Proc. 8th Int. Conf.
Artificial Neural Networks (ICANN 1998).</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.white</span></code></dt>
<dd>The whitening node used for preprocessing.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.filters</span></code></dt>
<dd>The ICA filters matrix (this is the transposed of the
projection matrix after whitening).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.convergence</span></code></dt>
<dd>The value of the convergence threshold.</dd>
</dl>
</div></blockquote>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Perform Independent Component Analysis using the TDSEP algorithm.\n    Note that TDSEP, as implemented in this Node, is an online algorithm,\n    i.e. it is suited to be trained on huge data sets, provided that the\n    training is done sending small chunks of data for each time.\n\n    Reference:\n    Ziehe, Andreas and Muller, Klaus-Robert (1998).\n    TDSEP an efficient algorithm for blind separation using time structure.\n    in Niklasson, L, Boden, M, and Ziemke, T (Editors), Proc. 8th Int. Conf.\n    Artificial Neural Networks (ICANN 1998).\n\n    **Internal variables of interest**\n\n      ``self.white``\n          The whitening node used for preprocessing.\n\n      ``self.filters``\n          The ICA filters matrix (this is the transposed of the\n          projection matrix after whitening).\n\n      ``self.convergence``\n          The value of the convergence threshold.\n    ', '__init__': &lt;function TDSEPNode.__init__&gt;, '_stop_training': &lt;function TDSEPNode._stop_training&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.TDSEPNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>lags=1</em>, <em>limit=1e-05</em>, <em>max_iter=10000</em>, <em>verbose=False</em>, <em>whitened=False</em>, <em>white_comp=None</em>, <em>white_parm=None</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input arguments:</p>
<dl class="docutils">
<dt>lags    – list of time-lags to generate the time-delayed covariance</dt>
<dd>matrices. If lags is an integer, time-lags 1,2,…,’lags’
are used.
Note that time-lag == 0 (instantaneous correlation) is
always implicitly used.</dd>
<dt>whitened – Set whitened is True if input data are already whitened.</dt>
<dd>Otherwise the node will whiten the data itself.</dd>
<dt>white_comp – If whitened is False, you can set ‘white_comp’ to the</dt>
<dd>number of whitened components to keep during the
calculation (i.e., the input dimensions are reduced to
white_comp by keeping the components of largest variance).</dd>
<dt>white_parm – a dictionary with additional parameters for whitening.</dt>
<dd>It is passed directly to the WhiteningNode constructor.
Ex: white_parm = { ‘svd’ : True }</dd>
</dl>
<p>limit – convergence threshold.</p>
<dl class="docutils">
<dt>max_iter     – If the algorithms does not achieve convergence within</dt>
<dd>max_iter iterations raise an Exception. Should be
larger than 100.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.TDSEPNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._adjust_ica_sfa_coeff">
<code class="descname">_adjust_ica_sfa_coeff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._adjust_ica_sfa_coeff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._do_sweep">
<code class="descname">_do_sweep</code><span class="sig-paren">(</span><em>covs</em>, <em>Q</em>, <em>prev_contrast</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._do_sweep" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._fix_covs">
<code class="descname">_fix_covs</code><span class="sig-paren">(</span><em>covs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._fix_covs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._fmt_prog_info">
<code class="descname">_fmt_prog_info</code><span class="sig-paren">(</span><em>sweep</em>, <em>pert</em>, <em>contrast</em>, <em>sfa=None</em>, <em>ica=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._fmt_prog_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._get_contrast">
<code class="descname">_get_contrast</code><span class="sig-paren">(</span><em>covs</em>, <em>bica_bsfa=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._get_contrast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._get_eye">
<code class="descname">_get_eye</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._get_eye" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._get_rnd_permutation">
<code class="descname">_get_rnd_permutation</code><span class="sig-paren">(</span><em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._get_rnd_permutation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._get_rnd_rotation">
<code class="descname">_get_rnd_rotation</code><span class="sig-paren">(</span><em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._get_rnd_rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>Support floating point types with size larger or equal than 64 bits.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._givens_angle">
<code class="descname">_givens_angle</code><span class="sig-paren">(</span><em>i</em>, <em>j</em>, <em>covs</em>, <em>bica_bsfa=None</em>, <em>complete=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._givens_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._givens_angle_case1">
<code class="descname">_givens_angle_case1</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>covs</em>, <em>bica_bsfa</em>, <em>complete=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._givens_angle_case1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._givens_angle_case2">
<code class="descname">_givens_angle_case2</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>covs</em>, <em>bica_bsfa</em>, <em>complete=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._givens_angle_case2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._optimize">
<code class="descname">_optimize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._optimize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>covs=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/ica_nodes.html#TDSEPNode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.TDSEPNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>If the node is used on large datasets it may be wise to first
learn the covariance matrices, and then tune the parameters
until a suitable parameter set has been found (learning the
covariance matrices is the slowest part in this case).  This
could be done for example in the following way (assuming the
data is already white):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">covs</span><span class="o">=</span><span class="p">[</span><span class="n">mdp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">DelayCovarianceMatrix</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>      <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">covs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">))]</span>
</pre></div>
</div>
<p>You can then initialize the ISFANode with the desired parameters,
do a fake training with some random data to set the internal
node structure and then call stop_training with the stored covariance
matrices. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span> <span class="o">=</span> <span class="n">ISFANode</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="o">.....</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx_rand</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span><span class="o">.</span><span class="n">stop_training</span><span class="p">(</span><span class="n">covs</span><span class="o">=</span><span class="n">covs</span><span class="p">)</span>
</pre></div>
</div>
<p>This trick has been used in the paper to apply ISFA to surrogate
matrices, i.e. covariance matrices that were not learnt on a
real dataset.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.TDSEPNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.get_projmatrix">
<code class="descname">get_projmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.get_projmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the projection matrix.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.get_recmatrix">
<code class="descname">get_recmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.get_recmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the back-projection matrix (i.e. the reconstruction matrix).
Note that if the unknown sources are white, this is a good
approximation of the mixing matrix (up to a permutation matrix).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id21"><span class="problematic" id="id22">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.TDSEPNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.TDSEPNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>covs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>If the node is used on large datasets it may be wise to first
learn the covariance matrices, and then tune the parameters
until a suitable parameter set has been found (learning the
covariance matrices is the slowest part in this case).  This
could be done for example in the following way (assuming the
data is already white):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">covs</span><span class="o">=</span><span class="p">[</span><span class="n">mdp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">DelayCovarianceMatrix</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>      <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">covs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">))]</span>
</pre></div>
</div>
<p>You can then initialize the ISFANode with the desired parameters,
do a fake training with some random data to set the internal
node structure and then call stop_training with the stored covariance
matrices. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span> <span class="o">=</span> <span class="n">ISFANode</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="o">.....</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx_rand</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span><span class="o">.</span><span class="n">stop_training</span><span class="p">(</span><span class="n">covs</span><span class="o">=</span><span class="n">covs</span><span class="p">)</span>
</pre></div>
</div>
<p>This trick has been used in the paper to apply ISFA to surrogate
matrices, i.e. covariance matrices that were not learnt on a
real dataset.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TDSEPNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.TDSEPNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TDSEPNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TDSEPNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.JADENode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">JADENode</code><span class="sig-paren">(</span><em>limit=0.001</em>, <em>max_it=1000</em>, <em>verbose=False</em>, <em>whitened=False</em>, <em>white_comp=None</em>, <em>white_parm=None</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.ICANode</span></code></p>
<p>Perform Independent Component Analysis using the JADE algorithm.
Note that JADE is a batch-algorithm. This means that it needs
all input data before it can start and compute the ICs.
The algorithm is here given as a Node for convenience, but it
actually accumulates all inputs it receives. Remember that to avoid
running out of memory when you have many components and many time samples.</p>
<p>JADE does not support the telescope mode.</p>
<p>Main references:</p>
<blockquote>
<div><ul class="simple">
<li>Cardoso, Jean-Francois and Souloumiac, Antoine (1993).
Blind beamforming for non Gaussian signals.
Radar and Signal Processing, IEE Proceedings F, 140(6): 362-370.</li>
<li>Cardoso, Jean-Francois (1999).
High-order contrasts for independent component analysis.
Neural Computation, 11(1): 157-192.</li>
</ul>
</div></blockquote>
<p>Original code contributed by:
Gabriel Beckers (2008).</p>
<p>History:</p>
<ul class="simple">
<li>May 2005    version 1.8 for MATLAB released by Jean-Francois Cardoso</li>
<li>Dec 2007    MATLAB version 1.8 ported to Python/NumPy by Gabriel Beckers</li>
<li>Feb 15 2008 Python/NumPy version adapted for MDP by Gabriel Beckers</li>
</ul>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.JADENode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.JADENode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.JADENode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': '\n    Perform Independent Component Analysis using the JADE algorithm.\n    Note that JADE is a batch-algorithm. This means that it needs\n    all input data before it can start and compute the ICs.\n    The algorithm is here given as a Node for convenience, but it\n    actually accumulates all inputs it receives. Remember that to avoid\n    running out of memory when you have many components and many time samples.\n\n    JADE does not support the telescope mode.\n\n    Main references:\n    \n      * Cardoso, Jean-Francois and Souloumiac, Antoine (1993).\n        Blind beamforming for non Gaussian signals.\n        Radar and Signal Processing, IEE Proceedings F, 140(6): 362-370.\n      * Cardoso, Jean-Francois (1999).\n        High-order contrasts for independent component analysis.\n        Neural Computation, 11(1): 157-192.\n\n    Original code contributed by: \n    Gabriel Beckers (2008).\n\n    History:\n    \n    - May 2005    version 1.8 for MATLAB released by Jean-Francois Cardoso\n    - Dec 2007    MATLAB version 1.8 ported to Python/NumPy by Gabriel Beckers\n    - Feb 15 2008 Python/NumPy version adapted for MDP by Gabriel Beckers\n    ', '__init__': &lt;function JADENode.__init__&gt;, 'core': &lt;function JADENode.core&gt;})</em><a class="headerlink" href="#mdp.nodes.JADENode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.JADENode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.JADENode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.JADENode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.JADENode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.JADENode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>limit=0.001</em>, <em>max_it=1000</em>, <em>verbose=False</em>, <em>whitened=False</em>, <em>white_comp=None</em>, <em>white_parm=None</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input arguments:</p>
<p>General:</p>
<dl class="docutils">
<dt>whitened – Set whitened == True if input data are already whitened.</dt>
<dd>Otherwise the node will whiten the data itself</dd>
<dt>white_comp – If whitened == False, you can set ‘white_comp’ to the</dt>
<dd>number of whitened components to keep during the
calculation (i.e., the input dimensions are reduced to
white_comp by keeping the components of largest variance).</dd>
<dt>white_parm – a dictionary with additional parameters for whitening.</dt>
<dd>It is passed directly to the WhiteningNode constructor.
Ex: white_parm = { ‘svd’ : True }</dd>
</dl>
<p>limit – convergence threshold.</p>
<p>Specific for JADE:</p>
<p>max_it – maximum number of iterations</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.JADENode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.JADENode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.JADENode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.JADENode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.JADENode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.JADENode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id23"><span class="problematic" id="id24">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Whiten data if needed and call the ‘core’ routine to perform ICA.
Take care of telescope-mode if needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.JADENode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.core">
<code class="descname">core</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.core" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the core routine of the ICANode. Each subclass must
define this function to return the achieved convergence value.
This function is also responsible for setting the ICA filters
matrix self.filters.
Note that the matrix self.filters is applied to the right of the
matrix containing input data. This is the transposed of the matrix
defining the linear transformation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.JADENode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.get_projmatrix">
<code class="descname">get_projmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.get_projmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the projection matrix.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.get_recmatrix">
<code class="descname">get_recmatrix</code><span class="sig-paren">(</span><em>transposed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.get_recmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the back-projection matrix (i.e. the reconstruction matrix).
Note that if the unknown sources are white, this is a good
approximation of the mixing matrix (up to a permutation matrix).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id25"><span class="problematic" id="id26">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.JADENode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.JADENode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.JADENode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.JADENode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Whiten data if needed and call the ‘core’ routine to perform ICA.
Take care of telescope-mode if needed.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.JADENode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.JADENode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.JADENode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.JADENode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.SFANode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">SFANode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>include_last_sample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Extract the slowly varying components from the input data.
More information about Slow Feature Analysis can be found in
Wiskott, L. and Sejnowski, T.J., Slow Feature Analysis: Unsupervised
Learning of Invariances, Neural Computation, 14(4):715-770 (2002).</p>
<p><strong>Instance variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.avg</span></code></dt>
<dd>Mean of the input data (available after training)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.sf</span></code></dt>
<dd>Matrix of the SFA filters (available after training)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.d</span></code></dt>
<dd>Delta values corresponding to the SFA components (generalized
eigenvalues). [See the docs of the <code class="docutils literal notranslate"><span class="pre">get_eta_values</span></code> method for
more information]</dd>
</dl>
</div></blockquote>
<p><strong>Special arguments for constructor</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code></dt>
<dd><p class="first">If <code class="docutils literal notranslate"><span class="pre">False</span></code> the <cite>train</cite> method discards the last sample in every
chunk during training when calculating the covariance matrix.
The last sample is in this case only used for calculating the
covariance matrix of the derivatives. The switch should be set
to <code class="docutils literal notranslate"><span class="pre">False</span></code> if you plan to train with several small chunks. For
example we can split a sequence (index is time):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_1</span> <span class="n">x_2</span> <span class="n">x_3</span> <span class="n">x_4</span>
</pre></div>
</div>
<p>in smaller parts like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_1</span> <span class="n">x_2</span>
<span class="n">x_2</span> <span class="n">x_3</span>
<span class="n">x_3</span> <span class="n">x_4</span>
</pre></div>
</div>
<p>The SFANode will see 3 derivatives for the temporal covariance
matrix, and the first 3 points for the spatial covariance matrix.
Of course you will need to use a generator that <em>connects</em> the
small chunks (the last sample needs to be sent again in the next
chunk). If <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> was True, depending on the
generator you use, you would either get:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_1</span> <span class="n">x_2</span>
<span class="n">x_2</span> <span class="n">x_3</span>
<span class="n">x_3</span> <span class="n">x_4</span>
</pre></div>
</div>
<p>in which case the last sample of every chunk would be used twice
when calculating the covariance matrix, or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_1</span> <span class="n">x_2</span>
<span class="n">x_3</span> <span class="n">x_4</span>
</pre></div>
</div>
<p>in which case you loose the derivative between <code class="docutils literal notranslate"><span class="pre">x_3</span></code> and <code class="docutils literal notranslate"><span class="pre">x_2</span></code>.</p>
<p>If you plan to train with a single big chunk leave
<code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> to the default value, i.e. <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p class="last">You can even change this behaviour during training. Just set the
corresponding switch in the <cite>train</cite> method.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.SFANode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.SFANode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.SFANode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Extract the slowly varying components from the input data.\n    More information about Slow Feature Analysis can be found in\n    Wiskott, L. and Sejnowski, T.J., Slow Feature Analysis: Unsupervised\n    Learning of Invariances, Neural Computation, 14(4):715-770 (2002).\n\n    **Instance variables of interest**\n\n      ``self.avg``\n          Mean of the input data (available after training)\n\n      ``self.sf``\n          Matrix of the SFA filters (available after training)\n\n      ``self.d``\n          Delta values corresponding to the SFA components (generalized\n          eigenvalues). [See the docs of the ``get_eta_values`` method for\n          more information]\n\n    **Special arguments for constructor**\n\n      ``include_last_sample``\n          If ``False`` the `train` method discards the last sample in every\n          chunk during training when calculating the covariance matrix.\n          The last sample is in this case only used for calculating the\n          covariance matrix of the derivatives. The switch should be set\n          to ``False`` if you plan to train with several small chunks. For\n          example we can split a sequence (index is time)::\n\n            x_1 x_2 x_3 x_4\n\n          in smaller parts like this::\n\n            x_1 x_2\n            x_2 x_3\n            x_3 x_4\n\n          The SFANode will see 3 derivatives for the temporal covariance\n          matrix, and the first 3 points for the spatial covariance matrix.\n          Of course you will need to use a generator that *connects* the\n          small chunks (the last sample needs to be sent again in the next\n          chunk). If ``include_last_sample`` was True, depending on the\n          generator you use, you would either get::\n\n             x_1 x_2\n             x_2 x_3\n             x_3 x_4\n\n          in which case the last sample of every chunk would be used twice\n          when calculating the covariance matrix, or::\n\n             x_1 x_2\n             x_3 x_4\n\n          in which case you loose the derivative between ``x_3`` and ``x_2``.\n\n          If you plan to train with a single big chunk leave\n          ``include_last_sample`` to the default value, i.e. ``True``.\n\n          You can even change this behaviour during training. Just set the\n          corresponding switch in the `train` method.\n    ', '__init__': &lt;function SFANode.__init__&gt;, 'time_derivative': &lt;function SFANode.time_derivative&gt;, '_set_range': &lt;function SFANode._set_range&gt;, '_check_train_args': &lt;function SFANode._check_train_args&gt;, '_train': &lt;function SFANode._train&gt;, '_stop_training': &lt;function SFANode._stop_training&gt;, '_execute': &lt;function SFANode._execute&gt;, '_inverse': &lt;function SFANode._inverse&gt;, 'get_eta_values': &lt;function SFANode.get_eta_values&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;, 'inverse': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.SFANode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.SFANode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.SFANode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.SFANode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.SFANode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.SFANode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>include_last_sample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.SFANode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.SFANode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.SFANode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.SFANode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.SFANode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.SFANode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFANode._check_train_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFANode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFANode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFANode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output of the slowest functions.
If ‘n’ is an integer, then use the first ‘n’ slowest components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id27"><span class="problematic" id="id28">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFANode._inverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFANode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._set_range">
<code class="descname">_set_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFANode._set_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFANode._set_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFANode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFANode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>include_last_sample=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFANode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFANode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.SFANode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.SFANode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output of the slowest functions.
If ‘n’ is an integer, then use the first ‘n’ slowest components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.get_eta_values">
<code class="descname">get_eta_values</code><span class="sig-paren">(</span><em>t=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.get_eta_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the eta values of the slow components learned during
the training phase. If the training phase has not been completed
yet, call <cite>stop_training</cite>.</p>
<p>The delta value of a signal is a measure of its temporal
variation, and is defined as the mean of the derivative squared,
i.e. delta(x) = mean(dx/dt(t)^2).  delta(x) is zero if
x is a constant signal, and increases if the temporal variation
of the signal is bigger.</p>
<p>The eta value is a more intuitive measure of temporal variation,
defined as
eta(x) = t/(2*pi) * sqrt(delta(x))
If x is a signal of length ‘t’ which consists of a sine function
that accomplishes exactly N oscillations, then eta(x)=N.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>t</dt>
<dd><p class="first">Sampling frequency in Hz.</p>
<p class="last">The original definition in (Wiskott and Sejnowski, 2002)
is obtained for t = number of training data points, while
for t=1 (default), this corresponds to the beta-value defined in
(Berkes and Wiskott, 2005).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id29"><span class="problematic" id="id30">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.SFANode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.SFANode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.SFANode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.SFANode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFANode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.SFANode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.time_derivative">
<code class="descname">time_derivative</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.time_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the linear approximation of the time derivative.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFANode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>include_last_sample=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFANode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.SFA2Node">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">SFA2Node</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>include_last_sample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.SFANode" title="mdp.nodes.SFANode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.SFANode</span></code></a></p>
<p>Get an input signal, expand it in the space of
inhomogeneous polynomials of degree 2 and extract its slowly varying
components. The <code class="docutils literal notranslate"><span class="pre">get_quadratic_form</span></code> method returns the input-output
function of one of the learned unit as a <code class="docutils literal notranslate"><span class="pre">QuadraticForm</span></code> object.
See the documentation of <code class="docutils literal notranslate"><span class="pre">mdp.utils.QuadraticForm</span></code> for additional
information.</p>
<p>More information about Slow Feature Analysis can be found in
Wiskott, L. and Sejnowski, T.J., Slow Feature Analysis: Unsupervised
Learning of Invariances, Neural Computation, 14(4):715-770 (2002).</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.SFA2Node.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Get an input signal, expand it in the space of\n    inhomogeneous polynomials of degree 2 and extract its slowly varying\n    components. The ``get_quadratic_form`` method returns the input-output\n    function of one of the learned unit as a ``QuadraticForm`` object.\n    See the documentation of ``mdp.utils.QuadraticForm`` for additional\n    information.\n\n    More information about Slow Feature Analysis can be found in\n    Wiskott, L. and Sejnowski, T.J., Slow Feature Analysis: Unsupervised\n    Learning of Invariances, Neural Computation, 14(4):715-770 (2002).', '__init__': &lt;function SFA2Node.__init__&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_set_input_dim': &lt;function SFA2Node._set_input_dim&gt;, '_train': &lt;function SFA2Node._train&gt;, '_set_range': &lt;function SFA2Node._set_range&gt;, '_stop_training': &lt;function SFA2Node._stop_training&gt;, '_execute': &lt;function SFA2Node._execute&gt;, 'get_quadratic_form': &lt;function SFA2Node.get_quadratic_form&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.SFA2Node.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>include_last_sample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.SFA2Node.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.SFA2Node.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFA2Node._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFA2Node._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output of the slowest functions.
If ‘n’ is an integer, then use the first ‘n’ slowest components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id31"><span class="problematic" id="id32">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFA2Node._set_input_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFA2Node._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._set_range">
<code class="descname">_set_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFA2Node._set_range"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFA2Node._set_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFA2Node._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFA2Node._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>include_last_sample=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/sfa_nodes.html#SFA2Node._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SFA2Node._train" title="Permalink to this definition">¶</a></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.SFA2Node._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.SFA2Node.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output of the slowest functions.
If ‘n’ is an integer, then use the first ‘n’ slowest components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.get_eta_values">
<code class="descname">get_eta_values</code><span class="sig-paren">(</span><em>t=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.get_eta_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the eta values of the slow components learned during
the training phase. If the training phase has not been completed
yet, call <cite>stop_training</cite>.</p>
<p>The delta value of a signal is a measure of its temporal
variation, and is defined as the mean of the derivative squared,
i.e. delta(x) = mean(dx/dt(t)^2).  delta(x) is zero if
x is a constant signal, and increases if the temporal variation
of the signal is bigger.</p>
<p>The eta value is a more intuitive measure of temporal variation,
defined as
eta(x) = t/(2*pi) * sqrt(delta(x))
If x is a signal of length ‘t’ which consists of a sine function
that accomplishes exactly N oscillations, then eta(x)=N.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>t</dt>
<dd><p class="first">Sampling frequency in Hz.</p>
<p class="last">The original definition in (Wiskott and Sejnowski, 2002)
is obtained for t = number of training data points, while
for t=1 (default), this corresponds to the beta-value defined in
(Berkes and Wiskott, 2005).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.get_quadratic_form">
<code class="descname">get_quadratic_form</code><span class="sig-paren">(</span><em>nr</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.get_quadratic_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix H, the vector f and the constant c of the
quadratic form 1/2 x’Hx + f’x + c that defines the output
of the component ‘nr’ of the SFA node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id33"><span class="problematic" id="id34">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.SFA2Node.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.SFA2Node.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.SFA2Node.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.SFA2Node.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SFA2Node.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.SFA2Node.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.time_derivative">
<code class="descname">time_derivative</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.time_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the linear approximation of the time derivative.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SFA2Node.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>include_last_sample=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SFA2Node.train" title="Permalink to this definition">¶</a></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.ISFANode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">ISFANode</code><span class="sig-paren">(</span><em>lags=1</em>, <em>sfa_ica_coeff=(1.0</em>, <em>1.0)</em>, <em>icaweights=None</em>, <em>sfaweights=None</em>, <em>whitened=False</em>, <em>white_comp=None</em>, <em>white_parm=None</em>, <em>eps_contrast=1e-06</em>, <em>max_iter=10000</em>, <em>RP=None</em>, <em>verbose=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Perform Independent Slow Feature Analysis on the input data.</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.RP</span></code></dt>
<dd>The global rotation-permutation matrix. This is the filter
applied on input_data to get output_data</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.RPC</span></code></dt>
<dd>The <em>complete</em> global rotation-permutation matrix. This
is a matrix of dimension input_dim x input_dim (the ‘outer space’
is retained)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.covs</span></code></dt>
<dd><p class="first">A <cite>mdp.utils.MultipleCovarianceMatrices</cite> instance containing
the current time-delayed covariance matrices of the input_data.
After convergence the uppermost <code class="docutils literal notranslate"><span class="pre">output_dim</span></code> x <code class="docutils literal notranslate"><span class="pre">output_dim</span></code>
submatrices should be almost diagonal.</p>
<p><code class="docutils literal notranslate"><span class="pre">self.covs[n-1]</span></code> is the covariance matrix relative to the <code class="docutils literal notranslate"><span class="pre">n</span></code>-th
time-lag</p>
<p>Note: they are not cleared after convergence. If you need to free
some memory, you can safely delete them with:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">covs</span>
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.initial_contrast</span></code></dt>
<dd>A dictionary with the starting contrast and the SFA and ICA parts of
it.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.final_contrast</span></code></dt>
<dd>Like the above but after convergence.</dd>
</dl>
</div></blockquote>
<p>Note: If you intend to use this node for large datasets please have
a look at the <code class="docutils literal notranslate"><span class="pre">stop_training</span></code> method documentation for
speeding things up.</p>
<p>References:
Blaschke, T. , Zito, T., and Wiskott, L. (2007).
Independent Slow Feature Analysis and Nonlinear Blind Source Separation.
Neural Computation 19(4):994-1021 (2007)
<a class="reference external" href="http://itb.biologie.hu-berlin.de/~wiskott/Publications/BlasZitoWisk2007-ISFA-NeurComp.pdf">http://itb.biologie.hu-berlin.de/~wiskott/Publications/BlasZitoWisk2007-ISFA-NeurComp.pdf</a></p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.ISFANode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': &quot;\n    Perform Independent Slow Feature Analysis on the input data.\n\n    **Internal variables of interest**\n\n      ``self.RP``\n          The global rotation-permutation matrix. This is the filter\n          applied on input_data to get output_data\n\n      ``self.RPC``\n          The *complete* global rotation-permutation matrix. This\n          is a matrix of dimension input_dim x input_dim (the 'outer space'\n          is retained)\n\n      ``self.covs``\n          A `mdp.utils.MultipleCovarianceMatrices` instance containing\n          the current time-delayed covariance matrices of the input_data.\n          After convergence the uppermost ``output_dim`` x ``output_dim``\n          submatrices should be almost diagonal.\n          \n          ``self.covs[n-1]`` is the covariance matrix relative to the ``n``-th\n          time-lag\n            \n          Note: they are not cleared after convergence. If you need to free\n          some memory, you can safely delete them with::\n          \n              &gt;&gt;&gt; del self.covs\n\n      ``self.initial_contrast``\n          A dictionary with the starting contrast and the SFA and ICA parts of\n          it.\n\n      ``self.final_contrast``\n          Like the above but after convergence.\n\n    Note: If you intend to use this node for large datasets please have\n    a look at the ``stop_training`` method documentation for\n    speeding things up.\n\n    References:\n    Blaschke, T. , Zito, T., and Wiskott, L. (2007).\n    Independent Slow Feature Analysis and Nonlinear Blind Source Separation.\n    Neural Computation 19(4):994-1021 (2007)\n    http://itb.biologie.hu-berlin.de/~wiskott/Publications/BlasZitoWisk2007-ISFA-NeurComp.pdf\n    &quot;, '__init__': &lt;function ISFANode.__init__&gt;, '_get_supported_dtypes': &lt;function ISFANode._get_supported_dtypes&gt;, '_set_dtype': &lt;function ISFANode._set_dtype&gt;, '_set_input_dim': &lt;function ISFANode._set_input_dim&gt;, '_train': &lt;function ISFANode._train&gt;, '_execute': &lt;function ISFANode._execute&gt;, '_inverse': &lt;function ISFANode._inverse&gt;, '_fmt_prog_info': &lt;function ISFANode._fmt_prog_info&gt;, '_get_eye': &lt;function ISFANode._get_eye&gt;, '_get_rnd_rotation': &lt;function ISFANode._get_rnd_rotation&gt;, '_get_rnd_permutation': &lt;function ISFANode._get_rnd_permutation&gt;, '_givens_angle': &lt;function ISFANode._givens_angle&gt;, '_givens_angle_case2': &lt;function ISFANode._givens_angle_case2&gt;, '_givens_angle_case1': &lt;function ISFANode._givens_angle_case1&gt;, '_get_contrast': &lt;function ISFANode._get_contrast&gt;, '_adjust_ica_sfa_coeff': &lt;function ISFANode._adjust_ica_sfa_coeff&gt;, '_fix_covs': &lt;function ISFANode._fix_covs&gt;, '_optimize': &lt;function ISFANode._optimize&gt;, '_do_sweep': &lt;function ISFANode._do_sweep&gt;, '_stop_training': &lt;function ISFANode._stop_training&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;, 'inverse': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.ISFANode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>lags=1</em>, <em>sfa_ica_coeff=(1.0</em>, <em>1.0)</em>, <em>icaweights=None</em>, <em>sfaweights=None</em>, <em>whitened=False</em>, <em>white_comp=None</em>, <em>white_parm=None</em>, <em>eps_contrast=1e-06</em>, <em>max_iter=10000</em>, <em>RP=None</em>, <em>verbose=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Independent Slow Feature Analysis.</p>
<p>The notation is the same used in the paper by Blaschke et al. Please
refer to the paper for more information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>lags</dt>
<dd><p class="first last">list of time-lags to generate the time-delayed covariance
matrices (in the paper this is the set of   au). If
lags is an integer, time-lags 1,2,…,’lags’ are used.
Note that time-lag == 0 (instantaneous correlation) is
always implicitly used.</p>
</dd>
<dt>sfa_ica_coeff</dt>
<dd><p class="first last">a list of float with two entries, which defines the
weights of the SFA and ICA part of the objective
function. They are called b_{SFA} and b_{ICA} in the
paper.</p>
</dd>
<dt>sfaweights</dt>
<dd><p class="first last">weighting factors for the covariance matrices relative
to the SFA part of the objective function (called
kappa_{SFA}^{      au} in the paper). Default is
[1., 0., …, 0.]
For possible values see the description of icaweights.</p>
</dd>
<dt>icaweights</dt>
<dd><p class="first">weighting factors for the cov matrices relative
to the ICA part of the objective function (called
kappa_{ICA}^{      au} in the paper). Default is 1.
Possible values are:</p>
<ul class="last simple">
<li>an integer <code class="docutils literal notranslate"><span class="pre">n</span></code>: all matrices are weighted the same
(note that it does not make sense to have <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">!=</span> <span class="pre">1</span></code>)</li>
<li>a list or array of floats of <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">==</span> <span class="pre">len(lags)</span></code>:
each element of the list is used for weighting the
corresponding matrix</li>
<li><code class="docutils literal notranslate"><span class="pre">None</span></code>: use the default values.</li>
</ul>
</dd>
<dt>whitened</dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">True</span></code> if input data is already white, <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise (the data will be whitened internally).</p>
</dd>
<dt>white_comp</dt>
<dd><p class="first last">If whitened is false, you can set <code class="docutils literal notranslate"><span class="pre">white_comp</span></code> to the
number of whitened components to keep during the
calculation (i.e., the input dimensions are reduced to
<code class="docutils literal notranslate"><span class="pre">white_comp</span></code> by keeping the components of largest variance).</p>
</dd>
<dt>white_parm</dt>
<dd><p class="first last">a dictionary with additional parameters for whitening.
It is passed directly to the WhiteningNode constructor.
Ex: white_parm = { ‘svd’ : True }</p>
</dd>
<dt>eps_contrast</dt>
<dd><p class="first last">Convergence is achieved when the relative
improvement in the contrast is below this threshold.
Values in the range [1E-4, 1E-10] are usually
reasonable.</p>
</dd>
<dt>max_iter</dt>
<dd><p class="first last">If the algorithms does not achieve convergence within
max_iter iterations raise an Exception. Should be
larger than 100.</p>
</dd>
<dt>RP</dt>
<dd><p class="first last">Starting rotation-permutation matrix. It is an
input_dim x input_dim matrix used to initially rotate the
input components. If not set, the identity matrix is used.
In the paper this is used to start the algorithm at the
SFA solution (which is often quite near to the optimum).</p>
</dd>
<dt>verbose</dt>
<dd><p class="first last">print progress information during convergence. This can
slow down the algorithm, but it’s the only way to see
the rate of improvement and immediately spot if something
is going wrong.</p>
</dd>
<dt>output_dim</dt>
<dd><p class="first last">sets the number of independent components that have to
be extracted. Note that if this is not smaller than
input_dim, the problem is solved linearly and SFA
would give the same solution only much faster.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.ISFANode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.ISFANode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._adjust_ica_sfa_coeff">
<code class="descname">_adjust_ica_sfa_coeff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._adjust_ica_sfa_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._adjust_ica_sfa_coeff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._do_sweep">
<code class="descname">_do_sweep</code><span class="sig-paren">(</span><em>covs</em>, <em>Q</em>, <em>prev_contrast</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._do_sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._do_sweep" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._fix_covs">
<code class="descname">_fix_covs</code><span class="sig-paren">(</span><em>covs=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._fix_covs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._fix_covs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._fmt_prog_info">
<code class="descname">_fmt_prog_info</code><span class="sig-paren">(</span><em>sweep</em>, <em>pert</em>, <em>contrast</em>, <em>sfa=None</em>, <em>ica=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._fmt_prog_info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._fmt_prog_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._get_contrast">
<code class="descname">_get_contrast</code><span class="sig-paren">(</span><em>covs</em>, <em>bica_bsfa=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._get_contrast"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._get_contrast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._get_eye">
<code class="descname">_get_eye</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._get_eye"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._get_eye" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._get_rnd_permutation">
<code class="descname">_get_rnd_permutation</code><span class="sig-paren">(</span><em>dim</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._get_rnd_permutation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._get_rnd_permutation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._get_rnd_rotation">
<code class="descname">_get_rnd_rotation</code><span class="sig-paren">(</span><em>dim</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._get_rnd_rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._get_rnd_rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>Support floating point types with size larger or equal than 64 bits.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._givens_angle">
<code class="descname">_givens_angle</code><span class="sig-paren">(</span><em>i</em>, <em>j</em>, <em>covs</em>, <em>bica_bsfa=None</em>, <em>complete=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._givens_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._givens_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._givens_angle_case1">
<code class="descname">_givens_angle_case1</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>covs</em>, <em>bica_bsfa</em>, <em>complete=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._givens_angle_case1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._givens_angle_case1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._givens_angle_case2">
<code class="descname">_givens_angle_case2</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>covs</em>, <em>bica_bsfa</em>, <em>complete=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._givens_angle_case2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._givens_angle_case2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._inverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._optimize">
<code class="descname">_optimize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._optimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._optimize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._set_dtype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._set_input_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>covs=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>If the node is used on large datasets it may be wise to first
learn the covariance matrices, and then tune the parameters
until a suitable parameter set has been found (learning the
covariance matrices is the slowest part in this case).  This
could be done for example in the following way (assuming the
data is already white):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">covs</span><span class="o">=</span><span class="p">[</span><span class="n">mdp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">DelayCovarianceMatrix</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>      <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">covs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">))]</span>
</pre></div>
</div>
<p>You can then initialize the ISFANode with the desired parameters,
do a fake training with some random data to set the internal
node structure and then call stop_training with the stored covariance
matrices. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span> <span class="o">=</span> <span class="n">ISFANode</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="o">.....</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx_rand</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span><span class="o">.</span><span class="n">stop_training</span><span class="p">(</span><span class="n">covs</span><span class="o">=</span><span class="n">covs</span><span class="p">)</span>
</pre></div>
</div>
<p>This trick has been used in the paper to apply ISFA to surrogate
matrices, i.e. covariance matrices that were not learnt on a
real dataset.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/isfa_nodes.html#ISFANode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.ISFANode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.ISFANode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.ISFANode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id35"><span class="problematic" id="id36">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.ISFANode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.ISFANode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.ISFANode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.ISFANode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>covs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>If the node is used on large datasets it may be wise to first
learn the covariance matrices, and then tune the parameters
until a suitable parameter set has been found (learning the
covariance matrices is the slowest part in this case).  This
could be done for example in the following way (assuming the
data is already white):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">covs</span><span class="o">=</span><span class="p">[</span><span class="n">mdp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">DelayCovarianceMatrix</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>      <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">covs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">))]</span>
</pre></div>
</div>
<p>You can then initialize the ISFANode with the desired parameters,
do a fake training with some random data to set the internal
node structure and then call stop_training with the stored covariance
matrices. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span> <span class="o">=</span> <span class="n">ISFANode</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="o">.....</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx_rand</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isfa</span><span class="o">.</span><span class="n">stop_training</span><span class="p">(</span><span class="n">covs</span><span class="o">=</span><span class="n">covs</span><span class="p">)</span>
</pre></div>
</div>
<p>This trick has been used in the paper to apply ISFA to surrogate
matrices, i.e. covariance matrices that were not learnt on a
real dataset.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.ISFANode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.ISFANode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.ISFANode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.ISFANode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.XSFANode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">XSFANode</code><span class="sig-paren">(</span><em>basic_exp=None</em>, <em>intern_exp=None</em>, <em>svd=False</em>, <em>verbose=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Perform Non-linear Blind Source Separation using Slow Feature Analysis.</p>
<p>This node is designed to iteratively extract statistically
independent sources from (in principle) arbitrary invertible
nonlinear mixtures. The method relies on temporal correlations in
the sources and consists of a combination of nonlinear SFA and a
projection algorithm. More details can be found in the reference
given below (once it’s published).</p>
<p>The node has multiple training phases. The number of training
phases depends on the number of sources that must be
extracted. The recommended way of training this node is through a
container flow:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flow</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">Flow</span><span class="p">([</span><span class="n">XSFANode</span><span class="p">()])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flow</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>doing so will automatically train all training phases. The argument
<code class="docutils literal notranslate"><span class="pre">x</span></code> to the <code class="docutils literal notranslate"><span class="pre">Flow.train</span></code> method can be an array or a list of iterables
(see the section about Iterators in the MDP tutorial for more info).</p>
<p>If the number of training samples is large, you may run into
memory problems: use data iterators and chunk training to reduce
memory usage.</p>
<p>If you need to debug training and/or execution of this node, the
suggested approach is to use the capabilities of BiMDP. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flow</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">Flow</span><span class="p">([</span><span class="n">XSFANode</span><span class="p">()])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tr_filename</span> <span class="o">=</span> <span class="n">bimdp</span><span class="o">.</span><span class="n">show_training</span><span class="p">(</span><span class="n">flow</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span> <span class="n">data_iterators</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ex_filename</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">bimdp</span><span class="o">.</span><span class="n">show_execution</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>this will run training and execution with bimdp inspection. Snapshots
of the internal flow state for each training phase and execution step
will be opened in a web brower and presented as a slideshow.</p>
<p>References:
Sprekeler, H., Zito, T., and Wiskott, L. (2009).
An Extension of Slow Feature Analysis for Nonlinear Blind Source Separation.
Journal of Machine Learning Research.
<a class="reference external" href="http://cogprints.org/7056/1/SprekelerZitoWiskott-Cogprints-2010.pdf">http://cogprints.org/7056/1/SprekelerZitoWiskott-Cogprints-2010.pdf</a></p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.XSFANode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': &quot;Perform Non-linear Blind Source Separation using Slow Feature Analysis.\n\n    This node is designed to iteratively extract statistically\n    independent sources from (in principle) arbitrary invertible\n    nonlinear mixtures. The method relies on temporal correlations in\n    the sources and consists of a combination of nonlinear SFA and a\n    projection algorithm. More details can be found in the reference\n    given below (once it's published).\n\n    The node has multiple training phases. The number of training\n    phases depends on the number of sources that must be\n    extracted. The recommended way of training this node is through a\n    container flow::\n\n       &gt;&gt;&gt; flow = mdp.Flow([XSFANode()])\n       &gt;&gt;&gt; flow.train(x)\n\n    doing so will automatically train all training phases. The argument\n    ``x`` to the ``Flow.train`` method can be an array or a list of iterables\n    (see the section about Iterators in the MDP tutorial for more info).\n\n    If the number of training samples is large, you may run into\n    memory problems: use data iterators and chunk training to reduce\n    memory usage.\n\n    If you need to debug training and/or execution of this node, the\n    suggested approach is to use the capabilities of BiMDP. For example::\n\n       &gt;&gt;&gt; flow = mdp.Flow([XSFANode()])\n       &gt;&gt;&gt; tr_filename = bimdp.show_training(flow=flow, data_iterators=x)\n       &gt;&gt;&gt; ex_filename, out = bimdp.show_execution(flow, x=x)\n\n    this will run training and execution with bimdp inspection. Snapshots\n    of the internal flow state for each training phase and execution step\n    will be opened in a web brower and presented as a slideshow.\n\n    References:\n    Sprekeler, H., Zito, T., and Wiskott, L. (2009).\n    An Extension of Slow Feature Analysis for Nonlinear Blind Source Separation.\n    Journal of Machine Learning Research. \n    http://cogprints.org/7056/1/SprekelerZitoWiskott-Cogprints-2010.pdf\n    &quot;, '__init__': &lt;function XSFANode.__init__&gt;, 'flow': &lt;property object&gt;, '_get_train_seq': &lt;function XSFANode._get_train_seq&gt;, '_set_input_dim': &lt;function XSFANode._set_input_dim&gt;, '_check_train_args': &lt;function XSFANode._check_train_args&gt;, '_initialize_internal_flow': &lt;function XSFANode._initialize_internal_flow&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_train': &lt;function XSFANode._train&gt;, '_stop_training': &lt;function XSFANode._stop_training&gt;, '_execute': &lt;function XSFANode._execute&gt;, '_get_source_extractor': &lt;function XSFANode._get_source_extractor&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.XSFANode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>basic_exp=None</em>, <em>intern_exp=None</em>, <em>svd=False</em>, <em>verbose=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Keywords:</th><td class="field-body"><dl class="first last docutils">
<dt>basic_exp</dt>
<dd><p class="first">a tuple <code class="docutils literal notranslate"><span class="pre">(node,</span> <span class="pre">args,</span> <span class="pre">kwargs)</span></code> defining the node used for
the basic nonlinear expansion.  It is assumed that the
mixture is linearly invertible after this expansion. The
higher the complexity of the nonlinearity, the higher are
the chances of inverting the unknown mixture. On the
other hand, high complexity of the nonlinear expansion
increases the danger of numeric instabilities, which can
cause singularities in the simulation or errors in the
source estimation. The trade-off has to be evaluated
carefully.</p>
<p class="last">Default: <code class="docutils literal notranslate"><span class="pre">(mdp.nodes.PolynomialExpansionNode,</span> <span class="pre">(2,</span> <span class="pre">),</span> <span class="pre">{})</span></code></p>
</dd>
<dt>intern_exp</dt>
<dd><p class="first">a tuple <code class="docutils literal notranslate"><span class="pre">(node,</span> <span class="pre">args,</span> <span class="pre">kwargs)</span></code> defining the node used
for the internal nonlinear expansion of the estimated
sources to be removed from the input space.  The same
trade-off as for basic_exp is valid here.</p>
<p class="last">Default: <code class="docutils literal notranslate"><span class="pre">(mdp.nodes.PolynomialExpansionNode,</span> <span class="pre">(10,</span> <span class="pre">),</span> <span class="pre">{})</span></code></p>
</dd>
<dt>svd</dt>
<dd><p class="first last">enable Singular Value Decomposition for normalization
and regularization. Use it if the node complains about
singular covariance matrices.</p>
</dd>
<dt>verbose</dt>
<dd><p class="first">show some progress during training.</p>
<p class="last">Default: False</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.XSFANode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.XSFANode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#XSFANode._check_train_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.XSFANode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#XSFANode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.XSFANode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._get_source_extractor">
<code class="descname">_get_source_extractor</code><span class="sig-paren">(</span><em>dim</em>, <em>nsources</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#XSFANode._get_source_extractor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.XSFANode._get_source_extractor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id37"><span class="problematic" id="id38">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#XSFANode._get_train_seq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.XSFANode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._initialize_internal_flow">
<code class="descname">_initialize_internal_flow</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#XSFANode._initialize_internal_flow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.XSFANode._initialize_internal_flow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#XSFANode._set_input_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.XSFANode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#XSFANode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.XSFANode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#XSFANode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.XSFANode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.XSFANode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.XSFANode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.flow">
<code class="descname">flow</code><a class="headerlink" href="#mdp.nodes.XSFANode.flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only internal flow property.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id39"><span class="problematic" id="id40">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.XSFANode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.XSFANode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.XSFANode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.XSFANode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.XSFANode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.XSFANode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.XSFANode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.XSFANode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.FDANode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">FDANode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Perform a (generalized) Fisher Discriminant Analysis of its
input. It is a supervised node that implements FDA using a
generalized eigenvalue approach.</p>
<p>FDANode has two training phases and is supervised so make sure to
pay attention to the following points when you train it:</p>
<ul class="simple">
<li>call the <code class="docutils literal notranslate"><span class="pre">train</span></code> method with <em>two</em> arguments: the input data
and the labels (see the doc string of the <code class="docutils literal notranslate"><span class="pre">train</span></code> method for details).</li>
<li>if you are training the node by hand, call the <code class="docutils literal notranslate"><span class="pre">train</span></code> method twice.</li>
<li>if you are training the node using a flow (recommended), the
only argument to <code class="docutils literal notranslate"><span class="pre">Flow.train</span></code> must be a list of
<code class="docutils literal notranslate"><span class="pre">(data_point,</span> <span class="pre">label)</span></code> tuples or an iterator returning lists of
such tuples, <em>not</em> a generator.  The <code class="docutils literal notranslate"><span class="pre">Flow.train</span></code> function can be
called just once as usual, since it takes care of <em>rewinding</em> the iterator
to perform the second training step.</li>
</ul>
<p>More information on Fisher Discriminant Analysis can be found for
example in C. Bishop, Neural Networks for Pattern Recognition,
Oxford Press, pp. 105-112.</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.avg</span></code></dt>
<dd>Mean of the input data (available after training)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.v</span></code></dt>
<dd>Transposed of the projection matrix, so that
<code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">dot(input-self.avg,</span> <span class="pre">self.v)</span></code> (available after training).</dd>
</dl>
</div></blockquote>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.FDANode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.FDANode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.FDANode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Perform a (generalized) Fisher Discriminant Analysis of its\n    input. It is a supervised node that implements FDA using a\n    generalized eigenvalue approach.\n\n    FDANode has two training phases and is supervised so make sure to\n    pay attention to the following points when you train it:\n\n    - call the ``train`` method with *two* arguments: the input data\n      and the labels (see the doc string of the ``train`` method for details).\n\n    - if you are training the node by hand, call the ``train`` method twice.\n\n    - if you are training the node using a flow (recommended), the\n      only argument to ``Flow.train`` must be a list of\n      ``(data_point, label)`` tuples or an iterator returning lists of\n      such tuples, *not* a generator.  The ``Flow.train`` function can be\n      called just once as usual, since it takes care of *rewinding* the iterator\n      to perform the second training step.\n\n    More information on Fisher Discriminant Analysis can be found for\n    example in C. Bishop, Neural Networks for Pattern Recognition,\n    Oxford Press, pp. 105-112.\n\n    **Internal variables of interest**\n\n      ``self.avg``\n          Mean of the input data (available after training)\n\n      ``self.v``\n          Transposed of the projection matrix, so that\n          ``output = dot(input-self.avg, self.v)`` (available after training).\n    ', '_get_train_seq': &lt;function FDANode._get_train_seq&gt;, '__init__': &lt;function FDANode.__init__&gt;, '_check_train_args': &lt;function FDANode._check_train_args&gt;, '_train_means': &lt;function FDANode._train_means&gt;, '_stop_means': &lt;function FDANode._stop_means&gt;, '_update_means': &lt;function FDANode._update_means&gt;, '_train_fda': &lt;function FDANode._train_fda&gt;, '_stop_fda': &lt;function FDANode._stop_fda&gt;, '_update_SW': &lt;function FDANode._update_SW&gt;, '_train': &lt;function FDANode._train&gt;, '_execute': &lt;function FDANode._execute&gt;, '_inverse': &lt;function FDANode._inverse&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;, 'inverse': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.FDANode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.FDANode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.FDANode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.FDANode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.FDANode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.FDANode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>If the input dimension and the output dimension are
unspecified, they will be set when the <cite>train</cite> or <cite>execute</cite>
method is called for the first time.
If dtype is unspecified, it will be inherited from the data
it receives at the first call of <cite>train</cite> or <cite>execute</cite>.</p>
<p>Every subclass must take care of up- or down-casting the internal
structures to match this argument (use <cite>_refcast</cite> private
method when possible).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.FDANode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.FDANode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.FDANode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.FDANode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.FDANode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.FDANode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._check_train_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output of the FDA projection.</p>
<p>If ‘n’ is an integer, then use the first ‘n’ components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id41"><span class="problematic" id="id42">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._get_train_seq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._inverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._stop_fda">
<code class="descname">_stop_fda</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._stop_fda"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._stop_fda" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the eigenvalue problem for the total covariance.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._stop_means">
<code class="descname">_stop_means</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._stop_means"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._stop_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the class means.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data ‘x’.</p>
<dl class="docutils">
<dt>x – a matrix having different variables on different columns</dt>
<dd>and observations on the rows.</dd>
<dt>label – can be a list, tuple or array of labels (one for each data</dt>
<dd>point) or a single label, in which case all input data is assigned
to the same class.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._train_fda">
<code class="descname">_train_fda</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._train_fda"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._train_fda" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather data for the overall and within-class covariance</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._train_means">
<code class="descname">_train_means</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._train_means"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._train_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather data to compute the means and number of elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.FDANode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._update_SW">
<code class="descname">_update_SW</code><span class="sig-paren">(</span><em>x</em>, <em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._update_SW"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._update_SW" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the covariance matrix of the class means.</p>
<p>x – Data points from a single class.
label – The label for that class.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode._update_means">
<code class="descname">_update_means</code><span class="sig-paren">(</span><em>x</em>, <em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/fda_nodes.html#FDANode._update_means"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FDANode._update_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal variables that store the data for the means.</p>
<p>x – Data points from a single class.
label – The label for that class.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.FDANode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output of the FDA projection.</p>
<p>If ‘n’ is an integer, then use the first ‘n’ components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id43"><span class="problematic" id="id44">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.FDANode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.FDANode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.FDANode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.FDANode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FDANode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.FDANode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FDANode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FDANode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data ‘x’.</p>
<dl class="docutils">
<dt>x – a matrix having different variables on different columns</dt>
<dd>and observations on the rows.</dd>
<dt>label – can be a list, tuple or array of labels (one for each data</dt>
<dd>point) or a single label, in which case all input data is assigned
to the same class.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.FANode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">FANode</code><span class="sig-paren">(</span><em>tol=0.0001</em>, <em>max_cycles=100</em>, <em>verbose=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Perform Factor Analysis.</p>
<p>The current implementation should be most efficient for long
data sets: the sufficient statistics are collected in the
training phase, and all EM-cycles are performed at
its end.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">execute</span></code> method returns the Maximum A Posteriori estimate
of the latent variables. The <code class="docutils literal notranslate"><span class="pre">generate_input</span></code> method generates
observations from the prior distribution.</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.mu</span></code></dt>
<dd>Mean of the input data (available after training)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.A</span></code></dt>
<dd>Generating weights (available after training)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.E_y_mtx</span></code></dt>
<dd>Weights for Maximum A Posteriori inference</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.sigma</span></code></dt>
<dd>Vector of estimated variance of the noise
for all input components</dd>
</dl>
</div></blockquote>
<p>More information about Factor Analysis can be found in
Max Welling’s classnotes:
<a class="reference external" href="http://www.ics.uci.edu/~welling/classnotes/classnotes.html">http://www.ics.uci.edu/~welling/classnotes/classnotes.html</a> ,
in the chapter ‘Linear Models’.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.FANode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.FANode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.FANode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': &quot;Perform Factor Analysis.\n\n    The current implementation should be most efficient for long\n    data sets: the sufficient statistics are collected in the\n    training phase, and all EM-cycles are performed at\n    its end.\n\n    The ``execute`` method returns the Maximum A Posteriori estimate\n    of the latent variables. The ``generate_input`` method generates\n    observations from the prior distribution.\n\n    **Internal variables of interest**\n\n      ``self.mu``\n          Mean of the input data (available after training)\n\n      ``self.A``\n          Generating weights (available after training)\n\n      ``self.E_y_mtx``\n          Weights for Maximum A Posteriori inference\n\n      ``self.sigma``\n          Vector of estimated variance of the noise\n          for all input components\n\n    More information about Factor Analysis can be found in\n    Max Welling's classnotes:\n    http://www.ics.uci.edu/~welling/classnotes/classnotes.html ,\n    in the chapter 'Linear Models'.\n    &quot;, '__init__': &lt;function FANode.__init__&gt;, '_train': &lt;function FANode._train&gt;, '_stop_training': &lt;function FANode._stop_training&gt;, '_execute': &lt;function FANode._execute&gt;, 'is_invertible': &lt;staticmethod object&gt;, 'generate_input': &lt;function FANode.generate_input&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.FANode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.FANode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.FANode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.FANode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.FANode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.FANode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>tol=0.0001</em>, <em>max_cycles=100</em>, <em>verbose=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>tol</dt>
<dd><p class="first last">tolerance (minimum change in log-likelihood before exiting
the EM algorithm)</p>
</dd>
<dt>max_cycles</dt>
<dd><p class="first last">maximum number of EM cycles</p>
</dd>
<dt>verbose</dt>
<dd><p class="first last">if true, print log-likelihood during the EM-cycles</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.FANode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.FANode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.FANode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.FANode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.FANode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.FANode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/em_nodes.html#FANode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FANode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id45"><span class="problematic" id="id46">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/em_nodes.html#FANode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FANode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/em_nodes.html#FANode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.FANode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.FANode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.FANode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.generate_input">
<code class="descname">generate_input</code><span class="sig-paren">(</span><em>len_or_y=1</em>, <em>noise=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.generate_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate data from the prior distribution.</p>
<p>If the training phase has not been completed yet, call stop_training.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><dl class="first last docutils">
<dt>len_or_y</dt>
<dd><p class="first last">If integer, it specified the number of observation
to generate. If array, it is used as a set of samples
of the latent variables</p>
</dd>
<dt>noise</dt>
<dd><p class="first last">if true, generation includes the estimated noise</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id47"><span class="problematic" id="id48">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.FANode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.FANode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.FANode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.FANode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.FANode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.FANode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.FANode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.FANode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.RBMNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">RBMNode</code><span class="sig-paren">(</span><em>hidden_dim</em>, <em>visible_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Restricted Boltzmann Machine node. An RBM is an undirected
probabilistic network with binary variables. The graph is
bipartite into observed (<em>visible</em>) and hidden (<em>latent</em>) variables.</p>
<p>By default, the <code class="docutils literal notranslate"><span class="pre">execute</span></code> method returns the <em>probability</em> of
one of the hiden variables being equal to 1 given the input.</p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">sample_v</span></code> method to sample from the observed variables
given a setting of the hidden variables, and <code class="docutils literal notranslate"><span class="pre">sample_h</span></code> to do the
opposite. The <code class="docutils literal notranslate"><span class="pre">energy</span></code> method can be used to compute the energy
of a given setting of all variables.</p>
<p>The network is trained by Contrastive Divergence, as described in
Hinton, G. E. (2002). Training products of experts by minimizing
contrastive divergence. Neural Computation, 14(8):1711-1800</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.w</span></code></dt>
<dd>Generative weights between hidden and observed variables</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.bv</span></code></dt>
<dd>bias vector of the observed variables</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.bh</span></code></dt>
<dd>bias vector of the hidden variables</dd>
</dl>
</div></blockquote>
<p>For more information on RBMs, see
Geoffrey E. Hinton (2007) Boltzmann machine. Scholarpedia, 2(5):1668</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.RBMNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Restricted Boltzmann Machine node. An RBM is an undirected\n    probabilistic network with binary variables. The graph is\n    bipartite into observed (*visible*) and hidden (*latent*) variables.\n\n    By default, the ``execute`` method returns the *probability* of\n    one of the hiden variables being equal to 1 given the input.\n\n    Use the ``sample_v`` method to sample from the observed variables\n    given a setting of the hidden variables, and ``sample_h`` to do the\n    opposite. The ``energy`` method can be used to compute the energy\n    of a given setting of all variables.\n\n    The network is trained by Contrastive Divergence, as described in\n    Hinton, G. E. (2002). Training products of experts by minimizing\n    contrastive divergence. Neural Computation, 14(8):1711-1800\n\n    **Internal variables of interest**\n\n      ``self.w``\n          Generative weights between hidden and observed variables\n\n      ``self.bv``\n          bias vector of the observed variables\n\n      ``self.bh``\n          bias vector of the hidden variables\n\n    For more information on RBMs, see\n    Geoffrey E. Hinton (2007) Boltzmann machine. Scholarpedia, 2(5):1668\n    ', '__init__': &lt;function RBMNode.__init__&gt;, '_init_weights': &lt;function RBMNode._init_weights&gt;, '_sample_h': &lt;function RBMNode._sample_h&gt;, '_sample_v': &lt;function RBMNode._sample_v&gt;, '_train': &lt;function RBMNode._train&gt;, '_stop_training': &lt;function RBMNode._stop_training&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_pre_inversion_checks': &lt;function RBMNode._pre_inversion_checks&gt;, 'sample_h': &lt;function RBMNode.sample_h&gt;, 'sample_v': &lt;function RBMNode.sample_v&gt;, '_energy': &lt;function RBMNode._energy&gt;, 'energy': &lt;function RBMNode.energy&gt;, '_execute': &lt;function RBMNode._execute&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.RBMNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>hidden_dim</em>, <em>visible_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>hidden_dim</dt>
<dd><p class="first last">number of hidden variables</p>
</dd>
<dt>visible_dim</dt>
<dd><p class="first last">number of observed variables</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.RBMNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.RBMNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._energy">
<code class="descname">_energy</code><span class="sig-paren">(</span><em>v</em>, <em>h</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/rbm_nodes.html#RBMNode._energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBMNode._energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>v</em>, <em>return_probs=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/rbm_nodes.html#RBMNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBMNode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>return_probs</cite> is True, returns the probability of the
hidden variables h[n,i] being 1 given the observations v[n,:].
If <cite>return_probs</cite> is False, return a sample from that probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id49"><span class="problematic" id="id50">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._init_weights">
<code class="descname">_init_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/rbm_nodes.html#RBMNode._init_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBMNode._init_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/rbm_nodes.html#RBMNode._pre_inversion_checks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBMNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._sample_h">
<code class="descname">_sample_h</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/rbm_nodes.html#RBMNode._sample_h"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBMNode._sample_h" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._sample_v">
<code class="descname">_sample_v</code><span class="sig-paren">(</span><em>h</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/rbm_nodes.html#RBMNode._sample_v"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBMNode._sample_v" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/rbm_nodes.html#RBMNode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBMNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>v</em>, <em>n_updates=1</em>, <em>epsilon=0.1</em>, <em>decay=0.0</em>, <em>momentum=0.0</em>, <em>update_with_ph=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/rbm_nodes.html#RBMNode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBMNode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>v</cite>.
The training is performed using Contrastive Divergence (CD).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>v</dt>
<dd><p class="first last">a binary matrix having different variables on different columns
and observations on the rows</p>
</dd>
<dt>n_updates</dt>
<dd><p class="first last">number of CD iterations. Default value: 1</p>
</dd>
<dt>epsilon</dt>
<dd><p class="first last">learning rate. Default value: 0.1</p>
</dd>
<dt>decay</dt>
<dd><p class="first last">weight decay term. Default value: 0.</p>
</dd>
<dt>momentum</dt>
<dd><p class="first last">momentum term. Default value: 0.</p>
</dd>
<dt>update_with_ph</dt>
<dd><p class="first last">In his code, G.Hinton updates the hidden biases using the
probability of the hidden unit activations instead of a
sample from it. This is in order to speed up sequential
learning of RBMs. Set this to False to use the samples instead.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.RBMNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.RBMNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.energy">
<code class="descname">energy</code><span class="sig-paren">(</span><em>v</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the energy of the RBM given observed variables state <cite>v</cite> and
hidden variables state <cite>h</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>v</em>, <em>return_probs=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>return_probs</cite> is True, returns the probability of the
hidden variables h[n,i] being 1 given the observations v[n,:].
If <cite>return_probs</cite> is False, return a sample from that probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id51"><span class="problematic" id="id52">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.RBMNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.RBMNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.RBMNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.RBMNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.sample_h">
<code class="descname">sample_h</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.sample_h" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the hidden variables given observations v.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple <code class="docutils literal notranslate"><span class="pre">(prob_h,</span> <span class="pre">h)</span></code>, where <code class="docutils literal notranslate"><span class="pre">prob_h[n,i]</span></code> is the
probability that variable <code class="docutils literal notranslate"><span class="pre">i</span></code> is one given the observations
<code class="docutils literal notranslate"><span class="pre">v[n,:]</span></code>, and <code class="docutils literal notranslate"><span class="pre">h[n,i]</span></code> is a sample from the posterior probability.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.sample_v">
<code class="descname">sample_v</code><span class="sig-paren">(</span><em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.sample_v" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the observed variables given hidden variable state h.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple <code class="docutils literal notranslate"><span class="pre">(prob_v,</span> <span class="pre">v)</span></code>, where <code class="docutils literal notranslate"><span class="pre">prob_v[n,i]</span></code> is the
probability that variable <code class="docutils literal notranslate"><span class="pre">i</span></code> is one given the hidden
variables <code class="docutils literal notranslate"><span class="pre">h[n,:]</span></code>, and <code class="docutils literal notranslate"><span class="pre">v[n,i]</span></code> is a sample from that
conditional probability.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.RBMNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>v</em>, <em>n_updates=1</em>, <em>epsilon=0.1</em>, <em>decay=0.0</em>, <em>momentum=0.0</em>, <em>update_with_ph=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>v</cite>.
The training is performed using Contrastive Divergence (CD).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>v</dt>
<dd><p class="first last">a binary matrix having different variables on different columns
and observations on the rows</p>
</dd>
<dt>n_updates</dt>
<dd><p class="first last">number of CD iterations. Default value: 1</p>
</dd>
<dt>epsilon</dt>
<dd><p class="first last">learning rate. Default value: 0.1</p>
</dd>
<dt>decay</dt>
<dd><p class="first last">weight decay term. Default value: 0.</p>
</dd>
<dt>momentum</dt>
<dd><p class="first last">momentum term. Default value: 0.</p>
</dd>
<dt>update_with_ph</dt>
<dd><p class="first last">In his code, G.Hinton updates the hidden biases using the
probability of the hidden unit activations instead of a
sample from it. This is in order to speed up sequential
learning of RBMs. Set this to False to use the samples instead.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.RBMWithLabelsNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">RBMWithLabelsNode</code><span class="sig-paren">(</span><em>hidden_dim</em>, <em>labels_dim</em>, <em>visible_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.RBMNode" title="mdp.nodes.RBMNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.RBMNode</span></code></a></p>
<p>Restricted Boltzmann Machine with softmax labels. An RBM is an
undirected probabilistic network with binary variables. In this
case, the node is partitioned into a set of observed (<em>visible</em>)
variables, a set of hidden (<em>latent</em>) variables, and a set of
label variables (also observed), only one of which is active at
any time. The node is able to learn associations between the
visible variables and the labels.</p>
<p>By default, the <code class="docutils literal notranslate"><span class="pre">execute</span></code> method returns the <em>probability</em> of
one of the hiden variables being equal to 1 given the input.</p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">sample_v</span></code> method to sample from the observed variables
(visible and labels) given a setting of the hidden variables, and
<code class="docutils literal notranslate"><span class="pre">sample_h</span></code> to do the opposite. The <code class="docutils literal notranslate"><span class="pre">energy</span></code> method can be used
to compute the energy of a given setting of all variables.</p>
<p>The network is trained by Contrastive Divergence, as described in
Hinton, G. E. (2002). Training products of experts by minimizing
contrastive divergence. Neural Computation, 14(8):1711-1800</p>
<p>Internal variables of interest:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.w</span></code></dt>
<dd>Generative weights between hidden and observed variables</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.bv</span></code></dt>
<dd>bias vector of the observed variables</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.bh</span></code></dt>
<dd>bias vector of the hidden variables</dd>
</dl>
</div></blockquote>
<p>For more information on RBMs with labels, see</p>
<blockquote>
<div><ul class="simple">
<li>Geoffrey E. Hinton (2007) Boltzmann machine. Scholarpedia, 2(5):1668.</li>
<li>Hinton, G. E, Osindero, S., and Teh, Y. W. (2006). A fast learning
algorithm for deep belief nets. Neural Computation, 18:1527-1554.</li>
</ul>
</div></blockquote>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Restricted Boltzmann Machine with softmax labels. An RBM is an\n    undirected probabilistic network with binary variables. In this\n    case, the node is partitioned into a set of observed (*visible*)\n    variables, a set of hidden (*latent*) variables, and a set of\n    label variables (also observed), only one of which is active at\n    any time. The node is able to learn associations between the\n    visible variables and the labels.\n\n    By default, the ``execute`` method returns the *probability* of\n    one of the hiden variables being equal to 1 given the input.\n\n    Use the ``sample_v`` method to sample from the observed variables\n    (visible and labels) given a setting of the hidden variables, and\n    ``sample_h`` to do the opposite. The ``energy`` method can be used\n    to compute the energy of a given setting of all variables.\n\n    The network is trained by Contrastive Divergence, as described in\n    Hinton, G. E. (2002). Training products of experts by minimizing\n    contrastive divergence. Neural Computation, 14(8):1711-1800\n\n    Internal variables of interest:\n\n      ``self.w``\n          Generative weights between hidden and observed variables\n\n      ``self.bv``\n          bias vector of the observed variables\n\n      ``self.bh``\n          bias vector of the hidden variables\n\n    For more information on RBMs with labels, see\n    \n      * Geoffrey E. Hinton (2007) Boltzmann machine. Scholarpedia, 2(5):1668.\n      * Hinton, G. E, Osindero, S., and Teh, Y. W. (2006). A fast learning\n        algorithm for deep belief nets. Neural Computation, 18:1527-1554.\n    ', '__init__': &lt;function RBMWithLabelsNode.__init__&gt;, '_set_input_dim': &lt;function RBMWithLabelsNode._set_input_dim&gt;, '_sample_v': &lt;function RBMWithLabelsNode._sample_v&gt;, 'sample_h': &lt;function RBMWithLabelsNode.sample_h&gt;, 'sample_v': &lt;function RBMWithLabelsNode.sample_v&gt;, 'energy': &lt;function RBMWithLabelsNode.energy&gt;, 'execute': &lt;function RBMWithLabelsNode.execute&gt;, 'is_invertible': &lt;staticmethod object&gt;, 'train': &lt;function RBMWithLabelsNode.train&gt;})</em><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>hidden_dim</em>, <em>labels_dim</em>, <em>visible_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>hidden_dim</dt>
<dd>number of hidden variables</dd>
<dt>visible_dim</dt>
<dd>number of observed variables</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._energy">
<code class="descname">_energy</code><span class="sig-paren">(</span><em>v</em>, <em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>v</em>, <em>return_probs=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>return_probs</cite> is True, returns the probability of the
hidden variables h[n,i] being 1 given the observations v[n,:].
If <cite>return_probs</cite> is False, return a sample from that probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id53"><span class="problematic" id="id54">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._init_weights">
<code class="descname">_init_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._init_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._sample_h">
<code class="descname">_sample_h</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._sample_h" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._sample_v">
<code class="descname">_sample_v</code><span class="sig-paren">(</span><em>h</em>, <em>sample_l=False</em>, <em>concatenate=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/rbm_nodes.html#RBMWithLabelsNode._sample_v"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._sample_v" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/rbm_nodes.html#RBMWithLabelsNode._set_input_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>v</em>, <em>n_updates=1</em>, <em>epsilon=0.1</em>, <em>decay=0.0</em>, <em>momentum=0.0</em>, <em>update_with_ph=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>v</cite>.
The training is performed using Contrastive Divergence (CD).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>v</dt>
<dd><p class="first last">a binary matrix having different variables on different columns
and observations on the rows</p>
</dd>
<dt>n_updates</dt>
<dd><p class="first last">number of CD iterations. Default value: 1</p>
</dd>
<dt>epsilon</dt>
<dd><p class="first last">learning rate. Default value: 0.1</p>
</dd>
<dt>decay</dt>
<dd><p class="first last">weight decay term. Default value: 0.</p>
</dd>
<dt>momentum</dt>
<dd><p class="first last">momentum term. Default value: 0.</p>
</dd>
<dt>update_with_ph</dt>
<dd><p class="first last">In his code, G.Hinton updates the hidden biases using the
probability of the hidden unit activations instead of a
sample from it. This is in order to speed up sequential
learning of RBMs. Set this to False to use the samples instead.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.energy">
<code class="descname">energy</code><span class="sig-paren">(</span><em>v</em>, <em>h</em>, <em>l</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the energy of the RBM given observed variables state <cite>v</cite>
and <cite>l</cite>, and hidden variables state <cite>h</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>v</em>, <em>l</em>, <em>return_probs=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>return_probs</cite> is True, returns the probability of the
hidden variables h[n,i] being 1 given the observations v[n,:]
and l[n,:].  If <cite>return_probs</cite> is False, return a sample from
that probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id55"><span class="problematic" id="id56">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.RBMWithLabelsNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.RBMWithLabelsNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.sample_h">
<code class="descname">sample_h</code><span class="sig-paren">(</span><em>v</em>, <em>l</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.sample_h" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the hidden variables given observations <cite>v</cite> and labels <cite>l</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple <code class="docutils literal notranslate"><span class="pre">(prob_h,</span> <span class="pre">h)</span></code>, where <code class="docutils literal notranslate"><span class="pre">prob_h[n,i]</span></code> is the
probability that variable <code class="docutils literal notranslate"><span class="pre">i</span></code> is one given the observations
<code class="docutils literal notranslate"><span class="pre">v[n,:]</span></code> and the labels <code class="docutils literal notranslate"><span class="pre">l[n,:]</span></code>, and <code class="docutils literal notranslate"><span class="pre">h[n,i]</span></code> is a sample
from the posterior probability.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.sample_v">
<code class="descname">sample_v</code><span class="sig-paren">(</span><em>h</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.sample_v" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample the observed variables given hidden variable state <cite>h</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a tuple <code class="docutils literal notranslate"><span class="pre">(prob_v,</span> <span class="pre">probs_l,</span> <span class="pre">v,</span> <span class="pre">l)</span></code>, where <code class="docutils literal notranslate"><span class="pre">prob_v[n,i]</span></code>
is the probability that the visible variable <code class="docutils literal notranslate"><span class="pre">i</span></code> is one given
the hidden variables <code class="docutils literal notranslate"><span class="pre">h[n,:]</span></code>, and <code class="docutils literal notranslate"><span class="pre">v[n,i]</span></code> is a sample from
that conditional probability. <code class="docutils literal notranslate"><span class="pre">prob_l</span></code> and <code class="docutils literal notranslate"><span class="pre">l</span></code> have similar
interpretations for the label variables. Note that the labels are
activated using a softmax function, so that only one label can be
active at any time.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBMWithLabelsNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBMWithLabelsNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>v</em>, <em>l</em>, <em>n_updates=1</em>, <em>epsilon=0.1</em>, <em>decay=0.0</em>, <em>momentum=0.0</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBMWithLabelsNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the visible data <cite>v</cite>
and the labels <cite>l</cite>.
The training is performed using Contrastive Divergence (CD).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>v</dt>
<dd><p class="first last">a binary matrix having different variables on different columns
and observations on the rows</p>
</dd>
<dt>l</dt>
<dd><p class="first last">a binary matrix having different variables on different columns
and observations on the rows. Only one value per row should be 1.</p>
</dd>
<dt>n_updates</dt>
<dd><p class="first last">number of CD iterations. Default value: 1</p>
</dd>
<dt>epsilon</dt>
<dd><p class="first last">learning rate. Default value: 0.1</p>
</dd>
<dt>decay</dt>
<dd><p class="first last">weight decay term. Default value: 0.</p>
</dd>
<dt>momentum</dt>
<dd><p class="first last">momentum term. Default value: 0.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.GrowingNeuralGasNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">GrowingNeuralGasNode</code><span class="sig-paren">(</span><em>start_poss=None</em>, <em>eps_b=0.2</em>, <em>eps_n=0.006</em>, <em>max_age=50</em>, <em>lambda_=100</em>, <em>alpha=0.5</em>, <em>d=0.995</em>, <em>max_nodes=2147483647</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Learn the topological structure of the input data by building a
corresponding graph approximation.</p>
<p>The algorithm expands on the original Neural Gas algorithm
(see mdp.nodes NeuralGasNode) in that the algorithm adds new nodes are
added to the graph as more data becomes available. Im this way,
if the growth rate is appropriate, one can avoid overfitting  or
underfitting the data.</p>
<p>More information about the Growing Neural Gas algorithm can be found in
B. Fritzke, A Growing Neural Gas Network Learns Topologies, in G. Tesauro,
D. S. Touretzky, and T. K. Leen (editors), Advances in Neural Information
Processing Systems 7, pages 625-632. MIT Press, Cambridge MA, 1995.</p>
<p><strong>Attributes and methods of interest</strong></p>
<ul class="simple">
<li>graph – The corresponding <cite>mdp.graph.Graph</cite> object</li>
</ul>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Learn the topological structure of the input data by building a\n    corresponding graph approximation.\n\n    The algorithm expands on the original Neural Gas algorithm\n    (see mdp.nodes NeuralGasNode) in that the algorithm adds new nodes are\n    added to the graph as more data becomes available. Im this way,\n    if the growth rate is appropriate, one can avoid overfitting  or\n    underfitting the data.\n\n    More information about the Growing Neural Gas algorithm can be found in\n    B. Fritzke, A Growing Neural Gas Network Learns Topologies, in G. Tesauro,\n    D. S. Touretzky, and T. K. Leen (editors), Advances in Neural Information\n    Processing Systems 7, pages 625-632. MIT Press, Cambridge MA, 1995.\n\n    **Attributes and methods of interest**\n\n    - graph -- The corresponding `mdp.graph.Graph` object\n    ', '__init__': &lt;function GrowingNeuralGasNode.__init__&gt;, '_set_input_dim': &lt;function GrowingNeuralGasNode._set_input_dim&gt;, '_add_node': &lt;function GrowingNeuralGasNode._add_node&gt;, '_add_edge': &lt;function GrowingNeuralGasNode._add_edge&gt;, '_get_nearest_nodes': &lt;function GrowingNeuralGasNode._get_nearest_nodes&gt;, '_move_node': &lt;function GrowingNeuralGasNode._move_node&gt;, '_remove_old_edges': &lt;function GrowingNeuralGasNode._remove_old_edges&gt;, '_insert_new_node': &lt;function GrowingNeuralGasNode._insert_new_node&gt;, 'get_nodes_position': &lt;function GrowingNeuralGasNode.get_nodes_position&gt;, '_train': &lt;function GrowingNeuralGasNode._train&gt;, 'nearest_neighbor': &lt;function GrowingNeuralGasNode.nearest_neighbor&gt;, 'train': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>start_poss=None</em>, <em>eps_b=0.2</em>, <em>eps_n=0.006</em>, <em>max_age=50</em>, <em>lambda_=100</em>, <em>alpha=0.5</em>, <em>d=0.995</em>, <em>max_nodes=2147483647</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Growing Neural Gas algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>start_poss</dt>
<dd><p class="first last">sequence of two arrays containing the position of the
first two nodes in the GNG graph. If unspecified, the
initial nodes are chosen with a random position generated
from a gaussian distribution with zero mean and unit
variance.</p>
</dd>
<dt>eps_b</dt>
<dd><p class="first">coefficient of movement of the nearest node to a new data
point. Typical values are 0 &lt; eps_b &lt;&lt; 1 .</p>
<p class="last">Default: 0.2</p>
</dd>
<dt>eps_n</dt>
<dd><p class="first">coefficient of movement of the neighbours of the nearest
node to a new data point. Typical values are
0 &lt; eps_n &lt;&lt; eps_b .</p>
<p class="last">Default: 0.006</p>
</dd>
<dt>max_age</dt>
<dd><p class="first">remove an edge after <cite>max_age</cite> updates. Typical values are
10 &lt; max_age &lt; lambda.</p>
<p class="last">Default: 50</p>
</dd>
<dt><cite>lambda_</cite></dt>
<dd><p class="first">insert a new node after <cite>lambda_</cite> steps. Typical values are O(100).</p>
<p class="last">Default: 100</p>
</dd>
<dt>alpha</dt>
<dd><p class="first">when a new node is inserted, multiply the error of the
nodes from which it generated by 0&lt;alpha&lt;1. A typical value
is 0.5.</p>
<p class="last">Default: 0.5</p>
</dd>
<dt>d</dt>
<dd><p class="first">each step the error of the nodes are multiplied by 0&lt;d&lt;1.
Typical values are close to 1.</p>
<p class="last">Default: 0.995</p>
</dd>
<dt>max_nodes</dt>
<dd><p class="first">maximal number of nodes in the graph.</p>
<p class="last">Default: 2^31 - 1</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._add_edge">
<code class="descname">_add_edge</code><span class="sig-paren">(</span><em>from_</em>, <em>to_</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#GrowingNeuralGasNode._add_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._add_edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._add_node">
<code class="descname">_add_node</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#GrowingNeuralGasNode._add_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._add_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._get_nearest_nodes">
<code class="descname">_get_nearest_nodes</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#GrowingNeuralGasNode._get_nearest_nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._get_nearest_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the two nodes in the graph that are nearest to x and their
squared distances. (Return ([node1, node2], [dist1, dist2])</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id57"><span class="problematic" id="id58">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._insert_new_node">
<code class="descname">_insert_new_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#GrowingNeuralGasNode._insert_new_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._insert_new_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a new node in the graph where it is more necessary (i.e.
where the error is the largest).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._move_node">
<code class="descname">_move_node</code><span class="sig-paren">(</span><em>node</em>, <em>x</em>, <em>eps</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#GrowingNeuralGasNode._move_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._move_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Move a node by eps in the direction x.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._remove_old_edges">
<code class="descname">_remove_old_edges</code><span class="sig-paren">(</span><em>edges</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#GrowingNeuralGasNode._remove_old_edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._remove_old_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all edges older than the maximal age.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#GrowingNeuralGasNode._set_input_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#GrowingNeuralGasNode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.get_nodes_position">
<code class="descname">get_nodes_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.get_nodes_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id59"><span class="problematic" id="id60">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.GrowingNeuralGasNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.GrowingNeuralGasNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.nearest_neighbor">
<code class="descname">nearest_neighbor</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.nearest_neighbor" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign each point in the input data to the nearest node in
the graph. Return the list of the nearest node instances, and
the list of distances.
Executing this function will close the training phase if
necessary.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.LLENode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">LLENode</code><span class="sig-paren">(</span><em>k</em>, <em>r=0.001</em>, <em>svd=False</em>, <em>verbose=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Cumulator" title="mdp.Cumulator"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Cumulator</span></code></a></p>
<p>Perform a Locally Linear Embedding analysis on the data.</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.training_projection</span></code></dt>
<dd>The LLE projection of the training data (defined when
training finishes).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.desired_variance</span></code></dt>
<dd>variance limit used to compute intrinsic dimensionality.</dd>
</dl>
</div></blockquote>
<p>Based on the algorithm outlined in <em>An Introduction to Locally
Linear Embedding</em> by L. Saul and S. Roweis, using improvements
suggested in <em>Locally Linear Embedding for Classification</em> by
D. deRidder and R.P.W. Duin.</p>
<p>References: Roweis, S. and Saul, L., Nonlinear dimensionality
reduction by locally linear embedding, Science 290 (5500), pp.
2323-2326, 2000.</p>
<p>Original code contributed by: Jake VanderPlas, University of Washington,</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.LLENode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.LLENode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.LLENode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Perform a Locally Linear Embedding analysis on the data.\n\n    **Internal variables of interest**\n\n      ``self.training_projection``\n          The LLE projection of the training data (defined when\n          training finishes).\n\n      ``self.desired_variance``\n          variance limit used to compute intrinsic dimensionality.\n\n    Based on the algorithm outlined in *An Introduction to Locally\n    Linear Embedding* by L. Saul and S. Roweis, using improvements\n    suggested in *Locally Linear Embedding for Classification* by\n    D. deRidder and R.P.W. Duin.\n\n    References: Roweis, S. and Saul, L., Nonlinear dimensionality\n    reduction by locally linear embedding, Science 290 (5500), pp.\n    2323-2326, 2000.\n\n    Original code contributed by: Jake VanderPlas, University of Washington,\n    ', '__init__': &lt;function LLENode.__init__&gt;, '_stop_training': &lt;function LLENode._stop_training&gt;, '_adjust_output_dim': &lt;function LLENode._adjust_output_dim&gt;, '_execute': &lt;function LLENode._execute&gt;, 'is_trainable': &lt;staticmethod object&gt;, 'is_invertible': &lt;staticmethod object&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.LLENode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.LLENode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.LLENode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.LLENode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.LLENode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.LLENode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>k</em>, <em>r=0.001</em>, <em>svd=False</em>, <em>verbose=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><dl class="first last docutils">
<dt>k</dt>
<dd><p class="first last">number of nearest neighbors to use</p>
</dd>
<dt>r</dt>
<dd><p class="first last">regularization constant; if <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">r</span></code> is automatically
computed using the method presented in deRidder and Duin;
this method involves solving an eigenvalue problem for
every data point, and can slow down the algorithm
If specified, it multiplies the trace of the local covariance
matrix of the distances, as in Saul &amp; Roweis (faster)</p>
</dd>
<dt>svd</dt>
<dd><p class="first last">if true, use SVD to compute the projection matrix;
SVD is slower but more stable</p>
</dd>
<dt>verbose</dt>
<dd><p class="first last">if true, displays information about the progress
of the algorithm</p>
</dd>
<dt>output_dim</dt>
<dd><p class="first last">number of dimensions to output or a float between 0.0 and
1.0. In the latter case, <code class="docutils literal notranslate"><span class="pre">output_dim</span></code> specifies the desired
fraction of variance to be explained, and the final
number of output dimensions is known at the end of
training (e.g., for <code class="docutils literal notranslate"><span class="pre">output_dim=0.95</span></code> the algorithm will
keep as many dimensions as necessary in order to explain
95% of the input variance)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.LLENode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.LLENode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.LLENode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.LLENode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.LLENode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.LLENode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._adjust_output_dim">
<code class="descname">_adjust_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/lle_nodes.html#LLENode._adjust_output_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.LLENode._adjust_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/lle_nodes.html#LLENode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.LLENode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id61"><span class="problematic" id="id62">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/lle_nodes.html#LLENode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.LLENode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the collected data in a single array.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.LLENode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.LLENode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id63"><span class="problematic" id="id64">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.LLENode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.LLENode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.LLENode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.LLENode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the collected data in a single array.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LLENode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.LLENode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LLENode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LLENode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.HLLENode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">HLLENode</code><span class="sig-paren">(</span><em>k</em>, <em>r=0.001</em>, <em>svd=False</em>, <em>verbose=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.LLENode" title="mdp.nodes.LLENode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.LLENode</span></code></a></p>
<p>Perform a Hessian Locally Linear Embedding analysis on the data.</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.training_projection</span></code></dt>
<dd>the HLLE projection of the training data (defined when training
finishes)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">self.desired_variance</span></code></dt>
<dd>variance limit used to compute intrinsic dimensionality.</dd>
</dl>
</div></blockquote>
<p>Implementation based on algorithm outlined in
Donoho, D. L., and Grimes, C., Hessian Eigenmaps: new locally linear
embedding techniques for high-dimensional data, Proceedings of the
National Academy of Sciences 100(10): 5591-5596, 2003.</p>
<p>Original code contributed by: Jake Vanderplas, University of Washington</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.HLLENode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Perform a Hessian Locally Linear Embedding analysis on the data.\n\n    **Internal variables of interest**\n\n      ``self.training_projection``\n          the HLLE projection of the training data (defined when training\n          finishes)\n\n      ``self.desired_variance``\n          variance limit used to compute intrinsic dimensionality.\n\n    Implementation based on algorithm outlined in\n    Donoho, D. L., and Grimes, C., Hessian Eigenmaps: new locally linear\n    embedding techniques for high-dimensional data, Proceedings of the\n    National Academy of Sciences 100(10): 5591-5596, 2003.\n\n    Original code contributed by: Jake Vanderplas, University of Washington\n    ', '__init__': &lt;function HLLENode.__init__&gt;, '_stop_training': &lt;function HLLENode._stop_training&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.HLLENode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>k</em>, <em>r=0.001</em>, <em>svd=False</em>, <em>verbose=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Keyword arguments:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt>k</dt>
<dd><p class="first last">number of nearest neighbors to use; the node will raise
an MDPWarning if k is smaller than
k &gt;= 1 + output_dim + output_dim*(output_dim+1)/2,
because in this case a less efficient computation must be
used, and the ablgorithm can become unstable</p>
</dd>
<dt>r</dt>
<dd><p class="first last">regularization constant; as opposed to LLENode, it is
not possible to compute this constant automatically; it is
only used during execution</p>
</dd>
<dt>svd</dt>
<dd><p class="first last">if true, use SVD to compute the projection matrix;
SVD is slower but more stable</p>
</dd>
<dt>verbose</dt>
<dd><p class="first last">if true, displays information about the progress
of the algorithm</p>
</dd>
<dt>output_dim</dt>
<dd><p class="first last">number of dimensions to output or a float between 0.0
and 1.0. In the latter case, output_dim specifies the
desired fraction of variance to be exaplained, and the
final number of output dimensions is known at the end of
training (e.g., for ‘output_dim=0.95’ the algorithm will
keep as many dimensions as necessary in order to explain
95% of the input variance)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.HLLENode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.HLLENode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._adjust_output_dim">
<code class="descname">_adjust_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._adjust_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id65"><span class="problematic" id="id66">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/lle_nodes.html#HLLENode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.HLLENode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the collected data in a single array.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.HLLENode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.HLLENode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id67"><span class="problematic" id="id68">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.HLLENode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.HLLENode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.HLLENode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.HLLENode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate the collected data in a single array.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HLLENode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.HLLENode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HLLENode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HLLENode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect all input data in a list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.LinearRegressionNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">LinearRegressionNode</code><span class="sig-paren">(</span><em>with_bias=True</em>, <em>use_pinv=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Compute least-square, multivariate linear regression on the input
data, i.e., learn coefficients <code class="docutils literal notranslate"><span class="pre">b_j</span></code> so that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y_i</span> <span class="o">=</span> <span class="n">b_0</span> <span class="o">+</span> <span class="n">b_1</span> <span class="n">x_1</span> <span class="o">+</span> <span class="o">...</span> <span class="n">b_N</span> <span class="n">x_N</span> <span class="p">,</span>
</pre></div>
</div>
<p>for <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">...</span> <span class="pre">M</span></code>, minimizes the square error given the training <code class="docutils literal notranslate"><span class="pre">x</span></code>’s
and <code class="docutils literal notranslate"><span class="pre">y</span></code>’s.</p>
<p>This is a supervised learning node, and requires input data <code class="docutils literal notranslate"><span class="pre">x</span></code> and
target data <code class="docutils literal notranslate"><span class="pre">y</span></code> to be supplied during training (see <code class="docutils literal notranslate"><span class="pre">train</span></code>
docstring).</p>
<p><strong>Internal variables of interest</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">self.beta</span></code></dt>
<dd>The coefficients of the linear regression</dd>
</dl>
</div></blockquote>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': &quot;Compute least-square, multivariate linear regression on the input\n    data, i.e., learn coefficients ``b_j`` so that::\n\n      y_i = b_0 + b_1 x_1 + ... b_N x_N ,\n\n    for ``i = 1 ... M``, minimizes the square error given the training ``x``'s\n    and ``y``'s.\n\n    This is a supervised learning node, and requires input data ``x`` and\n    target data ``y`` to be supplied during training (see ``train``\n    docstring).\n\n    **Internal variables of interest**\n\n      ``self.beta``\n          The coefficients of the linear regression\n    &quot;, '__init__': &lt;function LinearRegressionNode.__init__&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_check_train_args': &lt;function LinearRegressionNode._check_train_args&gt;, '_train': &lt;function LinearRegressionNode._train&gt;, '_stop_training': &lt;function LinearRegressionNode._stop_training&gt;, '_execute': &lt;function LinearRegressionNode._execute&gt;, '_add_constant': &lt;function LinearRegressionNode._add_constant&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>with_bias=True</em>, <em>use_pinv=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><dl class="first last docutils">
<dt>with_bias</dt>
<dd><p class="first">If true, the linear model includes a constant term</p>
<ul class="simple">
<li>True:  y_i = b_0 + b_1 x_1 + … b_N x_N</li>
<li>False: y_i =       b_1 x_1 + … b_N x_N</li>
</ul>
<p class="last">If present, the constant term is stored in the first
column of <code class="docutils literal notranslate"><span class="pre">self.beta</span></code>.</p>
</dd>
<dt>use_pinv</dt>
<dd><p class="first last">If true, uses the pseudo-inverse function to compute
the linear regression coefficients, which is more robust
in some cases</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._add_constant">
<code class="descname">_add_constant</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/regression_nodes.html#LinearRegressionNode._add_constant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._add_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a constant term to the vector ‘x’.
x -&gt; [1 x]</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/regression_nodes.html#LinearRegressionNode._check_train_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/regression_nodes.html#LinearRegressionNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id69"><span class="problematic" id="id70">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/regression_nodes.html#LinearRegressionNode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/regression_nodes.html#LinearRegressionNode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._train" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Additional input arguments</strong></p>
<dl class="docutils">
<dt>y</dt>
<dd>array of size (x.shape[0], output_dim) that contains the observed
output to the input x’s.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id71"><span class="problematic" id="id72">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.LinearRegressionNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.LinearRegressionNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.LinearRegressionNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.LinearRegressionNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.LinearRegressionNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Additional input arguments</strong></p>
<dl class="docutils">
<dt>y</dt>
<dd>array of size (x.shape[0], output_dim) that contains the observed
output to the input x’s.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.QuadraticExpansionNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">QuadraticExpansionNode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.PolynomialExpansionNode" title="mdp.nodes.PolynomialExpansionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.PolynomialExpansionNode</span></code></a></p>
<p>Perform expansion in the space formed by all linear and quadratic
monomials.
<code class="docutils literal notranslate"><span class="pre">QuadraticExpansionNode()</span></code> is equivalent to a
<code class="docutils literal notranslate"><span class="pre">PolynomialExpansionNode(2)</span></code></p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Perform expansion in the space formed by all linear and quadratic\n    monomials.\n    ``QuadraticExpansionNode()`` is equivalent to a\n    ``PolynomialExpansionNode(2)``', '__init__': &lt;function QuadraticExpansionNode.__init__&gt;})</em><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input arguments:
degree – degree of the polynomial space where the input is expanded</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.expanded_dim">
<code class="descname">expanded_dim</code><span class="sig-paren">(</span><em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.expanded_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of a vector of dimension ‘dim’ after
a polynomial expansion of degree ‘self._degree’.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id73"><span class="problematic" id="id74">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.QuadraticExpansionNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.QuadraticExpansionNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.QuadraticExpansionNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.QuadraticExpansionNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.QuadraticExpansionNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.PolynomialExpansionNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">PolynomialExpansionNode</code><span class="sig-paren">(</span><em>degree</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.nodes.expansion_nodes.html#mdp.nodes.expansion_nodes._ExpansionNode" title="mdp.nodes.expansion_nodes._ExpansionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.expansion_nodes._ExpansionNode</span></code></a></p>
<p>Perform expansion in a polynomial space.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Perform expansion in a polynomial space.', '__init__': &lt;function PolynomialExpansionNode.__init__&gt;, '_get_supported_dtypes': &lt;function PolynomialExpansionNode._get_supported_dtypes&gt;, 'expanded_dim': &lt;function PolynomialExpansionNode.expanded_dim&gt;, '_execute': &lt;function PolynomialExpansionNode._execute&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>degree</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input arguments:
degree – degree of the polynomial space where the input is expanded</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/expansion_nodes.html#PolynomialExpansionNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/expansion_nodes.html#PolynomialExpansionNode._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.expanded_dim">
<code class="descname">expanded_dim</code><span class="sig-paren">(</span><em>dim</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.expanded_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of a vector of dimension ‘dim’ after
a polynomial expansion of degree ‘self._degree’.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id75"><span class="problematic" id="id76">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.PolynomialExpansionNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.PolynomialExpansionNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PolynomialExpansionNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PolynomialExpansionNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PolynomialExpansionNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.RBFExpansionNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">RBFExpansionNode</code><span class="sig-paren">(</span><em>centers</em>, <em>sizes</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Expand input space with Gaussian Radial Basis Functions (RBFs).</p>
<p>The input data is filtered through a set of unnormalized Gaussian
filters, i.e.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y_j</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">/</span><span class="n">s_j</span> <span class="o">*</span> <span class="o">||</span><span class="n">x</span> <span class="o">-</span> <span class="n">c_j</span><span class="o">||^</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>for isotropic RBFs, or more in general:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y_j</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">c_j</span><span class="p">)</span><span class="o">^</span><span class="n">T</span> <span class="n">S</span><span class="o">^-</span><span class="mi">1</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">c_j</span><span class="p">))</span>
</pre></div>
</div>
<p>for anisotropic RBFs.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Expand input space with Gaussian Radial Basis Functions (RBFs).\n\n    The input data is filtered through a set of unnormalized Gaussian\n    filters, i.e.::\n\n       y_j = exp(-0.5/s_j * ||x - c_j||^2)\n\n    for isotropic RBFs, or more in general::\n\n       y_j = exp(-0.5 * (x-c_j)^T S^-1 (x-c_j))\n\n    for anisotropic RBFs.\n    ', '__init__': &lt;function RBFExpansionNode.__init__&gt;, 'is_trainable': &lt;staticmethod object&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_init_RBF': &lt;function RBFExpansionNode._init_RBF&gt;, '_execute': &lt;function RBFExpansionNode._execute&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>centers</em>, <em>sizes</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><dl class="first last docutils">
<dt>centers</dt>
<dd><p class="first last">Centers of the RBFs. The dimensionality
of the centers determines the input dimensionality;
the number of centers determines the output
dimensionalities</p>
</dd>
<dt>sizes</dt>
<dd><p class="first">Radius of the RBFs.</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">sizes</span></code> is a list with one element for each RBF, either
a scalar (the variance of the RBFs for isotropic RBFs)
or a covariance matrix (for anisotropic RBFs).
If <code class="docutils literal notranslate"><span class="pre">sizes</span></code> is not a list, the same variance/covariance
is used for all RBFs.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/expansion_nodes.html#RBFExpansionNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id77"><span class="problematic" id="id78">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._init_RBF">
<code class="descname">_init_RBF</code><span class="sig-paren">(</span><em>centers</em>, <em>sizes</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/expansion_nodes.html#RBFExpansionNode._init_RBF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._init_RBF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id79"><span class="problematic" id="id80">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.RBFExpansionNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.RBFExpansionNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.RBFExpansionNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.RBFExpansionNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.RBFExpansionNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.GeneralExpansionNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">GeneralExpansionNode</code><span class="sig-paren">(</span><em>funcs</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.nodes.expansion_nodes.html#mdp.nodes.expansion_nodes._ExpansionNode" title="mdp.nodes.expansion_nodes._ExpansionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.expansion_nodes._ExpansionNode</span></code></a></p>
<p>Expands the input samples by applying to them one or more functions provided.</p>
<p>The functions to be applied are specified by a list [f_0, …, f_k], where
f_i, for 0 &lt;= i &lt;= k, denotes a particular function.
The input data given to these functions is a two-dimensional array and
the output is another two-dimensional array. The dimensionality of the output
should depend only on the dimensionality of the input.
Given a two-dimensional input array x, the output of the node
is then [f_0(x), …, f_k(x)], that is, the concatenation of each one of
the computed arrays f_i(x).</p>
<p>This node has been designed to facilitate nonlinear, fixed but arbitrary
transformations of the data samples within MDP flows.</p>
<p><strong>Example</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mdp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mdp</span> <span class="k">import</span> <span class="n">numx</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">u3</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">numx</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span> <span class="c1">#A simple nonlinear transformation</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">norm2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="c1">#Computes the norm of each sample returning an Nx1 array</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="p">((</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">GeneralExpansionNode</span><span class="p">(</span><span class="n">funcs</span><span class="o">=</span><span class="p">[</span><span class="n">identity</span><span class="p">,</span> <span class="n">u3</span><span class="p">,</span> <span class="n">norm2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[[</span><span class="o">-</span><span class="mf">2.</span>          <span class="mf">2.</span>          <span class="mf">8.</span>          <span class="mf">8.</span>          <span class="mf">2.82842712</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="p">[</span> <span class="mf">0.2</span>         <span class="mf">0.3</span>         <span class="mf">0.008</span>       <span class="mf">0.027</span>       <span class="mf">0.36055513</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span> <span class="p">[</span> <span class="mf">0.6</span>         <span class="mf">1.2</span>         <span class="mf">0.216</span>       <span class="mf">1.728</span>       <span class="mf">1.34164079</span><span class="p">]]</span>
</pre></div>
</div>
<p>Original code contributed by Alberto Escalante.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Expands the input samples by applying to them one or more functions provided.\n    \n    The functions to be applied are specified by a list [f_0, ..., f_k], where \n    f_i, for 0 &lt;= i &lt;= k, denotes a particular function. \n    The input data given to these functions is a two-dimensional array and\n    the output is another two-dimensional array. The dimensionality of the output \n    should depend only on the dimensionality of the input.\n    Given a two-dimensional input array x, the output of the node \n    is then [f_0(x), ..., f_k(x)], that is, the concatenation of each one of \n    the computed arrays f_i(x).\n\n    This node has been designed to facilitate nonlinear, fixed but arbitrary  \n    transformations of the data samples within MDP flows.\n        \n    **Example**::\n   \n        &gt;&gt;&gt; import mdp\n        &gt;&gt;&gt; from mdp import numx\n        \n        &gt;&gt;&gt; def identity(x): return x\n        \n        &gt;&gt;&gt; def u3(x): return numx.absolute(x)**3 #A simple nonlinear transformation\n        \n        &gt;&gt;&gt; def norm2(x): #Computes the norm of each sample returning an Nx1 array\n        &gt;&gt;&gt;     return ((x**2).sum(axis=1)**0.5).reshape((-1,1)) \n          \n        &gt;&gt;&gt; x = numx.array([[-2., 2.], [0.2, 0.3], [0.6, 1.2]])\n        &gt;&gt;&gt; gen = mdp.nodes.GeneralExpansionNode(funcs=[identity, u3, norm2])\n        &gt;&gt;&gt; print(gen.execute(x))\n        &gt;&gt;&gt; [[-2.          2.          8.          8.          2.82842712]\n        &gt;&gt;&gt;  [ 0.2         0.3         0.008       0.027       0.36055513]\n        &gt;&gt;&gt;  [ 0.6         1.2         0.216       1.728       1.34164079]]\n\n    Original code contributed by Alberto Escalante.\n    ', '__init__': &lt;function GeneralExpansionNode.__init__&gt;, 'expanded_dim': &lt;function GeneralExpansionNode.expanded_dim&gt;, 'output_sizes': &lt;function GeneralExpansionNode.output_sizes&gt;, 'is_trainable': &lt;staticmethod object&gt;, 'is_invertible': &lt;staticmethod object&gt;, 'pseudo_inverse': &lt;function GeneralExpansionNode.pseudo_inverse&gt;, '_execute': &lt;function GeneralExpansionNode._execute&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>funcs</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Short argument description:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">funcs</span></code></dt>
<dd>list of functions f_i that realize the expansion.</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/expansion_nodes.html#GeneralExpansionNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id81"><span class="problematic" id="id82">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.expanded_dim">
<code class="descname">expanded_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.expanded_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>The expanded dim is computed by directly applying the expansion
functions f_i to a zero input of dimension n.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id83"><span class="problematic" id="id84">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.GeneralExpansionNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.GeneralExpansionNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.output_sizes">
<code class="descname">output_sizes</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.output_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the individual output sizes of each expansion function
when the input has lenght n.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.pseudo_inverse">
<code class="descname">pseudo_inverse</code><span class="sig-paren">(</span><em>x</em>, <em>use_hint=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.pseudo_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a pseudo inverse of the expansion using
scipy.optimize.</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">use_hint</span></code></dt>
<dd>when calculating a pseudo inverse of the expansion,
the hint determines the starting point for the approximation.
For details on this parameter see the function
<code class="docutils literal notranslate"><span class="pre">invert_exp_funcs2</span></code> in <code class="docutils literal notranslate"><span class="pre">mdp.utils.routines.py</span></code>.</dd>
</dl>
<p>This method requires scipy.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GeneralExpansionNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GeneralExpansionNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GeneralExpansionNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">GrowingNeuralGasExpansionNode</code><span class="sig-paren">(</span><em>start_poss=None</em>, <em>eps_b=0.2</em>, <em>eps_n=0.006</em>, <em>max_age=50</em>, <em>lambda_=100</em>, <em>alpha=0.5</em>, <em>d=0.995</em>, <em>max_nodes=100</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.GrowingNeuralGasNode" title="mdp.nodes.GrowingNeuralGasNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.GrowingNeuralGasNode</span></code></a></p>
<p>Perform a trainable radial basis expansion, where the centers and
sizes of the basis functions are learned through a growing neural
gas.</p>
<blockquote>
<div><dl class="docutils">
<dt>positions of RBFs</dt>
<dd>position of the nodes of the neural gas</dd>
<dt>sizes of the RBFs</dt>
<dd>mean distance to the neighbouring nodes.</dd>
</dl>
</div></blockquote>
<p>Important: Adjust the maximum number of nodes to control the
dimension of the expansion.</p>
<p>More information on this expansion type can be found in:
B. Fritzke.
Growing cell structures-a self-organizing network for unsupervised
and supervised learning. Neural Networks 7, p. 1441–1460 (1994).</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': '\n    Perform a trainable radial basis expansion, where the centers and\n    sizes of the basis functions are learned through a growing neural\n    gas.\n\n      positions of RBFs\n        position of the nodes of the neural gas\n\n      sizes of the RBFs\n        mean distance to the neighbouring nodes.\n\n    Important: Adjust the maximum number of nodes to control the\n    dimension of the expansion.\n\n    More information on this expansion type can be found in:\n    B. Fritzke.\n    Growing cell structures-a self-organizing network for unsupervised\n    and supervised learning. Neural Networks 7, p. 1441--1460 (1994).\n    ', '__init__': &lt;function GrowingNeuralGasExpansionNode.__init__&gt;, '_set_input_dim': &lt;function GrowingNeuralGasExpansionNode._set_input_dim&gt;, '_set_output_dim': &lt;function GrowingNeuralGasExpansionNode._set_output_dim&gt;, 'is_trainable': &lt;staticmethod object&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_stop_training': &lt;function GrowingNeuralGasExpansionNode._stop_training&gt;, '_execute': &lt;function GrowingNeuralGasExpansionNode._execute&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>start_poss=None</em>, <em>eps_b=0.2</em>, <em>eps_n=0.006</em>, <em>max_age=50</em>, <em>lambda_=100</em>, <em>alpha=0.5</em>, <em>d=0.995</em>, <em>max_nodes=100</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>For a full list of input arguments please check the documentation
of GrowingNeuralGasNode.</p>
<dl class="docutils">
<dt>max_nodes (default 100) <span class="classifier-delimiter">:</span> <span class="classifier">maximum number of nodes in the</span></dt>
<dd>neural gas, therefore an upper bound
to the output dimension of the
expansion.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._add_edge">
<code class="descname">_add_edge</code><span class="sig-paren">(</span><em>from_</em>, <em>to_</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._add_edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._add_node">
<code class="descname">_add_node</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._add_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/expansion_nodes.html#GrowingNeuralGasExpansionNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._get_nearest_nodes">
<code class="descname">_get_nearest_nodes</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._get_nearest_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the two nodes in the graph that are nearest to x and their
squared distances. (Return ([node1, node2], [dist1, dist2])</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id85"><span class="problematic" id="id86">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._insert_new_node">
<code class="descname">_insert_new_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._insert_new_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a new node in the graph where it is more necessary (i.e.
where the error is the largest).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._move_node">
<code class="descname">_move_node</code><span class="sig-paren">(</span><em>node</em>, <em>x</em>, <em>eps</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._move_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Move a node by eps in the direction x.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._remove_old_edges">
<code class="descname">_remove_old_edges</code><span class="sig-paren">(</span><em>edges</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._remove_old_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all edges older than the maximal age.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/expansion_nodes.html#GrowingNeuralGasExpansionNode._set_input_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/expansion_nodes.html#GrowingNeuralGasExpansionNode._set_output_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/expansion_nodes.html#GrowingNeuralGasExpansionNode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.get_nodes_position">
<code class="descname">get_nodes_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.get_nodes_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id87"><span class="problematic" id="id88">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.nearest_neighbor">
<code class="descname">nearest_neighbor</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.nearest_neighbor" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign each point in the input data to the nearest node in
the graph. Return the list of the nearest node instances, and
the list of distances.
Executing this function will close the training phase if
necessary.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GrowingNeuralGasExpansionNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GrowingNeuralGasExpansionNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.NeuralGasNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">NeuralGasNode</code><span class="sig-paren">(</span><em>num_nodes=10</em>, <em>start_poss=None</em>, <em>epsilon_i=0.3</em>, <em>epsilon_f=0.05</em>, <em>lambda_i=30.0</em>, <em>lambda_f=0.01</em>, <em>max_age_i=20</em>, <em>max_age_f=200</em>, <em>max_epochs=100</em>, <em>n_epochs_to_train=None</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.GrowingNeuralGasNode" title="mdp.nodes.GrowingNeuralGasNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.GrowingNeuralGasNode</span></code></a></p>
<p>Learn the topological structure of the input data by building a
corresponding graph approximation (original Neural Gas algorithm).</p>
<p>The Neural Gas algorithm was originally published in Martinetz, T. and
Schulten, K.: A “Neural-Gas” Network Learns Topologies. In Kohonen, T.,
Maekisara, K., Simula, O., and Kangas, J. (eds.), Artificial Neural
Networks. Elsevier, North-Holland., 1991.</p>
<p><strong>Attributes and methods of interest</strong></p>
<ul class="simple">
<li>graph – The corresponding <cite>mdp.graph.Graph</cite> object</li>
<li>max_epochs - maximum number of epochs until which to train.</li>
</ul>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Learn the topological structure of the input data by building a\n    corresponding graph approximation (original Neural Gas algorithm).\n\n    The Neural Gas algorithm was originally published in Martinetz, T. and\n    Schulten, K.: A &quot;Neural-Gas&quot; Network Learns Topologies. In Kohonen, T.,\n    Maekisara, K., Simula, O., and Kangas, J. (eds.), Artificial Neural\n    Networks. Elsevier, North-Holland., 1991.\n\n    **Attributes and methods of interest**\n\n    - graph -- The corresponding `mdp.graph.Graph` object\n    - max_epochs - maximum number of epochs until which to train.\n    ', '__init__': &lt;function NeuralGasNode.__init__&gt;, '_train': &lt;function NeuralGasNode._train&gt;, '_rank_nodes_by_distance': &lt;function NeuralGasNode._rank_nodes_by_distance&gt;, '_remove_old_edges': &lt;function NeuralGasNode._remove_old_edges&gt;, 'train': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>num_nodes=10</em>, <em>start_poss=None</em>, <em>epsilon_i=0.3</em>, <em>epsilon_f=0.05</em>, <em>lambda_i=30.0</em>, <em>lambda_f=0.01</em>, <em>max_age_i=20</em>, <em>max_age_f=200</em>, <em>max_epochs=100</em>, <em>n_epochs_to_train=None</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Neural Gas algorithm.</p>
<p>Default parameters taken from the original publication.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>start_poss</dt>
<dd><p class="first last">sequence of two arrays containing the position of the
first two nodes in the GNG graph. In unspecified, the
initial nodes are chosen with a random position generated
from a gaussian distribution with zero mean and unit
variance.</p>
</dd>
<dt>num_nodes</dt>
<dd><p class="first last">number of nodes to use. Ignored if start_poss is given.</p>
</dd>
<dt>epsilon_i, epsilon_f</dt>
<dd><p class="first last">initial and final values of epsilon. Fraction of the distance
between the closest node and the presented data point by which the
node moves towards the data point in an adaptation step. Epsilon
decays during training by e(t) = e_i(e_f/e_i)^(t/t_max) with t
being the epoch.</p>
</dd>
<dt>lambda_i, lambda_f</dt>
<dd><p class="first last">initial and final values of lambda. Lambda influences how the
weight change of nodes in the ranking decreases with lower rank. It
is sometimes called the “neighborhood factor”. Lambda decays during
training in the same manner as epsilon does.</p>
</dd>
<dt>max_age_i, max_age_f</dt>
<dd><p class="first last">Initial and final lifetime, after which an edge will be removed.
Lifetime is measured in terms of adaptation steps, i.e.,
presentations of data points. It decays during training like
epsilon does.</p>
</dd>
<dt>max_epochs</dt>
<dd><p class="first last">number of epochs to train. One epoch has passed when all data points
from the input have been presented once. The default in the original
publication was 40000, but since this has proven to be impractically
high too high for many real-world data sets, we adopted a default
value of 100.</p>
</dd>
<dt>n_epochs_to_train</dt>
<dd><p class="first last">number of epochs to train on each call. Useful for batch learning
and for visualization of the training process. Default is to
train once until max_epochs is reached.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._add_edge">
<code class="descname">_add_edge</code><span class="sig-paren">(</span><em>from_</em>, <em>to_</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._add_edge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._add_node">
<code class="descname">_add_node</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._add_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._get_nearest_nodes">
<code class="descname">_get_nearest_nodes</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._get_nearest_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the two nodes in the graph that are nearest to x and their
squared distances. (Return ([node1, node2], [dist1, dist2])</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id89"><span class="problematic" id="id90">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._insert_new_node">
<code class="descname">_insert_new_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._insert_new_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a new node in the graph where it is more necessary (i.e.
where the error is the largest).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._move_node">
<code class="descname">_move_node</code><span class="sig-paren">(</span><em>node</em>, <em>x</em>, <em>eps</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._move_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Move a node by eps in the direction x.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._rank_nodes_by_distance">
<code class="descname">_rank_nodes_by_distance</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#NeuralGasNode._rank_nodes_by_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NeuralGasNode._rank_nodes_by_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nodes in the graph in a list ranked by their squared
distance to x.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._remove_old_edges">
<code class="descname">_remove_old_edges</code><span class="sig-paren">(</span><em>max_age</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#NeuralGasNode._remove_old_edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NeuralGasNode._remove_old_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove edges with age &gt; max_age.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/neural_gas_nodes.html#NeuralGasNode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NeuralGasNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.get_nodes_position">
<code class="descname">get_nodes_position</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.get_nodes_position" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id91"><span class="problematic" id="id92">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NeuralGasNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NeuralGasNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.nearest_neighbor">
<code class="descname">nearest_neighbor</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.nearest_neighbor" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign each point in the input data to the nearest node in
the graph. Return the list of the nearest node instances, and
the list of distances.
Executing this function will close the training phase if
necessary.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NeuralGasNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.NeuralGasNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NeuralGasNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NeuralGasNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="mdp.nodes._expanded_dim">
<code class="descclassname">mdp.nodes.</code><code class="descname">_expanded_dim</code><span class="sig-paren">(</span><em>degree</em>, <em>nvariables</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes._expanded_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of a vector of dimension <code class="docutils literal notranslate"><span class="pre">nvariables</span></code> after
a polynomial expansion of degree <code class="docutils literal notranslate"><span class="pre">degree</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="mdp.nodes.SignumClassifier">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">SignumClassifier</code><span class="sig-paren">(</span><em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.ClassifierNode" title="mdp.ClassifierNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ClassifierNode</span></code></a></p>
<p>This classifier node classifies as <code class="docutils literal notranslate"><span class="pre">1</span></code> if the sum of the data points
is positive and as <code class="docutils literal notranslate"><span class="pre">-1</span></code> if the data point is negative</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'This classifier node classifies as ``1`` if the sum of the data points\n    is positive and as ``-1`` if the data point is negative', '_get_supported_dtypes': &lt;function SignumClassifier._get_supported_dtypes&gt;, 'is_trainable': &lt;staticmethod object&gt;, '_label': &lt;function SignumClassifier._label&gt;, 'label': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.SignumClassifier.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize classifier.</p>
<dl class="docutils">
<dt>execute_method – Set to string value ‘label’, ‘rank’, or ‘prob’ to</dt>
<dd>force the corresponding classification method being used instead
of the standard identity execution (which is used when
execute_method has the default value None). This can be used when
the node is last in a flow, the return value from Flow.execute
will then consist of the classification results.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.SignumClassifier.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#SignumClassifier._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SignumClassifier._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._label">
<code class="descname">_label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#SignumClassifier._label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SignumClassifier._label" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._prob">
<code class="descname">_prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.SignumClassifier._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id93"><span class="problematic" id="id94">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.SignumClassifier.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.SignumClassifier.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array with best class labels.</p>
<p>By default, subclasses should overwrite _label to implement
their label. The docstring of the ‘_label’ method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.prob">
<code class="descname">prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the probability for each datapoint and label
(e.g., [{1:0.1, 2:0.0, 3:0.9}, {1:1.0, 2:0.0, 3:0.0}, …])</p>
<p>By default, subclasses should overwrite _prob to implement
their prob. The docstring of the ‘_prob’ method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>x</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns ordered list with all labels ordered according to prob(x)
(e.g., [[3 1 2], [2 1 3], …]).</p>
<p>The optional threshold parameter is used to exclude labels having equal
or less probability. E.g. threshold=0 excludes all labels with zero
probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SignumClassifier.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.SignumClassifier.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SignumClassifier.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SignumClassifier.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.PerceptronClassifier">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">PerceptronClassifier</code><span class="sig-paren">(</span><em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.ClassifierNode" title="mdp.ClassifierNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ClassifierNode</span></code></a></p>
<p>A simple perceptron with input_dim input nodes.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'A simple perceptron with input_dim input nodes.', '__init__': &lt;function PerceptronClassifier.__init__&gt;, '_check_train_args': &lt;function PerceptronClassifier._check_train_args&gt;, '_train': &lt;function PerceptronClassifier._train&gt;, '_label': &lt;function PerceptronClassifier._label&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'label': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize classifier.</p>
<dl class="docutils">
<dt>execute_method – Set to string value ‘label’, ‘rank’, or ‘prob’ to</dt>
<dd>force the corresponding classification method being used instead
of the standard identity execution (which is used when
execute_method has the default value None). This can be used when
the node is last in a flow, the return value from Flow.execute
will then consist of the classification results.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#PerceptronClassifier._check_train_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id95"><span class="problematic" id="id96">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._label">
<code class="descname">_label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#PerceptronClassifier._label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._label" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array with class labels from the perceptron.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._prob">
<code class="descname">_prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#PerceptronClassifier._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data ‘x’.</p>
<dl class="docutils">
<dt>x – a matrix having different variables on different columns</dt>
<dd>and observations on the rows.</dd>
<dt>labels – can be a list, tuple or array of labels (one for each data point)</dt>
<dd>or a single label, in which case all input data is assigned to
the same class.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id97"><span class="problematic" id="id98">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.PerceptronClassifier.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.PerceptronClassifier.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array with class labels from the perceptron.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.prob">
<code class="descname">prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the probability for each datapoint and label
(e.g., [{1:0.1, 2:0.0, 3:0.9}, {1:1.0, 2:0.0, 3:0.0}, …])</p>
<p>By default, subclasses should overwrite _prob to implement
their prob. The docstring of the ‘_prob’ method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>x</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns ordered list with all labels ordered according to prob(x)
(e.g., [[3 1 2], [2 1 3], …]).</p>
<p>The optional threshold parameter is used to exclude labels having equal
or less probability. E.g. threshold=0 excludes all labels with zero
probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.PerceptronClassifier.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.PerceptronClassifier.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.PerceptronClassifier.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data ‘x’.</p>
<dl class="docutils">
<dt>x – a matrix having different variables on different columns</dt>
<dd>and observations on the rows.</dd>
<dt>labels – can be a list, tuple or array of labels (one for each data point)</dt>
<dd>or a single label, in which case all input data is assigned to
the same class.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.SimpleMarkovClassifier">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">SimpleMarkovClassifier</code><span class="sig-paren">(</span><em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.ClassifierNode" title="mdp.ClassifierNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ClassifierNode</span></code></a></p>
<p>A simple version of a Markov classifier.
It can be trained on a vector of tuples the label being the next element
in the testing data.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'A simple version of a Markov classifier.\n    It can be trained on a vector of tuples the label being the next element\n    in the testing data.\n    ', '__init__': &lt;function SimpleMarkovClassifier.__init__&gt;, '_get_supported_dtypes': &lt;function SimpleMarkovClassifier._get_supported_dtypes&gt;, '_check_train_args': &lt;function SimpleMarkovClassifier._check_train_args&gt;, '_train': &lt;function SimpleMarkovClassifier._train&gt;, '_learn': &lt;function SimpleMarkovClassifier._learn&gt;, '_prob': &lt;function SimpleMarkovClassifier._prob&gt;, '_prob_one': &lt;function SimpleMarkovClassifier._prob_one&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'prob': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize classifier.</p>
<dl class="docutils">
<dt>execute_method – Set to string value ‘label’, ‘rank’, or ‘prob’ to</dt>
<dd>force the corresponding classification method being used instead
of the standard identity execution (which is used when
execute_method has the default value None). This can be used when
the node is last in a flow, the return value from Flow.execute
will then consist of the classification results.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#SimpleMarkovClassifier._check_train_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#SimpleMarkovClassifier._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._label">
<code class="descname">_label</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._label" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._learn">
<code class="descname">_learn</code><span class="sig-paren">(</span><em>feature</em>, <em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#SimpleMarkovClassifier._learn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._learn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._prob">
<code class="descname">_prob</code><span class="sig-paren">(</span><em>features</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#SimpleMarkovClassifier._prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._prob_one">
<code class="descname">_prob_one</code><span class="sig-paren">(</span><em>feature</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#SimpleMarkovClassifier._prob_one"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._prob_one" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#SimpleMarkovClassifier._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data ‘x’.</p>
<dl class="docutils">
<dt>x – a matrix having different variables on different columns</dt>
<dd>and observations on the rows.</dd>
<dt>labels – can be a list, tuple or array of labels (one for each data point)</dt>
<dd>or a single label, in which case all input data is assigned to
the same class.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id99"><span class="problematic" id="id100">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.SimpleMarkovClassifier.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.SimpleMarkovClassifier.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array with best class labels.</p>
<p>By default, subclasses should overwrite _label to implement
their label. The docstring of the ‘_label’ method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.prob">
<code class="descname">prob</code><span class="sig-paren">(</span><em>features</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the probability for each datapoint and label
(e.g., [{1:0.1, 2:0.0, 3:0.9}, {1:1.0, 2:0.0, 3:0.0}, …])</p>
<p>By default, subclasses should overwrite _prob to implement
their prob. The docstring of the ‘_prob’ method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>x</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns ordered list with all labels ordered according to prob(x)
(e.g., [[3 1 2], [2 1 3], …]).</p>
<p>The optional threshold parameter is used to exclude labels having equal
or less probability. E.g. threshold=0 excludes all labels with zero
probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.SimpleMarkovClassifier.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.SimpleMarkovClassifier.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.SimpleMarkovClassifier.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data ‘x’.</p>
<dl class="docutils">
<dt>x – a matrix having different variables on different columns</dt>
<dd>and observations on the rows.</dd>
<dt>labels – can be a list, tuple or array of labels (one for each data point)</dt>
<dd>or a single label, in which case all input data is assigned to
the same class.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.DiscreteHopfieldClassifier">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">DiscreteHopfieldClassifier</code><span class="sig-paren">(</span><em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype='b'</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.ClassifierNode" title="mdp.ClassifierNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ClassifierNode</span></code></a></p>
<p>Node for simulating a simple discrete Hopfield model</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Node for simulating a simple discrete Hopfield model', '__init__': &lt;function DiscreteHopfieldClassifier.__init__&gt;, '_get_supported_dtypes': &lt;function DiscreteHopfieldClassifier._get_supported_dtypes&gt;, '_train': &lt;function DiscreteHopfieldClassifier._train&gt;, '_train_one': &lt;function DiscreteHopfieldClassifier._train_one&gt;, 'memory_size': &lt;property object&gt;, 'load_parameter': &lt;property object&gt;, '_stop_training': &lt;function DiscreteHopfieldClassifier._stop_training&gt;, '_label': &lt;function DiscreteHopfieldClassifier._label&gt;, '_label_one': &lt;function DiscreteHopfieldClassifier._label_one&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'label': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype='b'</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize classifier.</p>
<dl class="docutils">
<dt>execute_method – Set to string value ‘label’, ‘rank’, or ‘prob’ to</dt>
<dd>force the corresponding classification method being used instead
of the standard identity execution (which is used when
execute_method has the default value None). This can be used when
the node is last in a flow, the return value from Flow.execute
will then consist of the classification results.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#DiscreteHopfieldClassifier._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id101"><span class="problematic" id="id102">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._label">
<code class="descname">_label</code><span class="sig-paren">(</span><em>x</em>, <em>threshold=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#DiscreteHopfieldClassifier._label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._label" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves patterns from the associative memory.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._label_one">
<code class="descname">_label_one</code><span class="sig-paren">(</span><em>pattern</em>, <em>threshold</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#DiscreteHopfieldClassifier._label_one"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._label_one" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._prob">
<code class="descname">_prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#DiscreteHopfieldClassifier._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#DiscreteHopfieldClassifier._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the hopfield net with the possible states.</p>
<dl class="docutils">
<dt>x – a matrix having different variables on different columns</dt>
<dd>and observations on rows.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._train_one">
<code class="descname">_train_one</code><span class="sig-paren">(</span><em>pattern</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#DiscreteHopfieldClassifier._train_one"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._train_one" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id103"><span class="problematic" id="id104">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>x</em>, <em>threshold=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves patterns from the associative memory.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.load_parameter">
<code class="descname">load_parameter</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.load_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the load parameter of the Hopfield net.
The quality of memory recall for a Hopfield net breaks down when the
load parameter is larger than 0.14.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.memory_size">
<code class="descname">memory_size</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.memory_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hopfield net’s memory size</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.prob">
<code class="descname">prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the probability for each datapoint and label
(e.g., [{1:0.1, 2:0.0, 3:0.9}, {1:1.0, 2:0.0, 3:0.0}, …])</p>
<p>By default, subclasses should overwrite _prob to implement
their prob. The docstring of the ‘_prob’ method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>x</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns ordered list with all labels ordered according to prob(x)
(e.g., [[3 1 2], [2 1 3], …]).</p>
<p>The optional threshold parameter is used to exclude labels having equal
or less probability. E.g. threshold=0 excludes all labels with zero
probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.DiscreteHopfieldClassifier.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.DiscreteHopfieldClassifier.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide the hopfield net with the possible states.</p>
<dl class="docutils">
<dt>x – a matrix having different variables on different columns</dt>
<dd>and observations on rows.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.KMeansClassifier">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">KMeansClassifier</code><span class="sig-paren">(</span><em>num_clusters</em>, <em>max_iter=10000</em>, <em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.ClassifierNode" title="mdp.ClassifierNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ClassifierNode</span></code></a></p>
<p>Employs K-Means Clustering for a given number of centroids.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Employs K-Means Clustering for a given number of centroids.', '__init__': &lt;function KMeansClassifier.__init__&gt;, '_train': &lt;function KMeansClassifier._train&gt;, '_stop_training': &lt;function KMeansClassifier._stop_training&gt;, '_nearest_centroid_idx': &lt;function KMeansClassifier._nearest_centroid_idx&gt;, '_label': &lt;function KMeansClassifier._label&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'label': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>num_clusters</em>, <em>max_iter=10000</em>, <em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><dl class="first last docutils">
<dt>num_clusters</dt>
<dd><p class="first last">number of centroids to use = number of clusters</p>
</dd>
<dt>max_iter</dt>
<dd><p class="first last">if the algorithm does not reach convergence (for some
numerical reason), stop after <code class="docutils literal notranslate"><span class="pre">max_iter</span></code> iterations</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id105"><span class="problematic" id="id106">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._label">
<code class="descname">_label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#KMeansClassifier._label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.KMeansClassifier._label" title="Permalink to this definition">¶</a></dt>
<dd><p>For a set of feature vectors x, this classifier returns
a list of centroids.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._nearest_centroid_idx">
<code class="descname">_nearest_centroid_idx</code><span class="sig-paren">(</span><em>data</em>, <em>centroids</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#KMeansClassifier._nearest_centroid_idx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.KMeansClassifier._nearest_centroid_idx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._prob">
<code class="descname">_prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#KMeansClassifier._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.KMeansClassifier._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#KMeansClassifier._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.KMeansClassifier._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id107"><span class="problematic" id="id108">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.KMeansClassifier.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.KMeansClassifier.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.label" title="Permalink to this definition">¶</a></dt>
<dd><p>For a set of feature vectors x, this classifier returns
a list of centroids.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.prob">
<code class="descname">prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the probability for each datapoint and label
(e.g., [{1:0.1, 2:0.0, 3:0.9}, {1:1.0, 2:0.0, 3:0.0}, …])</p>
<p>By default, subclasses should overwrite _prob to implement
their prob. The docstring of the ‘_prob’ method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>x</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns ordered list with all labels ordered according to prob(x)
(e.g., [[3 1 2], [2 1 3], …]).</p>
<p>The optional threshold parameter is used to exclude labels having equal
or less probability. E.g. threshold=0 excludes all labels with zero
probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KMeansClassifier.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.KMeansClassifier.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KMeansClassifier.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KMeansClassifier.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.NormalizeNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">NormalizeNode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.signal_node.html#mdp.signal_node.PreserveDimNode" title="mdp.signal_node.PreserveDimNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.signal_node.PreserveDimNode</span></code></a></p>
<p>Make input signal meanfree and unit variance</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Make input signal meanfree and unit variance', '__init__': &lt;function NormalizeNode.__init__&gt;, 'is_trainable': &lt;staticmethod object&gt;, '_train': &lt;function NormalizeNode._train&gt;, '_stop_training': &lt;function NormalizeNode._stop_training&gt;, '_execute': &lt;function NormalizeNode._execute&gt;, '_inverse': &lt;function NormalizeNode._inverse&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;, 'inverse': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.NormalizeNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>If the input dimension and the output dimension are
unspecified, they will be set when the <cite>train</cite> or <cite>execute</cite>
method is called for the first time.
If dtype is unspecified, it will be inherited from the data
it receives at the first call of <cite>train</cite> or <cite>execute</cite>.</p>
<p>Every subclass must take care of up- or down-casting the internal
structures to match this argument (use <cite>_refcast</cite> private
method when possible).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.NormalizeNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#NormalizeNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NormalizeNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id109"><span class="problematic" id="id110">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#NormalizeNode._inverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NormalizeNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#NormalizeNode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NormalizeNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/xsfa_nodes.html#NormalizeNode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NormalizeNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.NormalizeNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id111"><span class="problematic" id="id112">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NormalizeNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NormalizeNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalizeNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.NormalizeNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalizeNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalizeNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.GaussianClassifier">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">GaussianClassifier</code><span class="sig-paren">(</span><em>execute_method=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.ClassifierNode" title="mdp.ClassifierNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ClassifierNode</span></code></a></p>
<p>Perform a supervised Gaussian classification.</p>
<p>Given a set of labelled data, the node fits a gaussian distribution
to each class.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Perform a supervised Gaussian classification.\n\n    Given a set of labelled data, the node fits a gaussian distribution\n    to each class.\n    ', '__init__': &lt;function GaussianClassifier.__init__&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_check_train_args': &lt;function GaussianClassifier._check_train_args&gt;, '_update_covs': &lt;function GaussianClassifier._update_covs&gt;, '_train': &lt;function GaussianClassifier._train&gt;, '_stop_training': &lt;function GaussianClassifier._stop_training&gt;, '_gaussian_prob': &lt;function GaussianClassifier._gaussian_prob&gt;, 'class_probabilities': &lt;function GaussianClassifier.class_probabilities&gt;, '_prob': &lt;function GaussianClassifier._prob&gt;, '_label': &lt;function GaussianClassifier._label&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'label': &lt;function &lt;lambda&gt;&gt;, 'prob': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>execute_method=False</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize classifier.</p>
<dl class="docutils">
<dt>execute_method – Set to string value ‘label’, ‘rank’, or ‘prob’ to</dt>
<dd>force the corresponding classification method being used instead
of the standard identity execution (which is used when
execute_method has the default value None). This can be used when
the node is last in a flow, the return value from Flow.execute
will then consist of the classification results.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#GaussianClassifier._check_train_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GaussianClassifier._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._gaussian_prob">
<code class="descname">_gaussian_prob</code><span class="sig-paren">(</span><em>x</em>, <em>lbl_idx</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#GaussianClassifier._gaussian_prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GaussianClassifier._gaussian_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the probability of the data points x with respect to a
gaussian.</p>
<p>Input arguments:
x – Input data
S – Covariance matrix
mn – Mean</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id113"><span class="problematic" id="id114">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._label">
<code class="descname">_label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#GaussianClassifier._label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GaussianClassifier._label" title="Permalink to this definition">¶</a></dt>
<dd><p>Classify the input data using Maximum A-Posteriori.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._prob">
<code class="descname">_prob</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#GaussianClassifier._prob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GaussianClassifier._prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the posterior probability of each class given the input in a dict.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#GaussianClassifier._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GaussianClassifier._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#GaussianClassifier._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GaussianClassifier._train" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><dl class="first last docutils">
<dt>x</dt>
<dd><p class="first last">data</p>
</dd>
<dt>labels</dt>
<dd><p class="first last">Can be a list, tuple or array of labels (one for each data point)
or a single label, in which case all input data is assigned to
the same class.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier._update_covs">
<code class="descname">_update_covs</code><span class="sig-paren">(</span><em>x</em>, <em>lbl</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#GaussianClassifier._update_covs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.GaussianClassifier._update_covs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.class_probabilities">
<code class="descname">class_probabilities</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.class_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the posterior probability of each class given the input.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id115"><span class="problematic" id="id116">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.GaussianClassifier.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.GaussianClassifier.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Classify the input data using Maximum A-Posteriori.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.prob">
<code class="descname">prob</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the posterior probability of each class given the input in a dict.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>x</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns ordered list with all labels ordered according to prob(x)
(e.g., [[3 1 2], [2 1 3], …]).</p>
<p>The optional threshold parameter is used to exclude labels having equal
or less probability. E.g. threshold=0 excludes all labels with zero
probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.GaussianClassifier.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.GaussianClassifier.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.GaussianClassifier.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.GaussianClassifier.train" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><dl class="first last docutils">
<dt>x</dt>
<dd><p class="first last">data</p>
</dd>
<dt>labels</dt>
<dd><p class="first last">Can be a list, tuple or array of labels (one for each data point)
or a single label, in which case all input data is assigned to
the same class.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.NearestMeanClassifier">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">NearestMeanClassifier</code><span class="sig-paren">(</span><em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.ClassifierNode" title="mdp.ClassifierNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ClassifierNode</span></code></a></p>
<p>Nearest-Mean classifier.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Nearest-Mean classifier.', '__init__': &lt;function NearestMeanClassifier.__init__&gt;, '_train': &lt;function NearestMeanClassifier._train&gt;, '_update_mean': &lt;function NearestMeanClassifier._update_mean&gt;, '_check_train_args': &lt;function NearestMeanClassifier._check_train_args&gt;, '_stop_training': &lt;function NearestMeanClassifier._stop_training&gt;, '_label': &lt;function NearestMeanClassifier._label&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'label': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize classifier.</p>
<dl class="docutils">
<dt>execute_method – Set to string value ‘label’, ‘rank’, or ‘prob’ to</dt>
<dd>force the corresponding classification method being used instead
of the standard identity execution (which is used when
execute_method has the default value None). This can be used when
the node is last in a flow, the return value from Flow.execute
will then consist of the classification results.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#NearestMeanClassifier._check_train_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id117"><span class="problematic" id="id118">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._label">
<code class="descname">_label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#NearestMeanClassifier._label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._label" title="Permalink to this definition">¶</a></dt>
<dd><p>Classify the data based on minimal distance to mean.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._prob">
<code class="descname">_prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#NearestMeanClassifier._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the class means.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#NearestMeanClassifier._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the mean information for the different classes.</p>
<dl class="docutils">
<dt>labels – Can be a list, tuple or array of labels (one for each data</dt>
<dd>point) or a single label, in which case all input data is assigned
to the same class (computationally this is more efficient).</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier._update_mean">
<code class="descname">_update_mean</code><span class="sig-paren">(</span><em>x</em>, <em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#NearestMeanClassifier._update_mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier._update_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the mean with data for a single label.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id119"><span class="problematic" id="id120">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NearestMeanClassifier.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NearestMeanClassifier.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Classify the data based on minimal distance to mean.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.prob">
<code class="descname">prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the probability for each datapoint and label
(e.g., [{1:0.1, 2:0.0, 3:0.9}, {1:1.0, 2:0.0, 3:0.0}, …])</p>
<p>By default, subclasses should overwrite _prob to implement
their prob. The docstring of the ‘_prob’ method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>x</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns ordered list with all labels ordered according to prob(x)
(e.g., [[3 1 2], [2 1 3], …]).</p>
<p>The optional threshold parameter is used to exclude labels having equal
or less probability. E.g. threshold=0 excludes all labels with zero
probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the class means.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NearestMeanClassifier.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NearestMeanClassifier.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NearestMeanClassifier.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the mean information for the different classes.</p>
<dl class="docutils">
<dt>labels – Can be a list, tuple or array of labels (one for each data</dt>
<dd>point) or a single label, in which case all input data is assigned
to the same class (computationally this is more efficient).</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.KNNClassifier">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">KNNClassifier</code><span class="sig-paren">(</span><em>k=1</em>, <em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.ClassifierNode" title="mdp.ClassifierNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ClassifierNode</span></code></a></p>
<p>K-Nearest-Neighbour Classifier.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'K-Nearest-Neighbour Classifier.', '__init__': &lt;function KNNClassifier.__init__&gt;, '_train': &lt;function KNNClassifier._train&gt;, '_add_samples': &lt;function KNNClassifier._add_samples&gt;, '_check_train_args': &lt;function KNNClassifier._check_train_args&gt;, '_stop_training': &lt;function KNNClassifier._stop_training&gt;, '_label': &lt;function KNNClassifier._label&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'label': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.KNNClassifier.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>k=1</em>, <em>execute_method=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize classifier.</p>
<p>k – Number of closest sample points that are taken into account.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.KNNClassifier.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._add_samples">
<code class="descname">_add_samples</code><span class="sig-paren">(</span><em>x</em>, <em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#KNNClassifier._add_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.KNNClassifier._add_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Store x set for later neirest-neighbour calculation.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#KNNClassifier._check_train_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.KNNClassifier._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id121"><span class="problematic" id="id122">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._label">
<code class="descname">_label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#KNNClassifier._label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.KNNClassifier._label" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the data by comparison with the reference points.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._prob">
<code class="descname">_prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#KNNClassifier._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.KNNClassifier._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Organize the sample data.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/classifier_nodes.html#KNNClassifier._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.KNNClassifier._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the sampel points to the classes.</p>
<dl class="docutils">
<dt>labels – Can be a list, tuple or array of labels (one for each data</dt>
<dd>point) or a single label, in which case all input data is assigned
to the same class (computationally this is more efficient).</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.KNNClassifier._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id123"><span class="problematic" id="id124">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.KNNClassifier.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.KNNClassifier.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.label">
<code class="descname">label</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the data by comparison with the reference points.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.prob">
<code class="descname">prob</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.prob" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the probability for each datapoint and label
(e.g., [{1:0.1, 2:0.0, 3:0.9}, {1:1.0, 2:0.0, 3:0.0}, …])</p>
<p>By default, subclasses should overwrite _prob to implement
their prob. The docstring of the ‘_prob’ method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.rank">
<code class="descname">rank</code><span class="sig-paren">(</span><em>x</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns ordered list with all labels ordered according to prob(x)
(e.g., [[3 1 2], [2 1 3], …]).</p>
<p>The optional threshold parameter is used to exclude labels having equal
or less probability. E.g. threshold=0 excludes all labels with zero
probability.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Organize the sample data.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.KNNClassifier.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.KNNClassifier.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.KNNClassifier.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.KNNClassifier.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the sampel points to the classes.</p>
<dl class="docutils">
<dt>labels – Can be a list, tuple or array of labels (one for each data</dt>
<dd>point) or a single label, in which case all input data is assigned
to the same class (computationally this is more efficient).</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.EtaComputerNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">EtaComputerNode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Compute the eta values of the normalized training data.</p>
<p>The delta value of a signal is a measure of its temporal
variation, and is defined as the mean of the derivative squared,
i.e. <code class="docutils literal notranslate"><span class="pre">delta(x)</span> <span class="pre">=</span> <span class="pre">mean(dx/dt(t)^2)</span></code>.  <code class="docutils literal notranslate"><span class="pre">delta(x)</span></code> is zero if
<code class="docutils literal notranslate"><span class="pre">x</span></code> is a constant signal, and increases if the temporal variation
of the signal is bigger.</p>
<p>The eta value is a more intuitive measure of temporal variation,
defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eta</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">delta</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is a signal of length <code class="docutils literal notranslate"><span class="pre">T</span></code> which consists of a sine function
that accomplishes exactly <code class="docutils literal notranslate"><span class="pre">N</span></code> oscillations, then <code class="docutils literal notranslate"><span class="pre">eta(x)=N</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">EtaComputerNode</span></code> normalizes the training data to have unit
variance, such that it is possible to compare the temporal
variation of two signals independently from their scaling.</p>
<p>Reference: Wiskott, L. and Sejnowski, T.J. (2002).
Slow Feature Analysis: Unsupervised Learning of Invariances,
Neural Computation, 14(4):715-770.</p>
<p>Important: if a data chunk is tlen data points long, this node is
going to consider only the first tlen-1 points together with their
derivatives. This means in particular that the variance of the
signal is not computed on all data points. This behavior is
compatible with that of <code class="docutils literal notranslate"><span class="pre">SFANode</span></code>.</p>
<p>This is an analysis node, i.e. the data is analyzed during training
and the results are stored internally.  Use the method
<code class="docutils literal notranslate"><span class="pre">get_eta</span></code> to access them.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Compute the eta values of the normalized training data.\n\n    The delta value of a signal is a measure of its temporal\n    variation, and is defined as the mean of the derivative squared,\n    i.e. ``delta(x) = mean(dx/dt(t)^2)``.  ``delta(x)`` is zero if\n    ``x`` is a constant signal, and increases if the temporal variation\n    of the signal is bigger.\n\n    The eta value is a more intuitive measure of temporal variation,\n    defined as::\n    \n       eta(x) = T/(2*pi) * sqrt(delta(x))\n\n    If ``x`` is a signal of length ``T`` which consists of a sine function\n    that accomplishes exactly ``N`` oscillations, then ``eta(x)=N``.\n\n    ``EtaComputerNode`` normalizes the training data to have unit\n    variance, such that it is possible to compare the temporal\n    variation of two signals independently from their scaling.\n\n    Reference: Wiskott, L. and Sejnowski, T.J. (2002).\n    Slow Feature Analysis: Unsupervised Learning of Invariances,\n    Neural Computation, 14(4):715-770.\n\n    Important: if a data chunk is tlen data points long, this node is\n    going to consider only the first tlen-1 points together with their\n    derivatives. This means in particular that the variance of the\n    signal is not computed on all data points. This behavior is\n    compatible with that of ``SFANode``.\n\n    This is an analysis node, i.e. the data is analyzed during training\n    and the results are stored internally.  Use the method\n    ``get_eta`` to access them.\n    ', '__init__': &lt;function EtaComputerNode.__init__&gt;, '_set_input_dim': &lt;function EtaComputerNode._set_input_dim&gt;, '_init_internals': &lt;function EtaComputerNode._init_internals&gt;, '_train': &lt;function EtaComputerNode._train&gt;, '_stop_training': &lt;function EtaComputerNode._stop_training&gt;, 'get_eta': &lt;function EtaComputerNode.get_eta&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>If the input dimension and the output dimension are
unspecified, they will be set when the <cite>train</cite> or <cite>execute</cite>
method is called for the first time.
If dtype is unspecified, it will be inherited from the data
it receives at the first call of <cite>train</cite> or <cite>execute</cite>.</p>
<p>Every subclass must take care of up- or down-casting the internal
structures to match this argument (use <cite>_refcast</cite> private
method when possible).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id125"><span class="problematic" id="id126">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._init_internals">
<code class="descname">_init_internals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#EtaComputerNode._init_internals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.EtaComputerNode._init_internals" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#EtaComputerNode._set_input_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.EtaComputerNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#EtaComputerNode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.EtaComputerNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#EtaComputerNode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.EtaComputerNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.get_eta">
<code class="descname">get_eta</code><span class="sig-paren">(</span><em>t=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.get_eta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the eta values of the data received during the training
phase. If the training phase has not been completed yet, call
stop_training.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><dl class="first last docutils">
<dt>t</dt>
<dd><p class="first">Sampling frequency in Hz.</p>
<p class="last">The original definition in (Wiskott and Sejnowski, 2002)
is obtained for <code class="docutils literal notranslate"><span class="pre">t=self._tlen</span></code>, while for <code class="docutils literal notranslate"><span class="pre">t=1</span></code> (default),
this corresponds to the beta-value defined in
(Berkes and Wiskott, 2005).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id127"><span class="problematic" id="id128">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.EtaComputerNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.EtaComputerNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.EtaComputerNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.EtaComputerNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.EtaComputerNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.EtaComputerNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.HitParadeNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">HitParadeNode</code><span class="sig-paren">(</span><em>n</em>, <em>d=1</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.signal_node.html#mdp.signal_node.PreserveDimNode" title="mdp.signal_node.PreserveDimNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.signal_node.PreserveDimNode</span></code></a></p>
<p>Collect the first <code class="docutils literal notranslate"><span class="pre">n</span></code> local maxima and minima of the training signal
which are separated by a minimum gap <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
<p>This is an analysis node, i.e. the data is analyzed during training
and the results are stored internally. Use the
<code class="docutils literal notranslate"><span class="pre">get_maxima</span></code> and <code class="docutils literal notranslate"><span class="pre">get_minima</span></code> methods to access them.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Collect the first ``n`` local maxima and minima of the training signal\n    which are separated by a minimum gap ``d``.\n\n    This is an analysis node, i.e. the data is analyzed during training\n    and the results are stored internally. Use the\n    ``get_maxima`` and ``get_minima`` methods to access them.\n    ', '__init__': &lt;function HitParadeNode.__init__&gt;, '_set_input_dim': &lt;function HitParadeNode._set_input_dim&gt;, '_get_supported_dtypes': &lt;function HitParadeNode._get_supported_dtypes&gt;, '_train': &lt;function HitParadeNode._train&gt;, 'get_maxima': &lt;function HitParadeNode.get_maxima&gt;, 'get_minima': &lt;function HitParadeNode.get_minima&gt;, 'train': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.HitParadeNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>n</em>, <em>d=1</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input arguments:
n – Number of maxima and minima to store
d – Minimum gap between two maxima or two minima</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.HitParadeNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#HitParadeNode._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.HitParadeNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#HitParadeNode._set_input_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.HitParadeNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#HitParadeNode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.HitParadeNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.HitParadeNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.get_maxima">
<code class="descname">get_maxima</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.get_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple (maxima, indices).
Maxima are sorted in descending order.</p>
<p>If the training phase has not been completed yet, call
stop_training.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.get_minima">
<code class="descname">get_minima</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.get_minima" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple (minima, indices).
Minima are sorted in ascending order.</p>
<p>If the training phase has not been completed yet, call
stop_training.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id129"><span class="problematic" id="id130">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.HitParadeNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.HitParadeNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HitParadeNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.HitParadeNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HitParadeNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HitParadeNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.NoiseNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">NoiseNode</code><span class="sig-paren">(</span><em>noise_func=&lt;built-in method normal of numpy.random.mtrand.RandomState object&gt;</em>, <em>noise_args=(0</em>, <em>1)</em>, <em>noise_type='additive'</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.signal_node.html#mdp.signal_node.PreserveDimNode" title="mdp.signal_node.PreserveDimNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.signal_node.PreserveDimNode</span></code></a></p>
<p>Inject multiplicative or additive noise into the input data.</p>
<p>Original code contributed by Mathias Franzius.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.NoiseNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Inject multiplicative or additive noise into the input data.\n\n    Original code contributed by Mathias Franzius.\n    ', '__init__': &lt;function NoiseNode.__init__&gt;, '_get_supported_dtypes': &lt;function NoiseNode._get_supported_dtypes&gt;, 'is_trainable': &lt;staticmethod object&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_execute': &lt;function NoiseNode._execute&gt;, 'save': &lt;function NoiseNode.save&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.NoiseNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>noise_func=&lt;built-in method normal of numpy.random.mtrand.RandomState object&gt;</em>, <em>noise_args=(0</em>, <em>1)</em>, <em>noise_type='additive'</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add noise to input signals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Arguments:</th><td class="field-body"><dl class="first last docutils">
<dt>noise_func</dt>
<dd><p class="first last">A function that generates noise. It must
take a <code class="docutils literal notranslate"><span class="pre">size</span></code> keyword argument and return
a random array of that size. Default is normal noise.</p>
</dd>
<dt>noise_args</dt>
<dd><p class="first last">Tuple of additional arguments passed to <cite>noise_func</cite>.
Default is (0,1) for (mean, standard deviation)
of the normal distribution.</p>
</dd>
<dt>noise_type</dt>
<dd><p class="first">Either <code class="docutils literal notranslate"><span class="pre">'additive'</span></code> or <code class="docutils literal notranslate"><span class="pre">'multiplicative'</span></code>.</p>
<dl class="docutils">
<dt>‘additive’</dt>
<dd><p class="first last">returns <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">noise</span></code>.</p>
</dd>
<dt>‘multiplicative’</dt>
<dd><p class="first last">returns <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">noise)</span></code></p>
</dd>
</dl>
<p class="last">Default is <code class="docutils literal notranslate"><span class="pre">'additive'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.NoiseNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.NoiseNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#NoiseNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NoiseNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#NoiseNode._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NoiseNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.NoiseNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.NoiseNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id131"><span class="problematic" id="id132">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.NoiseNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NoiseNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NoiseNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.NoiseNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to ‘filename’.
If ‘filename’ is None, return a string.</p>
<p>Note: the pickled Node is not guaranteed to be upward or
backward compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NoiseNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.NoiseNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NoiseNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NoiseNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.NormalNoiseNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">NormalNoiseNode</code><span class="sig-paren">(</span><em>noise_args=(0</em>, <em>1)</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.signal_node.html#mdp.signal_node.PreserveDimNode" title="mdp.signal_node.PreserveDimNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.signal_node.PreserveDimNode</span></code></a></p>
<p>Special version of <code class="docutils literal notranslate"><span class="pre">NoiseNode</span></code> for Gaussian additive noise.</p>
<p>Unlike <code class="docutils literal notranslate"><span class="pre">NoiseNode</span></code> it does not store a noise function reference but simply
uses <code class="docutils literal notranslate"><span class="pre">numx_rand.normal</span></code>.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Special version of ``NoiseNode`` for Gaussian additive noise.\n\n    Unlike ``NoiseNode`` it does not store a noise function reference but simply\n    uses ``numx_rand.normal``.\n    ', '__init__': &lt;function NormalNoiseNode.__init__&gt;, 'is_trainable': &lt;staticmethod object&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_execute': &lt;function NormalNoiseNode._execute&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>noise_args=(0</em>, <em>1)</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the noise parameters.</p>
<dl class="docutils">
<dt>noise_args – Tuple of (mean, standard deviation) for the normal</dt>
<dd>distribution, default is (0,1).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#NormalNoiseNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id133"><span class="problematic" id="id134">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id135"><span class="problematic" id="id136">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NormalNoiseNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.NormalNoiseNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.NormalNoiseNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.NormalNoiseNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.NormalNoiseNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.TimeFramesNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">TimeFramesNode</code><span class="sig-paren">(</span><em>time_frames</em>, <em>gap=1</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Copy delayed version of the input signal on the space dimensions.</p>
<p>For example, for <code class="docutils literal notranslate"><span class="pre">time_frames=3</span></code> and <code class="docutils literal notranslate"><span class="pre">gap=2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>        <span class="p">[</span> <span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>          <span class="n">X</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>   <span class="o">--&gt;</span>    <span class="n">X</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>          <span class="n">X</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>          <span class="o">...</span>  <span class="o">...</span>  <span class="o">...</span>  <span class="o">...</span>  <span class="o">...</span>  <span class="o">...</span> <span class="p">]</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
  <span class="o">...</span>  <span class="o">...</span>  <span class="p">]</span>
</pre></div>
</div>
<p>It is not always possible to invert this transformation (the
transformation is not surjective. However, the <code class="docutils literal notranslate"><span class="pre">pseudo_inverse</span></code>
method does the correct thing when it is indeed possible.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Copy delayed version of the input signal on the space dimensions.\n\n    For example, for ``time_frames=3`` and ``gap=2``::\n\n      [ X(1) Y(1)        [ X(1) Y(1) X(3) Y(3) X(5) Y(5)\n        X(2) Y(2)          X(2) Y(2) X(4) Y(4) X(6) Y(6)\n        X(3) Y(3)   --&gt;    X(3) Y(3) X(5) Y(5) X(7) Y(7)\n        X(4) Y(4)          X(4) Y(4) X(6) Y(6) X(8) Y(8)\n        X(5) Y(5)          ...  ...  ...  ...  ...  ... ]\n        X(6) Y(6)\n        X(7) Y(7)\n        X(8) Y(8)\n        ...  ...  ]\n\n    It is not always possible to invert this transformation (the\n    transformation is not surjective. However, the ``pseudo_inverse``\n    method does the correct thing when it is indeed possible.\n    ', '__init__': &lt;function TimeFramesNode.__init__&gt;, '_get_supported_dtypes': &lt;function TimeFramesNode._get_supported_dtypes&gt;, 'is_trainable': &lt;staticmethod object&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_set_input_dim': &lt;function TimeFramesNode._set_input_dim&gt;, '_set_output_dim': &lt;function TimeFramesNode._set_output_dim&gt;, '_execute': &lt;function TimeFramesNode._execute&gt;, 'pseudo_inverse': &lt;function TimeFramesNode.pseudo_inverse&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>time_frames</em>, <em>gap=1</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input arguments:
time_frames – Number of delayed copies
gap – Time delay between the copies</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#TimeFramesNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.TimeFramesNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#TimeFramesNode._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.TimeFramesNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#TimeFramesNode._set_input_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.TimeFramesNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#TimeFramesNode._set_output_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.TimeFramesNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id137"><span class="problematic" id="id138">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.TimeFramesNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.TimeFramesNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.pseudo_inverse">
<code class="descname">pseudo_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.pseudo_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a pseudo-inverse of the execute frame.
y == execute(x) only if y belongs to the domain of execute and
has been computed with a sufficently large x.
If gap &gt; 1 some of the last rows will be filled with zeros.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeFramesNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.TimeFramesNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeFramesNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeFramesNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.TimeDelayNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">TimeDelayNode</code><span class="sig-paren">(</span><em>time_frames</em>, <em>gap=1</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.TimeFramesNode" title="mdp.nodes.TimeFramesNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.TimeFramesNode</span></code></a></p>
<p>Copy delayed version of the input signal on the space dimensions.</p>
<p>For example, for <code class="docutils literal notranslate"><span class="pre">time_frames=3</span></code> and <code class="docutils literal notranslate"><span class="pre">gap=2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>        <span class="p">[</span> <span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>          <span class="n">X</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>   <span class="o">--&gt;</span>    <span class="n">X</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="mi">0</span>    <span class="mi">0</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>          <span class="n">X</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="mi">0</span>    <span class="mi">0</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>          <span class="n">X</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>          <span class="o">...</span>  <span class="o">...</span>  <span class="o">...</span>  <span class="o">...</span>  <span class="o">...</span>  <span class="o">...</span> <span class="p">]</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
  <span class="n">X</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="n">Y</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
  <span class="o">...</span>  <span class="o">...</span>  <span class="p">]</span>
</pre></div>
</div>
<p>This node provides similar functionality as the <code class="docutils literal notranslate"><span class="pre">TimeFramesNode</span></code>, only
that it performs a time embedding into the past rather than into the future.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">TimeDelaySlidingWindowNode</span></code> for a sliding window delay node for
application in a non-batch manner.</p>
<p>Original code contributed by Sebastian Hoefer.
Dec 31, 2010</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': '\n    Copy delayed version of the input signal on the space dimensions.\n\n    For example, for ``time_frames=3`` and ``gap=2``::\n\n      [ X(1) Y(1)        [ X(1) Y(1)   0    0    0    0\n        X(2) Y(2)          X(2) Y(2)   0    0    0    0\n        X(3) Y(3)   --&gt;    X(3) Y(3) X(1) Y(1)   0    0\n        X(4) Y(4)          X(4) Y(4) X(2) Y(2)   0    0\n        X(5) Y(5)          X(5) Y(5) X(3) Y(3) X(1) Y(1)\n        X(6) Y(6)          ...  ...  ...  ...  ...  ... ]\n        X(7) Y(7)\n        X(8) Y(8)\n        ...  ...  ]\n\n    This node provides similar functionality as the ``TimeFramesNode``, only\n    that it performs a time embedding into the past rather than into the future.\n\n    See ``TimeDelaySlidingWindowNode`` for a sliding window delay node for\n    application in a non-batch manner.\n\n    Original code contributed by Sebastian Hoefer.\n    Dec 31, 2010\n    ', '__init__': &lt;function TimeDelayNode.__init__&gt;, '_execute': &lt;function TimeDelayNode._execute&gt;, 'pseudo_inverse': &lt;function TimeDelayNode.pseudo_inverse&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>time_frames</em>, <em>gap=1</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input arguments:
time_frames – Number of delayed copies
gap – Time delay between the copies</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#TimeDelayNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.TimeDelayNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id139"><span class="problematic" id="id140">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.TimeDelayNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.TimeDelayNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.pseudo_inverse">
<code class="descname">pseudo_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.pseudo_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a pseudo-inverse of the execute frame.
y == execute(x) only if y belongs to the domain of execute and
has been computed with a sufficently large x.
If gap &gt; 1 some of the last rows will be filled with zeros.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelayNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.TimeDelayNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelayNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelayNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">TimeDelaySlidingWindowNode</code><span class="sig-paren">(</span><em>time_frames</em>, <em>gap=1</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.TimeDelayNode" title="mdp.nodes.TimeDelayNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.TimeDelayNode</span></code></a></p>
<p><code class="docutils literal notranslate"><span class="pre">TimeDelaySlidingWindowNode</span></code> is an alternative to <code class="docutils literal notranslate"><span class="pre">TimeDelayNode</span></code>
which should be used for online learning/execution. Whereas the
<code class="docutils literal notranslate"><span class="pre">TimeDelayNode</span></code> works in a batch manner, for online application
a sliding window is necessary which yields only one row per call.</p>
<p>Applied to the same data the collection of all returned rows of the
<code class="docutils literal notranslate"><span class="pre">TimeDelaySlidingWindowNode</span></code> is equivalent to the result of the
<code class="docutils literal notranslate"><span class="pre">TimeDelayNode</span></code>.</p>
<p>Original code contributed by Sebastian Hoefer.
Dec 31, 2010</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': '\n    ``TimeDelaySlidingWindowNode`` is an alternative to ``TimeDelayNode``\n    which should be used for online learning/execution. Whereas the\n    ``TimeDelayNode`` works in a batch manner, for online application\n    a sliding window is necessary which yields only one row per call.\n\n    Applied to the same data the collection of all returned rows of the\n    ``TimeDelaySlidingWindowNode`` is equivalent to the result of the\n    ``TimeDelayNode``.\n\n    Original code contributed by Sebastian Hoefer.\n    Dec 31, 2010\n    ', '__init__': &lt;function TimeDelaySlidingWindowNode.__init__&gt;, '_init_sliding_window': &lt;function TimeDelaySlidingWindowNode._init_sliding_window&gt;, '_execute': &lt;function TimeDelaySlidingWindowNode._execute&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>time_frames</em>, <em>gap=1</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input arguments:
time_frames – Number of delayed copies
gap – Time delay between the copies</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#TimeDelaySlidingWindowNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._init_sliding_window">
<code class="descname">_init_sliding_window</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#TimeDelaySlidingWindowNode._init_sliding_window"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._init_sliding_window" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id141"><span class="problematic" id="id142">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.pseudo_inverse">
<code class="descname">pseudo_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.pseudo_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a pseudo-inverse of the execute frame.
y == execute(x) only if y belongs to the domain of execute and
has been computed with a sufficently large x.
If gap &gt; 1 some of the last rows will be filled with zeros.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.TimeDelaySlidingWindowNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.TimeDelaySlidingWindowNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.CutoffNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">CutoffNode</code><span class="sig-paren">(</span><em>lower_bound=None</em>, <em>upper_bound=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.signal_node.html#mdp.signal_node.PreserveDimNode" title="mdp.signal_node.PreserveDimNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.signal_node.PreserveDimNode</span></code></a></p>
<p>Node to cut off values at specified bounds.</p>
<p>Works similar to <code class="docutils literal notranslate"><span class="pre">numpy.clip</span></code>, but also works when only a lower or upper
bound is specified.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.CutoffNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Node to cut off values at specified bounds.\n\n    Works similar to ``numpy.clip``, but also works when only a lower or upper\n    bound is specified.\n    ', '__init__': &lt;function CutoffNode.__init__&gt;, 'is_trainable': &lt;staticmethod object&gt;, 'is_invertible': &lt;staticmethod object&gt;, '_get_supported_dtypes': &lt;function CutoffNode._get_supported_dtypes&gt;, '_execute': &lt;function CutoffNode._execute&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.CutoffNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>lower_bound=None</em>, <em>upper_bound=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>lower_bound</dt>
<dd><p class="first last">Data values below this are cut to the <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code> value.
If <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> no cutoff is performed.</p>
</dd>
<dt>upper_bound</dt>
<dd><p class="first last">Works like <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.CutoffNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.CutoffNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#CutoffNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.CutoffNode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clipped data.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#CutoffNode._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.CutoffNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id143"><span class="problematic" id="id144">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.CutoffNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.CutoffNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clipped data.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id145"><span class="problematic" id="id146">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.CutoffNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.CutoffNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.CutoffNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.CutoffNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.CutoffNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.CutoffNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.CutoffNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.CutoffNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.AdaptiveCutoffNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">AdaptiveCutoffNode</code><span class="sig-paren">(</span><em>lower_cutoff_fraction=None</em>, <em>upper_cutoff_fraction=None</em>, <em>hist_fraction=1.0</em>, <em>hist_filename=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../node_list.html#mdp.nodes.HistogramNode" title="mdp.nodes.HistogramNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.HistogramNode</span></code></a></p>
<p>Node which uses the data history during training to learn cutoff values.</p>
<p>As opposed to the simple <code class="docutils literal notranslate"><span class="pre">CutoffNode</span></code>, a different cutoff value is learned
for each data coordinate. For example if an upper cutoff fraction of
0.05 is specified, then the upper cutoff bound is set so that the upper
5% of the training data would have been clipped (in each dimension).
The cutoff bounds are then applied during execution.
This node also works as a <code class="docutils literal notranslate"><span class="pre">HistogramNode</span></code>, so the histogram data is stored.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">stop_training</span></code> is called the cutoff values for each coordinate are
calculated based on the collected histogram data.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Node which uses the data history during training to learn cutoff values.\n\n    As opposed to the simple ``CutoffNode``, a different cutoff value is learned\n    for each data coordinate. For example if an upper cutoff fraction of\n    0.05 is specified, then the upper cutoff bound is set so that the upper\n    5% of the training data would have been clipped (in each dimension).\n    The cutoff bounds are then applied during execution.\n    This node also works as a ``HistogramNode``, so the histogram data is stored.\n\n    When ``stop_training`` is called the cutoff values for each coordinate are\n    calculated based on the collected histogram data.\n    ', '__init__': &lt;function AdaptiveCutoffNode.__init__&gt;, '_get_supported_dtypes': &lt;function AdaptiveCutoffNode._get_supported_dtypes&gt;, '_stop_training': &lt;function AdaptiveCutoffNode._stop_training&gt;, '_execute': &lt;function AdaptiveCutoffNode._execute&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>lower_cutoff_fraction=None</em>, <em>upper_cutoff_fraction=None</em>, <em>hist_fraction=1.0</em>, <em>hist_filename=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>lower_cutoff_fraction</dt>
<dd><p class="first last">Fraction of data that will be cut off after
the training phase (assuming the data distribution does not
change). If set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (default value) no cutoff is performed.</p>
</dd>
<dt>upper_cutoff_fraction</dt>
<dd><p class="first last">Works like <cite>lower_cutoff_fraction</cite>.</p>
</dd>
<dt>hist_fraction</dt>
<dd><p class="first last">Defines the fraction of the data that is stored for the
histogram.</p>
</dd>
<dt>hist_filename</dt>
<dd><p class="first last">Filename for the file to which the data history will be
pickled after training. The data is pickled when
<cite>stop_training</cite> is called and <code class="docutils literal notranslate"><span class="pre">data_hist</span></code> is then
cleared (to free memory).  If filename is <code class="docutils literal notranslate"><span class="pre">None</span></code>
(default value) then <code class="docutils literal notranslate"><span class="pre">data_hist</span></code> is not cleared and can
be directly used after training.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#AdaptiveCutoffNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clipped data.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#AdaptiveCutoffNode._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id147"><span class="problematic" id="id148">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#AdaptiveCutoffNode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the cutoff bounds based on collected histogram data.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the history data.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clipped data.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id149"><span class="problematic" id="id150">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.AdaptiveCutoffNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.AdaptiveCutoffNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the cutoff bounds based on collected histogram data.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.AdaptiveCutoffNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.AdaptiveCutoffNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.AdaptiveCutoffNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the history data.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.HistogramNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">HistogramNode</code><span class="sig-paren">(</span><em>hist_fraction=1.0</em>, <em>hist_filename=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.signal_node.html#mdp.signal_node.PreserveDimNode" title="mdp.signal_node.PreserveDimNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.signal_node.PreserveDimNode</span></code></a></p>
<p>Node which stores a history of the data during its training phase.</p>
<p>The data history is stored in <code class="docutils literal notranslate"><span class="pre">self.data_hist</span></code> and can also be deleted to
free memory. Alternatively it can be automatically pickled to disk.</p>
<p>Note that data is only stored during training.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.HistogramNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Node which stores a history of the data during its training phase.\n\n    The data history is stored in ``self.data_hist`` and can also be deleted to\n    free memory. Alternatively it can be automatically pickled to disk.\n\n    Note that data is only stored during training.\n    ', '__init__': &lt;function HistogramNode.__init__&gt;, '_get_supported_dtypes': &lt;function HistogramNode._get_supported_dtypes&gt;, '_train': &lt;function HistogramNode._train&gt;, '_stop_training': &lt;function HistogramNode._stop_training&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'stop_training': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.HistogramNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>hist_fraction=1.0</em>, <em>hist_filename=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the node.</p>
<dl class="docutils">
<dt>hist_fraction – Defines the fraction of the data that is stored</dt>
<dd>randomly.</dd>
<dt>hist_filename – Filename for the file to which the data history will</dt>
<dd>be pickled after training. The data is pickled when stop_training
is called and data_hist is then cleared (to free memory).
If filename is None (default value) then data_hist is not cleared
and can be directly used after training.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.HistogramNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.HistogramNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#HistogramNode._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.HistogramNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id151"><span class="problematic" id="id152">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#HistogramNode._stop_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.HistogramNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Pickle the histogram data to file and clear it if required.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#HistogramNode._train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.HistogramNode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the history data.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.HistogramNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.HistogramNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id153"><span class="problematic" id="id154">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.HistogramNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.HistogramNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.HistogramNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.HistogramNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Pickle the histogram data to file and clear it if required.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.HistogramNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.HistogramNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.HistogramNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.HistogramNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the history data.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.nodes.IdentityNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">IdentityNode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.signal_node.html#mdp.signal_node.PreserveDimNode" title="mdp.signal_node.PreserveDimNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.signal_node.PreserveDimNode</span></code></a></p>
<p>Execute returns the input data and the node is not trainable.</p>
<p>This node can be instantiated and is for example useful in
complex network layouts.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.IdentityNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Execute returns the input data and the node is not trainable.\n\n    This node can be instantiated and is for example useful in\n    complex network layouts.\n    ', '_get_supported_dtypes': &lt;function IdentityNode._get_supported_dtypes&gt;, 'is_trainable': &lt;staticmethod object&gt;})</em><a class="headerlink" href="#mdp.nodes.IdentityNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>If the input dimension and the output dimension are
unspecified, they will be set when the <cite>train</cite> or <cite>execute</cite>
method is called for the first time.
If dtype is unspecified, it will be inherited from the data
it receives at the first call of <cite>train</cite> or <cite>execute</cite>.</p>
<p>Every subclass must take care of up- or down-casting the internal
structures to match this argument (use <cite>_refcast</cite> private
method when possible).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.IdentityNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.IdentityNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/misc_nodes.html#IdentityNode._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.IdentityNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.IdentityNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.IdentityNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id155"><span class="problematic" id="id156">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.IdentityNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.IdentityNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.nodes.IdentityNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.IdentityNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.IdentityNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.IdentityNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.IdentityNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.IdentityNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes._OneDimensionalHitParade">
<code class="descclassname">mdp.nodes.</code><code class="descname">_OneDimensionalHitParade</code><a class="headerlink" href="#mdp.nodes._OneDimensionalHitParade" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.OneDimensionalHitParade</span></code></p>
</dd></dl>

<dl class="class">
<dt id="mdp.nodes.Convolution2DNode">
<em class="property">class </em><code class="descclassname">mdp.nodes.</code><code class="descname">Convolution2DNode</code><span class="sig-paren">(</span><em>filters</em>, <em>input_shape=None</em>, <em>approach='fft'</em>, <em>mode='full'</em>, <em>boundary='fill'</em>, <em>fillvalue=0</em>, <em>output_2d=True</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Convolve input data with filter banks.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">filters</span></code> argument specifies a set of 2D filters that are
convolved with the input data during execution. Convolution can
be selected to be executed by linear filtering of the data, or
in the frequency domain using a Discrete Fourier Transform.</p>
<p>Input data can be given as 3D data, each row being a 2D array
to be convolved with the filters, or as 2D data, in which case
the <code class="docutils literal notranslate"><span class="pre">input_shape</span></code> argument must be specified.</p>
<p>This node depends on <code class="docutils literal notranslate"><span class="pre">scipy</span></code>.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeMetaclass</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.nodes', '__doc__': 'Convolve input data with filter banks.\n\n    The ``filters`` argument specifies a set of 2D filters that are\n    convolved with the input data during execution. Convolution can\n    be selected to be executed by linear filtering of the data, or\n    in the frequency domain using a Discrete Fourier Transform.\n\n    Input data can be given as 3D data, each row being a 2D array\n    to be convolved with the filters, or as 2D data, in which case\n    the ``input_shape`` argument must be specified.\n\n    This node depends on ``scipy``.\n    ', '__init__': &lt;function Convolution2DNode.__init__&gt;, 'get_filters': &lt;function Convolution2DNode.get_filters&gt;, 'set_filters': &lt;function Convolution2DNode.set_filters&gt;, 'filters': &lt;property object&gt;, 'get_boundary': &lt;function Convolution2DNode.get_boundary&gt;, 'set_boundary': &lt;function Convolution2DNode.set_boundary&gt;, 'boundary': &lt;property object&gt;, 'input_shape': &lt;property object&gt;, 'approach': &lt;property object&gt;, 'mode': &lt;property object&gt;, 'output_shape': &lt;property object&gt;, 'is_trainable': &lt;function Convolution2DNode.is_trainable&gt;, 'is_invertible': &lt;function Convolution2DNode.is_invertible&gt;, '_get_supported_dtypes': &lt;function Convolution2DNode._get_supported_dtypes&gt;, '_pre_execution_checks': &lt;function Convolution2DNode._pre_execution_checks&gt;, '_execute': &lt;function Convolution2DNode._execute&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;})</em><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>filters</em>, <em>input_shape=None</em>, <em>approach='fft'</em>, <em>mode='full'</em>, <em>boundary='fill'</em>, <em>fillvalue=0</em>, <em>output_2d=True</em>, <em>input_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Input arguments:</p>
<dl class="docutils">
<dt>input_shape – Is a tuple (h,w) that corresponds to the height and</dt>
<dd>width of the input 2D data. If the input data is given
in a flattened format, it is first reshaped before
convolution</dd>
<dt>approach – ‘approach’ is one of [‘linear’, ‘fft’]</dt>
<dd>‘linear’: convolution is done by linear filtering;
‘fft’: convoltion is done using the Fourier Transform
If ‘approach’ is ‘fft’, the ‘boundary’ and ‘fillvalue’ arguments
are ignored, and are assumed to be ‘fill’ and 0, respectively.
(<em>Default</em> = ‘fft’)</dd>
<dt>mode – Convolution mode, as defined in scipy.signal.convolve2d</dt>
<dd>‘mode’ is one of [‘valid’, ‘same’, ‘full’]
(<em>Default</em> = ‘full’)</dd>
<dt>boundary – Boundary condition, as defined in scipy.signal.convolve2d</dt>
<dd>‘boundary’ is one of [‘fill’, ‘wrap’, ‘symm’]
(<em>Default</em> = ‘fill’)</dd>
<dt>fillvalue – Value to fill pad input arrays with</dt>
<dd>(<em>Default</em> = 0)</dd>
<dt>output_2d – If True, the output array is 2D; the first index</dt>
<dd><p class="first">corresponds to data points; every output data point
is the result of flattened convolution results, with
the output of each filter concatenated together.</p>
<p class="last">If False, the output array is 4D; the format is
data[idx,filter_nr,x,y], with
filter_nr: index of convolution filter
idx: data point index
x, y: 2D coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.nodes'</em><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/convolution_nodes.html#Convolution2DNode._execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.Convolution2DNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/convolution_nodes.html#Convolution2DNode._get_supported_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.Convolution2DNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>Support floating point types with size smaller or equal than 64 bits.
This is because fftpack does not support floating point types larger
than that.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/nodes/convolution_nodes.html#Convolution2DNode._pre_execution_checks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.nodes.Convolution2DNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.
It can be used when a subclass defines multiple execution methods.</p>
<p>In this case, the output dimension depends on the type of
convolution we use (padding, full, …). Also, we want to
to be able to accept 3D arrays.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.approach">
<code class="descname">approach</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.approach" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.boundary">
<code class="descname">boundary</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.boundary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.filters">
<code class="descname">filters</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.filters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.get_boundary">
<code class="descname">get_boundary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.get_boundary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.get_filters">
<code class="descname">get_filters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.get_filters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id157"><span class="problematic" id="id158">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.input_shape">
<code class="descname">input_shape</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.input_shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.is_invertible">
<code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.is_trainable">
<code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.mode">
<code class="descname">mode</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.mode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.output_shape">
<code class="descname">output_shape</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.output_shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.set_boundary">
<code class="descname">set_boundary</code><span class="sig-paren">(</span><em>boundary</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.set_boundary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.set_filters">
<code class="descname">set_filters</code><span class="sig-paren">(</span><em>filters</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.set_filters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.nodes.Convolution2DNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.nodes.Convolution2DNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.nodes.Convolution2DNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.nodes.Convolution2DNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mdp.nodes.classifier_nodes.html" class="btn btn-neutral float-right" title="mdp.nodes.classifier_nodes module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mdp.hinet.switchboard_factory.html" class="btn btn-neutral" title="mdp.hinet.switchboard_factory module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      Last updated on 2020-02-17 1:33:02 PM Coordinated Universal Time.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'3.5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   
<div class="footer">
    <hr />
    <table>
      <tr>
        <td class="footer-left">
           <a href="http://sourceforge.net/projects/mdp-toolkit">
 <img src="http://sflogo.sourceforge.net/sflogo.php?group_id=116959&amp;type=12"
      width="120" height="30" border="0" alt="MDP@SF.NET"/> </a>
        </td>
        <td class="footer-center">
          Last updated on
             2020-02-17 1:33:02 PM Coordinated Universal Time
        </td>
        <td class="footer-right">
         <form class="search" action="../search.html" method="get">
          <input type="submit" value="Search" />
          <input type="text" name="q" size="18" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
         </form>
        </td>
    </table>  
    <!-- Piwik -->
    <script type="text/javascript">
	var pkBaseURL = (("https:" == document.location.protocol) ? "https://sourceforge.net/apps/piwik/mdp-toolkit/" : "http://sourceforge.net/apps/piwik/mdp-toolkit/");
	document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
	piwik_action_name = '';
	piwik_idsite = 1;
	piwik_url = pkBaseURL + "piwik.php";
	piwik_log(piwik_action_name, piwik_idsite, piwik_url);
    </script>
    <object><noscript>
	    <p>
		<img src="http://sourceforge.net/apps/piwik/mdp-toolkit/piwik.php?idsite=1"
		     alt="piwik" />
	    </p>
    </noscript></object>
    <!-- End Piwik Tag -->
</div>   


</body>
</html>