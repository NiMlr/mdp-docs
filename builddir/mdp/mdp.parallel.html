

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mdp.parallel package &mdash; Modular toolkit for Data Processing (MDP)</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Modular toolkit for Data Processing (MDP)" href="../index.html"/>
        <link rel="up" title="mdp package" href="mdp.html"/>
        <link rel="next" title="mdp.parallel.parallelclassifiers module" href="mdp.parallel.parallelclassifiers.html"/>
        <link rel="prev" title="mdp.nodes.xsfa_nodes module" href="mdp.nodes.xsfa_nodes.html"/> 
<meta name="viewport" content="width=740" />


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/logo_animation.gif" class="logo" />
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../tutorial/tutorial.html">Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../examples/examples.html">Examples</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="modules.html">mdp</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="mdp.html">mdp package</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="mdp.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l5"><a class="reference internal" href="mdp.caching.html">mdp.caching package</a></li>
<li class="toctree-l5"><a class="reference internal" href="mdp.graph.html">mdp.graph package</a></li>
<li class="toctree-l5"><a class="reference internal" href="mdp.hinet.html">mdp.hinet package</a></li>
<li class="toctree-l5"><a class="reference internal" href="mdp.nodes.html">mdp.nodes package</a></li>
<li class="toctree-l5 current"><a class="current reference internal" href="#">mdp.parallel package</a></li>
<li class="toctree-l5"><a class="reference internal" href="mdp.test.html">mdp.test package</a></li>
<li class="toctree-l5"><a class="reference internal" href="mdp.utils.html">mdp.utils package</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="mdp.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="mdp.html#module-mdp">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../additional_utilities.html">Additional utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development.html">Development</a></li>
<li class="toctree-l2"><a class="reference external" href="http://mdp-toolkit.sourceforge.net/api/index.html">API documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../how_to_cite_mdp.html">How to cite MDP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MDP</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../documentation.html">Documentation</a> &raquo;</li>
        
          <li><a href="modules.html">mdp</a> &raquo;</li>
        
          <li><a href="mdp.html">mdp package</a> &raquo;</li>
        
      <li>mdp.parallel package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mdp-parallel-package">
<h1>mdp.parallel package<a class="headerlink" href="#mdp-parallel-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="mdp.parallel.parallelclassifiers.html">mdp.parallel.parallelclassifiers module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.parallel.parallelflows.html">mdp.parallel.parallelflows module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.parallel.parallelhinet.html">mdp.parallel.parallelhinet module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.parallel.parallelnodes.html">mdp.parallel.parallelnodes module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.parallel.pp_slave_script.html">mdp.parallel.pp_slave_script module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.parallel.pp_slave_wrapper.html">mdp.parallel.pp_slave_wrapper module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.parallel.pp_support.html">mdp.parallel.pp_support module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.parallel.process_schedule.html">mdp.parallel.process_schedule module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.parallel.scheduling.html">mdp.parallel.scheduling module</a></li>
<li class="toctree-l1"><a class="reference internal" href="mdp.parallel.thread_schedule.html">mdp.parallel.thread_schedule module</a></li>
</ul>
</div>
</div>
<div class="section" id="module-mdp.parallel">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-mdp.parallel" title="Permalink to this headline">¶</a></h2>
<p>This is the MDP package for parallel processing.</p>
<p>It is designed to work with nodes for which a large part of the
computation is embaressingly parallel (like in
<a class="reference internal" href="../node_list.html#mdp.nodes.PCANode" title="mdp.nodes.PCANode"><code class="xref py py-class docutils literal notranslate"><span class="pre">PCANode</span></code></a>). The hinet package is also fully
supported, i.e., there are parallel versions of all hinet nodes.</p>
<p>This package consists of two decoupled parts. The first part consists
of parallel versions of the familiar MDP structures (nodes and
flows). At the top there is the <a class="reference internal" href="#mdp.parallel.ParallelFlow" title="mdp.parallel.ParallelFlow"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParallelFlow</span></code></a>, which
generates tasks that are processed in parallel (this can be done
automatically in the train or execute methods).</p>
<p>The second part consists of the schedulers. They take tasks and
process them in a more or less parallel way (e.g. in multiple
processes). So they are designed to deal with the more technical
aspects of the parallelization, but do not have to know anything about
flows or nodes.</p>
<p><strong>Module content:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.CheckpointFlow</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.CheckpointFunction</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.CheckpointSaveFunction</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.ClassifierCumulator</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.ClassifierNode</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.CrashRecoveryException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.Cumulator</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.ExtensionException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.ExtensionNode</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.ExtensionNodeMetaclass</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.Flow</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.FlowException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.FlowExceptionCR</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.InconsistentDimException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.IsNotInvertibleException</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.IsNotTrainableException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.MDPDeprecationWarning</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.MDPException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.MDPWarning</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.Node</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.NodeException</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.NodeMetaclass</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.PreserveDimNode</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.TrainingException</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.TrainingFinishedException</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.VariadicCumulator</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">__loader__</span></code></td>
<td>Concrete implementation of SourceLoader using the file system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">__spec__</span></code></td>
<td>The specification for a module, used for loading.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.activate_extension</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.activate_extensions</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.config</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.deactivate_extension</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.deactivate_extensions</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.extension</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.extension_method</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.extension_setup</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.extension_teardown</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.fastica</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.get_active_extensions</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.get_extensions</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.pca</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.test</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">mdp.parallel.with_extension</span></code></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="mdp.parallel.ResultContainer">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ResultContainer</code><a class="headerlink" href="#mdp.parallel.ResultContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class for result containers.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Abstract base class for result containers.', 'add_result': &lt;function ResultContainer.add_result&gt;, 'get_results': &lt;function ResultContainer.get_results&gt;, '__dict__': &lt;attribute '__dict__' of 'ResultContainer' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'ResultContainer' objects&gt;})</em><a class="headerlink" href="#mdp.parallel.ResultContainer.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ResultContainer.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ResultContainer.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ResultContainer.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ResultContainer.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ResultContainer.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ResultContainer.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ResultContainer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ResultContainer.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ResultContainer.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ResultContainer.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ResultContainer.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ResultContainer.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ResultContainer.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ResultContainer.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ResultContainer.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ResultContainer.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ResultContainer.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ResultContainer.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ResultContainer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ResultContainer.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>result_data</em>, <em>task_index</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ResultContainer.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a result in the container.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ResultContainer.get_results">
<code class="descname">get_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ResultContainer.get_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results and reset container.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ListResultContainer">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ListResultContainer</code><a class="headerlink" href="#mdp.parallel.ListResultContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.ResultContainer" title="mdp.parallel.ResultContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ResultContainer</span></code></a></p>
<p>Basic result container using simply a list.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Basic result container using simply a list.', '__init__': &lt;function ListResultContainer.__init__&gt;, 'add_result': &lt;function ListResultContainer.add_result&gt;, 'get_results': &lt;function ListResultContainer.get_results&gt;})</em><a class="headerlink" href="#mdp.parallel.ListResultContainer.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ListResultContainer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ListResultContainer.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ListResultContainer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>result</em>, <em>task_index</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a result in the container.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ListResultContainer.get_results">
<code class="descname">get_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ListResultContainer.get_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of results and reset this container.</p>
<p>Note that the results are stored in the order that they come in, which
can be different from the orginal task order.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.OrderedResultContainer">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">OrderedResultContainer</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.ListResultContainer" title="mdp.parallel.ListResultContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ListResultContainer</span></code></a></p>
<p>Default result container with automatic restoring of the result order.</p>
<p>In general the order of the incoming results in the scheduler can be
different from the order of the tasks, since some tasks may finish quicker
than other tasks. This result container restores the original order.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Default result container with automatic restoring of the result order.\n\n    In general the order of the incoming results in the scheduler can be\n    different from the order of the tasks, since some tasks may finish quicker\n    than other tasks. This result container restores the original order.\n    ', '__init__': &lt;function OrderedResultContainer.__init__&gt;, 'add_result': &lt;function OrderedResultContainer.add_result&gt;, 'get_results': &lt;function OrderedResultContainer.get_results&gt;})</em><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.OrderedResultContainer.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>result</em>, <em>task_index</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a result in the container.</p>
<p>The task index is also stored and later used to reconstruct the
original task order.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.OrderedResultContainer.get_results">
<code class="descname">get_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.OrderedResultContainer.get_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the results into the original order and return them in list.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.TaskCallable">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">TaskCallable</code><a class="headerlink" href="#mdp.parallel.TaskCallable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract base class for task callables.</p>
<p>This class encapsulates the task behavior and the related fixed data
(data which stays constant over multiple tasks).</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.TaskCallable.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the computation and return the result.</p>
<p>Override this method with a concrete implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Abstract base class for task callables.\n\n    This class encapsulates the task behavior and the related fixed data\n    (data which stays constant over multiple tasks).\n    ', 'setup_environment': &lt;function TaskCallable.setup_environment&gt;, '__call__': &lt;function TaskCallable.__call__&gt;, 'fork': &lt;function TaskCallable.fork&gt;, '__dict__': &lt;attribute '__dict__' of 'TaskCallable' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'TaskCallable' objects&gt;})</em><a class="headerlink" href="#mdp.parallel.TaskCallable.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallable.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallable.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallable.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.TaskCallable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallable.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallable.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallable.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallable.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallable.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallable.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.TaskCallable.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallable.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fork of this callable, e.g. by making a copy.</p>
<p>This method is always called exactly once before a callable is called,
so instead of the original callable a fresh fork is called. This
ensures that the original callable is preserved when caching is used.
If the callable is not modified by the call then it can simply return
itself.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallable.setup_environment">
<code class="descname">setup_environment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallable.setup_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>This hook method is only called when the callable is first called
in a different Python process / environment.</p>
<p>It can be used for modifications in the Python environment that are
required by this callable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.SqrTestCallable">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">SqrTestCallable</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.TaskCallable" title="mdp.parallel.TaskCallable"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.TaskCallable</span></code></a></p>
<p>Callable for testing.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the squared data.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Callable for testing.', '__call__': &lt;function SqrTestCallable.__call__&gt;})</em><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SqrTestCallable.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.SqrTestCallable.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fork of this callable, e.g. by making a copy.</p>
<p>This method is always called exactly once before a callable is called,
so instead of the original callable a fresh fork is called. This
ensures that the original callable is preserved when caching is used.
If the callable is not modified by the call then it can simply return
itself.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SqrTestCallable.setup_environment">
<code class="descname">setup_environment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SqrTestCallable.setup_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>This hook method is only called when the callable is first called
in a different Python process / environment.</p>
<p>It can be used for modifications in the Python environment that are
required by this callable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.SleepSqrTestCallable">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">SleepSqrTestCallable</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.TaskCallable" title="mdp.parallel.TaskCallable"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.TaskCallable</span></code></a></p>
<p>Callable for testing.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the squared data[0] after sleeping for data[1] seconds.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Callable for testing.', '__call__': &lt;function SleepSqrTestCallable.__call__&gt;})</em><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.SleepSqrTestCallable.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fork of this callable, e.g. by making a copy.</p>
<p>This method is always called exactly once before a callable is called,
so instead of the original callable a fresh fork is called. This
ensures that the original callable is preserved when caching is used.
If the callable is not modified by the call then it can simply return
itself.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.SleepSqrTestCallable.setup_environment">
<code class="descname">setup_environment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.SleepSqrTestCallable.setup_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>This hook method is only called when the callable is first called
in a different Python process / environment.</p>
<p>It can be used for modifications in the Python environment that are
required by this callable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.TaskCallableWrapper">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">TaskCallableWrapper</code><span class="sig-paren">(</span><em>task_callable</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.TaskCallable" title="mdp.parallel.TaskCallable"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.TaskCallable</span></code></a></p>
<p>Wrapper to provide a fork method for simple callables like a function.</p>
<p>This wrapper is applied internally in Scheduler.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the internal callable with the data and return the result.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Wrapper to provide a fork method for simple callables like a function.\n\n    This wrapper is applied internally in Scheduler.\n    ', '__init__': &lt;function TaskCallableWrapper.__init__&gt;, '__call__': &lt;function TaskCallableWrapper.__call__&gt;})</em><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>task_callable</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Store and wrap the callable.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TaskCallableWrapper.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fork of this callable, e.g. by making a copy.</p>
<p>This method is always called exactly once before a callable is called,
so instead of the original callable a fresh fork is called. This
ensures that the original callable is preserved when caching is used.
If the callable is not modified by the call then it can simply return
itself.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TaskCallableWrapper.setup_environment">
<code class="descname">setup_environment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TaskCallableWrapper.setup_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>This hook method is only called when the callable is first called
in a different Python process / environment.</p>
<p>It can be used for modifications in the Python environment that are
required by this callable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.Scheduler">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">Scheduler</code><span class="sig-paren">(</span><em>result_container=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class and trivial implementation for schedulers.</p>
<p>New tasks are added with add_task(data, callable).
get_results then returns the results (and locks if tasks are
pending).</p>
<p>In this simple scheduler implementation the tasks are simply executed in the
add_task method.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Base class and trivial implementation for schedulers.\n\n    New tasks are added with add_task(data, callable).\n    get_results then returns the results (and locks if tasks are\n    pending).\n\n    In this simple scheduler implementation the tasks are simply executed in the\n    add_task method.\n    ', '__init__': &lt;function Scheduler.__init__&gt;, 'task_counter': &lt;property object&gt;, 'n_open_tasks': &lt;property object&gt;, 'add_task': &lt;function Scheduler.add_task&gt;, 'set_task_callable': &lt;function Scheduler.set_task_callable&gt;, '_store_result': &lt;function Scheduler._store_result&gt;, 'get_results': &lt;function Scheduler.get_results&gt;, 'shutdown': &lt;function Scheduler.shutdown&gt;, '__enter__': &lt;function Scheduler.__enter__&gt;, '__exit__': &lt;function Scheduler.__exit__&gt;, '_process_task': &lt;function Scheduler._process_task&gt;, '_shutdown': &lt;function Scheduler._shutdown&gt;, '__dict__': &lt;attribute '__dict__' of 'Scheduler' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Scheduler' objects&gt;})</em><a class="headerlink" href="#mdp.parallel.Scheduler.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__enter__">
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__exit__">
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>type</em>, <em>value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown the scheduler.</p>
<p>It is important that all the calculations have finished
when this is called, otherwise the shutdown might fail.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>result_container=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the scheduler.</p>
<dl class="docutils">
<dt>result_container – Instance of ResultContainer that is used to store</dt>
<dd>the results (default is None, in which case a ListResultContainer
is used).</dd>
</dl>
<p>verbose – If True then status messages will be printed to sys.stdout.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.Scheduler.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.Scheduler.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler._process_task">
<code class="descname">_process_task</code><span class="sig-paren">(</span><em>data</em>, <em>task_callable</em>, <em>task_index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/scheduling.html#Scheduler._process_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.Scheduler._process_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the task and store the result.</p>
<p>You can override this method for custom schedulers.</p>
<p>Warning: When this method is entered is has the lock, the lock must be
released here.</p>
<p>Warning: Note that fork has not been called yet, so the provided
task_callable must not be called. Only a forked version can be called.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler._shutdown">
<code class="descname">_shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/scheduling.html#Scheduler._shutdown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.Scheduler._shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for shutdown to be used in custom schedulers.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler._store_result">
<code class="descname">_store_result</code><span class="sig-paren">(</span><em>result</em>, <em>task_index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/scheduling.html#Scheduler._store_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.Scheduler._store_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a result in the internal result container.</p>
<p>result – Result data
task_index – Task index. Can be None if an error occured.</p>
<p>This function blocks to avoid any problems during result storage.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.add_task">
<code class="descname">add_task</code><span class="sig-paren">(</span><em>data</em>, <em>task_callable=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.add_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a task to be executed.</p>
<p>data – Data for the task.
task_callable – A callable, which is called with the data. If it is</p>
<blockquote>
<div>None (default value) then the last provided callable is used.
If task_callable is not an instance of TaskCallable then a
TaskCallableWrapper is used.</div></blockquote>
<p>The callable together with the data constitutes the task. This method
blocks if there are no free recources to store or process the task
(e.g. if no free worker processes are available).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.get_results">
<code class="descname">get_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.get_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the accumulated results from the result container.</p>
<p>This method blocks if there are open tasks.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.n_open_tasks">
<code class="descname">n_open_tasks</code><a class="headerlink" href="#mdp.parallel.Scheduler.n_open_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>This property counts of submitted but unfinished tasks.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.set_task_callable">
<code class="descname">set_task_callable</code><span class="sig-paren">(</span><em>task_callable</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.set_task_callable" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the callable that will be used if no task_callable is given.</p>
<p>Normally the callables are provided via add_task, in which case there
is no need for this method.</p>
<dl class="docutils">
<dt>task_callable – Callable that will be used unless a new task_callable</dt>
<dd>is given.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.Scheduler.shutdown">
<code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.Scheduler.shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Controlled shutdown of the scheduler.</p>
<p>This method should always be called when the scheduler is no longer
needed and before the program shuts down! Otherwise one might get
error messages.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.Scheduler.task_counter">
<code class="descname">task_counter</code><a class="headerlink" href="#mdp.parallel.Scheduler.task_counter" title="Permalink to this definition">¶</a></dt>
<dd><p>This property counts the number of submitted tasks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ProcessScheduler">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ProcessScheduler</code><span class="sig-paren">(</span><em>result_container=None</em>, <em>verbose=False</em>, <em>n_processes=1</em>, <em>source_paths=None</em>, <em>python_executable=None</em>, <em>cache_callable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.Scheduler" title="mdp.parallel.Scheduler"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.Scheduler</span></code></a></p>
<p>Scheduler that distributes the task to multiple processes.</p>
<p>The subprocess module is used to start the requested number of processes.
The execution of each task is internally managed by dedicated thread.</p>
<p>This scheduler should work on all platforms (at least on Linux,
Windows XP and Vista).</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Scheduler that distributes the task to multiple processes.\n\n    The subprocess module is used to start the requested number of processes.\n    The execution of each task is internally managed by dedicated thread.\n\n    This scheduler should work on all platforms (at least on Linux,\n    Windows XP and Vista).\n    ', '__init__': &lt;function ProcessScheduler.__init__&gt;, '_shutdown': &lt;function ProcessScheduler._shutdown&gt;, '_process_task': &lt;function ProcessScheduler._process_task&gt;, '_task_thread': &lt;function ProcessScheduler._task_thread&gt;})</em><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__enter__">
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__exit__">
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>type</em>, <em>value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown the scheduler.</p>
<p>It is important that all the calculations have finished
when this is called, otherwise the shutdown might fail.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>result_container=None</em>, <em>verbose=False</em>, <em>n_processes=1</em>, <em>source_paths=None</em>, <em>python_executable=None</em>, <em>cache_callable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the scheduler and start the slave processes.</p>
<p>result_container – ResultContainer used to store the results.
verbose – Set to True to get progress reports from the scheduler</p>
<blockquote>
<div>(default value is False).</div></blockquote>
<dl class="docutils">
<dt>n_processes – Number of processes used in parallel. If None (default)</dt>
<dd>then the number of detected CPU cores is used.</dd>
<dt>source_paths – List of paths that are added to sys.path in</dt>
<dd>the processes to make the task unpickling work. A single path
instead of a list is also accepted.
If None (default value) then source_paths is set to sys.path.
To prevent this you can specify an empty list.</dd>
<dt>python_executable – Python executable that is used for the processes.</dt>
<dd>The default value is None, in which case sys.executable will be
used.</dd>
<dt>cache_callable – Cache the task objects in the processes (default</dt>
<dd>is True). Disabling caching can reduce the memory usage, but will
generally be less efficient since the task_callable has to be
pickled each time.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler._process_task">
<code class="descname">_process_task</code><span class="sig-paren">(</span><em>data</em>, <em>task_callable</em>, <em>task_index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/process_schedule.html#ProcessScheduler._process_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ProcessScheduler._process_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a task, if possible without blocking.</p>
<p>It blocks when the system is not able to start a new thread
or when the processes are all in use.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler._shutdown">
<code class="descname">_shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/process_schedule.html#ProcessScheduler._shutdown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ProcessScheduler._shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Shut down the slave processes.</p>
<p>If a process is still running a task then an exception is raised.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler._store_result">
<code class="descname">_store_result</code><span class="sig-paren">(</span><em>result</em>, <em>task_index</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler._store_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a result in the internal result container.</p>
<p>result – Result data
task_index – Task index. Can be None if an error occured.</p>
<p>This function blocks to avoid any problems during result storage.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler._task_thread">
<code class="descname">_task_thread</code><span class="sig-paren">(</span><em>process</em>, <em>data</em>, <em>task_callable</em>, <em>task_index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/process_schedule.html#ProcessScheduler._task_thread"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ProcessScheduler._task_thread" title="Permalink to this definition">¶</a></dt>
<dd><p>Thread function which cares for a single task.</p>
<p>The task is pushed to the process via stdin, then we wait for the
result on stdout, pass the result to the result container, free
the process and exit.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.add_task">
<code class="descname">add_task</code><span class="sig-paren">(</span><em>data</em>, <em>task_callable=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.add_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a task to be executed.</p>
<p>data – Data for the task.
task_callable – A callable, which is called with the data. If it is</p>
<blockquote>
<div>None (default value) then the last provided callable is used.
If task_callable is not an instance of TaskCallable then a
TaskCallableWrapper is used.</div></blockquote>
<p>The callable together with the data constitutes the task. This method
blocks if there are no free recources to store or process the task
(e.g. if no free worker processes are available).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.get_results">
<code class="descname">get_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.get_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the accumulated results from the result container.</p>
<p>This method blocks if there are open tasks.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.n_open_tasks">
<code class="descname">n_open_tasks</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.n_open_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>This property counts of submitted but unfinished tasks.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.set_task_callable">
<code class="descname">set_task_callable</code><span class="sig-paren">(</span><em>task_callable</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.set_task_callable" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the callable that will be used if no task_callable is given.</p>
<p>Normally the callables are provided via add_task, in which case there
is no need for this method.</p>
<dl class="docutils">
<dt>task_callable – Callable that will be used unless a new task_callable</dt>
<dd>is given.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ProcessScheduler.shutdown">
<code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ProcessScheduler.shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Controlled shutdown of the scheduler.</p>
<p>This method should always be called when the scheduler is no longer
needed and before the program shuts down! Otherwise one might get
error messages.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ProcessScheduler.task_counter">
<code class="descname">task_counter</code><a class="headerlink" href="#mdp.parallel.ProcessScheduler.task_counter" title="Permalink to this definition">¶</a></dt>
<dd><p>This property counts the number of submitted tasks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ThreadScheduler">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ThreadScheduler</code><span class="sig-paren">(</span><em>result_container=None</em>, <em>verbose=False</em>, <em>n_threads=1</em>, <em>copy_callable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.Scheduler" title="mdp.parallel.Scheduler"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.Scheduler</span></code></a></p>
<p>Thread based scheduler.</p>
<p>Because of the GIL this only makes sense if most of the time is spend in
numpy calculations (or some other external non-blocking C code) or for IO,
but can be more efficient than ProcessScheduler because of the
shared memory.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Thread based scheduler.\n\n    Because of the GIL this only makes sense if most of the time is spend in\n    numpy calculations (or some other external non-blocking C code) or for IO,\n    but can be more efficient than ProcessScheduler because of the\n    shared memory.\n    ', '__init__': &lt;function ThreadScheduler.__init__&gt;, '_process_task': &lt;function ThreadScheduler._process_task&gt;, '_task_thread': &lt;function ThreadScheduler._task_thread&gt;})</em><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__enter__">
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__exit__">
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>type</em>, <em>value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Shutdown the scheduler.</p>
<p>It is important that all the calculations have finished
when this is called, otherwise the shutdown might fail.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>result_container=None</em>, <em>verbose=False</em>, <em>n_threads=1</em>, <em>copy_callable=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the scheduler.</p>
<p>result_container – ResultContainer used to store the results.
verbose – Set to True to get progress reports from the scheduler</p>
<blockquote>
<div>(default value is False).</div></blockquote>
<dl class="docutils">
<dt>n_threads – Number of threads used in parallel. If None (default)</dt>
<dd>then the number of detected CPU cores is used.</dd>
<dt>copy_callable – Use deep copies of the task callable in the threads.</dt>
<dd>This is for example required if some nodes are stateful during
execution (e.g., a BiNode using the coroutine decorator).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler._process_task">
<code class="descname">_process_task</code><span class="sig-paren">(</span><em>data</em>, <em>task_callable</em>, <em>task_index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/thread_schedule.html#ThreadScheduler._process_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ThreadScheduler._process_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a task, if possible without blocking.</p>
<p>It blocks when the maximum number of threads is reached (given by
n_threads) or when the system is not able to start a new thread.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler._shutdown">
<code class="descname">_shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler._shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for shutdown to be used in custom schedulers.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler._store_result">
<code class="descname">_store_result</code><span class="sig-paren">(</span><em>result</em>, <em>task_index</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler._store_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a result in the internal result container.</p>
<p>result – Result data
task_index – Task index. Can be None if an error occured.</p>
<p>This function blocks to avoid any problems during result storage.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler._task_thread">
<code class="descname">_task_thread</code><span class="sig-paren">(</span><em>data</em>, <em>task_callable</em>, <em>task_index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/thread_schedule.html#ThreadScheduler._task_thread"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ThreadScheduler._task_thread" title="Permalink to this definition">¶</a></dt>
<dd><p>Thread function which processes a single task.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.add_task">
<code class="descname">add_task</code><span class="sig-paren">(</span><em>data</em>, <em>task_callable=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.add_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a task to be executed.</p>
<p>data – Data for the task.
task_callable – A callable, which is called with the data. If it is</p>
<blockquote>
<div>None (default value) then the last provided callable is used.
If task_callable is not an instance of TaskCallable then a
TaskCallableWrapper is used.</div></blockquote>
<p>The callable together with the data constitutes the task. This method
blocks if there are no free recources to store or process the task
(e.g. if no free worker processes are available).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.get_results">
<code class="descname">get_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.get_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the accumulated results from the result container.</p>
<p>This method blocks if there are open tasks.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.n_open_tasks">
<code class="descname">n_open_tasks</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.n_open_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>This property counts of submitted but unfinished tasks.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.set_task_callable">
<code class="descname">set_task_callable</code><span class="sig-paren">(</span><em>task_callable</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.set_task_callable" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the callable that will be used if no task_callable is given.</p>
<p>Normally the callables are provided via add_task, in which case there
is no need for this method.</p>
<dl class="docutils">
<dt>task_callable – Callable that will be used unless a new task_callable</dt>
<dd>is given.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ThreadScheduler.shutdown">
<code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ThreadScheduler.shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Controlled shutdown of the scheduler.</p>
<p>This method should always be called when the scheduler is no longer
needed and before the program shuts down! Otherwise one might get
error messages.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ThreadScheduler.task_counter">
<code class="descname">task_counter</code><a class="headerlink" href="#mdp.parallel.ThreadScheduler.task_counter" title="Permalink to this definition">¶</a></dt>
<dd><p>This property counts the number of submitted tasks.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ParallelExtensionNode">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelExtensionNode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.ExtensionNode" title="mdp.ExtensionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ExtensionNode</span></code></a>, <a class="reference internal" href="mdp.html#mdp.Node" title="mdp.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Node</span></code></a></p>
<p>Base class for parallel trainable MDP nodes.</p>
<p>With the fork method new node instances are created which can then be
trained. With the join method the trained instances are then merged back
into a single node instance.</p>
<p>This class defines default methods which raise a
TrainingPhaseNotParallelException exception.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="mdp.html#mdp.ExtensionNodeMetaclass" title="mdp.ExtensionNodeMetaclass"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ExtensionNodeMetaclass</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Base class for parallel trainable MDP nodes.\n\n    With the fork method new node instances are created which can then be\n    trained. With the join method the trained instances are then merged back\n    into a single node instance.\n\n    This class defines default methods which raise a\n    TrainingPhaseNotParallelException exception.\n    ', 'extension_name': 'parallel', 'fork': &lt;function ParallelExtensionNode.fork&gt;, 'join': &lt;function ParallelExtensionNode.join&gt;, '_fork': &lt;function ParallelExtensionNode._fork&gt;, '_join': &lt;function ParallelExtensionNode._join&gt;, 'use_execute_fork': &lt;staticmethod object&gt;, '_default_fork': &lt;function ParallelExtensionNode._default_fork&gt;, '_join_covariance': &lt;staticmethod object&gt;})</em><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>If the input dimension and the output dimension are
unspecified, they will be set when the <cite>train</cite> or <cite>execute</cite>
method is called for the first time.
If dtype is unspecified, it will be inherited from the data
it receives at the first call of <cite>train</cite> or <cite>execute</cite>.</p>
<p>Every subclass must take care of up- or down-casting the internal
structures to match this argument (use <cite>_refcast</cite> private
method when possible).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._default_fork">
<code class="descname">_default_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelExtensionNode._default_fork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._default_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation of _fork.</p>
<p>It uses introspection to determine the init kwargs and tries to fill
them with attributes. These kwargs are then used to instanciate
self.__class__ to create the fork instance.</p>
<p>So you can use this method if all the required keys are also public
attributes or have a single underscore in front.</p>
<p>There are two reasons why this method does not simply replace _fork
of ParallelExtensionNode (plus removing Node from the
inheritance list):
- If a node is not parallelized _fork raises an exception, as do nodes</p>
<blockquote>
<div>which can not fork due to some other reasons. Without this bahavior
of _fork we would have to check with hasattr first if fork is
present, adding more complexity at other places (mostly in
container nodes).</div></blockquote>
<ul class="simple">
<li><dl class="first docutils">
<dt>This is a safeguard forcing users to think a little instead of</dt>
<dd>relying on the inherited (but possibly incompatible)
default implementation.</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._fork">
<code class="descname">_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelExtensionNode._fork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for forking with default implementation.</p>
<p>Overwrite this method for nodes that can be parallelized.
You can use _default_fork, if that is compatible with your node class,
typically the hard part is the joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id1"><span class="problematic" id="id2">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelExtensionNode._join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for joining, to be overridden.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelExtensionNode._join_covariance">
<em class="property">static </em><code class="descname">_join_covariance</code><span class="sig-paren">(</span><em>cov</em>, <em>forked_cov</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelExtensionNode._join_covariance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._join_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to join two CovarianceMatrix instances.</p>
<dl class="docutils">
<dt>cov – Instance of CovarianceMatrix, to which the forked_cov instance</dt>
<dd>is aded in-place.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.extension_name">
<code class="descname">extension_name</code><em class="property"> = 'parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.extension_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of this node class for remote training.</p>
<p>This is a template method, the actual forking should be implemented in
_fork.</p>
<p>The forked node should be a ParallelNode of the same class as well,
thus allowing recursive forking and joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id3"><span class="problematic" id="id4">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelExtensionNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelExtensionNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Absorb the trained node from a fork into this parent node.</p>
<p>This is a template method, the actual joining should be implemented in
_join.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelExtensionNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelExtensionNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelExtensionNode.use_execute_fork">
<em class="property">static </em><code class="descname">use_execute_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelExtensionNode.use_execute_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if node requires a fork / join even during execution.</p>
<p>The default output is False, overwrite this method if required.</p>
<p>Note that the same fork and join methods are used as during training,
so the distinction must be implemented in the custom _fork and _join
methods.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="mdp.parallel.JoinParallelException">
<em class="property">exception </em><code class="descclassname">mdp.parallel.</code><code class="descname">JoinParallelException</code><a class="headerlink" href="#mdp.parallel.JoinParallelException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.NodeException" title="mdp.NodeException"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeException</span></code></a></p>
<p>Exception for errors when joining parallel nodes.</p>
<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__cause__">
<code class="descname">__cause__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__context__">
<code class="descname">__context__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Exception for errors when joining parallel nodes.'})</em><a class="headerlink" href="#mdp.parallel.JoinParallelException.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.JoinParallelException.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.JoinParallelException.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.JoinParallelException.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.JoinParallelException.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.JoinParallelException.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.JoinParallelException.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.JoinParallelException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.JoinParallelException.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.JoinParallelException.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.JoinParallelException.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.JoinParallelException.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.JoinParallelException.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.JoinParallelException.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.JoinParallelException.__setstate__">
<code class="descname">__setstate__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.JoinParallelException.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.JoinParallelException.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.JoinParallelException.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.JoinParallelException.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.JoinParallelException.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__suppress_context__">
<code class="descname">__suppress_context__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__traceback__">
<code class="descname">__traceback__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.JoinParallelException.args">
<code class="descname">args</code><a class="headerlink" href="#mdp.parallel.JoinParallelException.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.JoinParallelException.with_traceback">
<code class="descname">with_traceback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.JoinParallelException.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="mdp.parallel.NotForkableParallelException">
<em class="property">exception </em><code class="descclassname">mdp.parallel.</code><code class="descname">NotForkableParallelException</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.NodeException" title="mdp.NodeException"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.NodeException</span></code></a></p>
<p>Exception to signal that a fork is not possible.</p>
<p>This exception is can be safely used and should be caught inside the
ParallelFlow or the Scheduler.</p>
<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__cause__">
<code class="descname">__cause__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__context__">
<code class="descname">__context__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Exception to signal that a fork is not possible.\n\n    This exception is can be safely used and should be caught inside the\n    ParallelFlow or the Scheduler.\n    '})</em><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.NotForkableParallelException.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NotForkableParallelException.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NotForkableParallelException.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NotForkableParallelException.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NotForkableParallelException.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NotForkableParallelException.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NotForkableParallelException.__setstate__">
<code class="descname">__setstate__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.NotForkableParallelException.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NotForkableParallelException.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__suppress_context__">
<code class="descname">__suppress_context__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__traceback__">
<code class="descname">__traceback__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NotForkableParallelException.args">
<code class="descname">args</code><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.NotForkableParallelException.with_traceback">
<code class="descname">with_traceback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NotForkableParallelException.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ParallelSFANode">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelSFANode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>include_last_sample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.ParallelExtensionNode" title="mdp.parallel.ParallelExtensionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ParallelExtensionNode</span></code></a>, <a class="reference internal" href="../node_list.html#mdp.nodes.SFANode" title="mdp.nodes.SFANode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.SFANode</span></code></a></p>
<p>Parallel version of MDP SFA node.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="mdp.html#mdp.ExtensionNodeMetaclass" title="mdp.ExtensionNodeMetaclass"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ExtensionNodeMetaclass</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Parallel version of MDP SFA node.', '_fork': &lt;function ParallelSFANode._fork&gt;, '_join': &lt;function ParallelSFANode._join&gt;})</em><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>include_last_sample=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._default_fork">
<code class="descname">_default_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._default_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation of _fork.</p>
<p>It uses introspection to determine the init kwargs and tries to fill
them with attributes. These kwargs are then used to instanciate
self.__class__ to create the fork instance.</p>
<p>So you can use this method if all the required keys are also public
attributes or have a single underscore in front.</p>
<p>There are two reasons why this method does not simply replace _fork
of ParallelExtensionNode (plus removing Node from the
inheritance list):
- If a node is not parallelized _fork raises an exception, as do nodes</p>
<blockquote>
<div>which can not fork due to some other reasons. Without this bahavior
of _fork we would have to check with hasattr first if fork is
present, adding more complexity at other places (mostly in
container nodes).</div></blockquote>
<ul class="simple">
<li><dl class="first docutils">
<dt>This is a safeguard forcing users to think a little instead of</dt>
<dd>relying on the inherited (but possibly incompatible)
default implementation.</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output of the slowest functions.
If ‘n’ is an integer, then use the first ‘n’ slowest components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._fork">
<code class="descname">_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelSFANode._fork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelSFANode._fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for forking with default implementation.</p>
<p>Overwrite this method for nodes that can be parallelized.
You can use _default_fork, if that is compatible with your node class,
typically the hard part is the joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id5"><span class="problematic" id="id6">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelSFANode._join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelSFANode._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the covariance matrices.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelSFANode._join_covariance">
<em class="property">static </em><code class="descname">_join_covariance</code><span class="sig-paren">(</span><em>cov</em>, <em>forked_cov</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._join_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to join two CovarianceMatrix instances.</p>
<dl class="docutils">
<dt>cov – Instance of CovarianceMatrix, to which the forked_cov instance</dt>
<dd>is aded in-place.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._set_range">
<code class="descname">_set_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._set_range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>include_last_sample=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output of the slowest functions.
If ‘n’ is an integer, then use the first ‘n’ slowest components.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.extension_name">
<code class="descname">extension_name</code><em class="property"> = 'parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelSFANode.extension_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of this node class for remote training.</p>
<p>This is a template method, the actual forking should be implemented in
_fork.</p>
<p>The forked node should be a ParallelNode of the same class as well,
thus allowing recursive forking and joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.get_eta_values">
<code class="descname">get_eta_values</code><span class="sig-paren">(</span><em>t=1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.get_eta_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the eta values of the slow components learned during
the training phase. If the training phase has not been completed
yet, call <cite>stop_training</cite>.</p>
<p>The delta value of a signal is a measure of its temporal
variation, and is defined as the mean of the derivative squared,
i.e. delta(x) = mean(dx/dt(t)^2).  delta(x) is zero if
x is a constant signal, and increases if the temporal variation
of the signal is bigger.</p>
<p>The eta value is a more intuitive measure of temporal variation,
defined as
eta(x) = t/(2*pi) * sqrt(delta(x))
If x is a signal of length ‘t’ which consists of a sine function
that accomplishes exactly N oscillations, then eta(x)=N.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>t</dt>
<dd><p class="first">Sampling frequency in Hz.</p>
<p class="last">The original definition in (Wiskott and Sejnowski, 2002)
is obtained for t = number of training data points, while
for t=1 (default), this corresponds to the beta-value defined in
(Berkes and Wiskott, 2005).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id7"><span class="problematic" id="id8">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelSFANode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelSFANode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Absorb the trained node from a fork into this parent node.</p>
<p>This is a template method, the actual joining should be implemented in
_join.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelSFANode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.parallel.ParallelSFANode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.time_derivative">
<code class="descname">time_derivative</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.time_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the linear approximation of the time derivative.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelSFANode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>include_last_sample=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelSFANode.use_execute_fork">
<em class="property">static </em><code class="descname">use_execute_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelSFANode.use_execute_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if node requires a fork / join even during execution.</p>
<p>The default output is False, overwrite this method if required.</p>
<p>Note that the same fork and join methods are used as during training,
so the distinction must be implemented in the custom _fork and _join
methods.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelSFANode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>include_last_sample=True</em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.ParallelExtensionNode" title="mdp.parallel.ParallelExtensionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ParallelExtensionNode</span></code></a>, <a class="reference internal" href="../node_list.html#mdp.nodes.SFANode" title="mdp.nodes.SFANode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.SFANode</span></code></a></p>
<p>Parallel version of MDP SFA node.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt>
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__class__</code></dt>
<dd><p>alias of <a class="reference internal" href="mdp.html#mdp.ExtensionNodeMetaclass" title="mdp.ExtensionNodeMetaclass"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ExtensionNodeMetaclass</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__delattr__</code></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Parallel version of MDP SFA node.', '_fork': &lt;function ParallelSFANode._fork&gt;, '_join': &lt;function ParallelSFANode._join&gt;})</em></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__eq__</code></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__ge__</code></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__getattribute__</code></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__gt__</code></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__hash__</code></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em>, <em>include_last_sample=True</em><span class="sig-paren">)</span></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__le__</code></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__lt__</code></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__ne__</code></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__setattr__</code></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">__weakref__</code></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_default_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Default implementation of _fork.</p>
<p>It uses introspection to determine the init kwargs and tries to fill
them with attributes. These kwargs are then used to instanciate
self.__class__ to create the fork instance.</p>
<p>So you can use this method if all the required keys are also public
attributes or have a single underscore in front.</p>
<p>There are two reasons why this method does not simply replace _fork
of ParallelExtensionNode (plus removing Node from the
inheritance list):
- If a node is not parallelized _fork raises an exception, as do nodes</p>
<blockquote>
<div>which can not fork due to some other reasons. Without this bahavior
of _fork we would have to check with hasattr first if fork is
present, adding more complexity at other places (mostly in
container nodes).</div></blockquote>
<ul class="simple">
<li><dl class="first docutils">
<dt>This is a safeguard forcing users to think a little instead of</dt>
<dd>relying on the inherited (but possibly incompatible)
default implementation.</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span></dt>
<dd><p>Compute the output of the slowest functions.
If ‘n’ is an integer, then use the first ‘n’ slowest components.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelSFANode._fork"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Hook method for forking with default implementation.</p>
<p>Overwrite this method for nodes that can be parallelized.
You can use _default_fork, if that is compatible with your node class,
typically the hard part is the joining.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id9"><span class="problematic" id="id10">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelSFANode._join"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Combine the covariance matrices.</p>
</dd></dl>

<dl class="staticmethod">
<dt>
<em class="property">static </em><code class="descname">_join_covariance</code><span class="sig-paren">(</span><em>cov</em>, <em>forked_cov</em><span class="sig-paren">)</span></dt>
<dd><p>Helper method to join two CovarianceMatrix instances.</p>
<dl class="docutils">
<dt>cov – Instance of CovarianceMatrix, to which the forked_cov instance</dt>
<dd>is aded in-place.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_set_range</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>include_last_sample=None</em><span class="sig-paren">)</span></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">_train_seq</code></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">dtype</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span></dt>
<dd><p>Compute the output of the slowest functions.
If ‘n’ is an integer, then use the first ‘n’ slowest components.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">extension_name</code><em class="property"> = 'parallel'</em></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return a new instance of this node class for remote training.</p>
<p>This is a template method, the actual forking should be implemented in
_fork.</p>
<p>The forked node should be a ParallelNode of the same class as well,
thus allowing recursive forking and joining.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_eta_values</code><span class="sig-paren">(</span><em>t=1</em><span class="sig-paren">)</span></dt>
<dd><p>Return the eta values of the slow components learned during
the training phase. If the training phase has not been completed
yet, call <cite>stop_training</cite>.</p>
<p>The delta value of a signal is a measure of its temporal
variation, and is defined as the mean of the derivative squared,
i.e. delta(x) = mean(dx/dt(t)^2).  delta(x) is zero if
x is a constant signal, and increases if the temporal variation
of the signal is bigger.</p>
<p>The eta value is a more intuitive measure of temporal variation,
defined as
eta(x) = t/(2*pi) * sqrt(delta(x))
If x is a signal of length ‘t’ which consists of a sine function
that accomplishes exactly N oscillations, then eta(x)=N.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>t</dt>
<dd><p class="first">Sampling frequency in Hz.</p>
<p class="last">The original definition in (Wiskott and Sejnowski, 2002)
is obtained for t = number of training data points, while
for t=1 (default), this corresponds to the beta-value defined in
(Berkes and Wiskott, 2005).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id11"><span class="problematic" id="id12">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">input_dim</code></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt>
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt>
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span></dt>
<dd><p>Absorb the trained node from a fork into this parent node.</p>
<p>This is a template method, the actual joining should be implemented in
_join.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">output_dim</code></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>debug=False</em><span class="sig-paren">)</span></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">supported_dtypes</code></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">time_derivative</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span></dt>
<dd><p>Compute the linear approximation of the time derivative.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>include_last_sample=None</em><span class="sig-paren">)</span></dt>
<dd><p>For the <code class="docutils literal notranslate"><span class="pre">include_last_sample</span></code> switch have a look at the
SFANode class docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt>
<em class="property">static </em><code class="descname">use_execute_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Return True if node requires a fork / join even during execution.</p>
<p>The default output is False, overwrite this method if required.</p>
<p>Note that the same fork and join methods are used as during training,
so the distinction must be implemented in the custom _fork and _join
methods.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ParallelFDANode">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelFDANode</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.ParallelExtensionNode" title="mdp.parallel.ParallelExtensionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ParallelExtensionNode</span></code></a>, <a class="reference internal" href="../node_list.html#mdp.nodes.FDANode" title="mdp.nodes.FDANode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.FDANode</span></code></a></p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="mdp.html#mdp.ExtensionNodeMetaclass" title="mdp.ExtensionNodeMetaclass"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ExtensionNodeMetaclass</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '_fork': &lt;function ParallelFDANode._fork&gt;, '_join': &lt;function ParallelFDANode._join&gt;, '__doc__': None})</em><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>If the input dimension and the output dimension are
unspecified, they will be set when the <cite>train</cite> or <cite>execute</cite>
method is called for the first time.
If dtype is unspecified, it will be inherited from the data
it receives at the first call of <cite>train</cite> or <cite>execute</cite>.</p>
<p>Every subclass must take care of up- or down-casting the internal
structures to match this argument (use <cite>_refcast</cite> private
method when possible).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._default_fork">
<code class="descname">_default_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._default_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation of _fork.</p>
<p>It uses introspection to determine the init kwargs and tries to fill
them with attributes. These kwargs are then used to instanciate
self.__class__ to create the fork instance.</p>
<p>So you can use this method if all the required keys are also public
attributes or have a single underscore in front.</p>
<p>There are two reasons why this method does not simply replace _fork
of ParallelExtensionNode (plus removing Node from the
inheritance list):
- If a node is not parallelized _fork raises an exception, as do nodes</p>
<blockquote>
<div>which can not fork due to some other reasons. Without this bahavior
of _fork we would have to check with hasattr first if fork is
present, adding more complexity at other places (mostly in
container nodes).</div></blockquote>
<ul class="simple">
<li><dl class="first docutils">
<dt>This is a safeguard forcing users to think a little instead of</dt>
<dd>relying on the inherited (but possibly incompatible)
default implementation.</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output of the FDA projection.</p>
<p>If ‘n’ is an integer, then use the first ‘n’ components.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._fork">
<code class="descname">_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelFDANode._fork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelFDANode._fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for forking with default implementation.</p>
<p>Overwrite this method for nodes that can be parallelized.
You can use _default_fork, if that is compatible with your node class,
typically the hard part is the joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id13"><span class="problematic" id="id14">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelFDANode._join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelFDANode._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for joining, to be overridden.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelFDANode._join_covariance">
<em class="property">static </em><code class="descname">_join_covariance</code><span class="sig-paren">(</span><em>cov</em>, <em>forked_cov</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._join_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to join two CovarianceMatrix instances.</p>
<dl class="docutils">
<dt>cov – Instance of CovarianceMatrix, to which the forked_cov instance</dt>
<dd>is aded in-place.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._stop_fda">
<code class="descname">_stop_fda</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._stop_fda" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the eigenvalue problem for the total covariance.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._stop_means">
<code class="descname">_stop_means</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._stop_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the class means.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data ‘x’.</p>
<dl class="docutils">
<dt>x – a matrix having different variables on different columns</dt>
<dd>and observations on the rows.</dd>
<dt>label – can be a list, tuple or array of labels (one for each data</dt>
<dd>point) or a single label, in which case all input data is assigned
to the same class.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._train_fda">
<code class="descname">_train_fda</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._train_fda" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather data for the overall and within-class covariance</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._train_means">
<code class="descname">_train_means</code><span class="sig-paren">(</span><em>x</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._train_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather data to compute the means and number of elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._update_SW">
<code class="descname">_update_SW</code><span class="sig-paren">(</span><em>x</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._update_SW" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the covariance matrix of the class means.</p>
<p>x – Data points from a single class.
label – The label for that class.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode._update_means">
<code class="descname">_update_means</code><span class="sig-paren">(</span><em>x</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode._update_means" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal variables that store the data for the means.</p>
<p>x – Data points from a single class.
label – The label for that class.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>n=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output of the FDA projection.</p>
<p>If ‘n’ is an integer, then use the first ‘n’ components.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.extension_name">
<code class="descname">extension_name</code><em class="property"> = 'parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelFDANode.extension_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of this node class for remote training.</p>
<p>This is a template method, the actual forking should be implemented in
_fork.</p>
<p>The forked node should be a ParallelNode of the same class as well,
thus allowing recursive forking and joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id15"><span class="problematic" id="id16">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelFDANode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelFDANode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Absorb the trained node from a fork into this parent node.</p>
<p>This is a template method, the actual joining should be implemented in
_join.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFDANode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.parallel.ParallelFDANode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFDANode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data ‘x’.</p>
<dl class="docutils">
<dt>x – a matrix having different variables on different columns</dt>
<dd>and observations on the rows.</dd>
<dt>label – can be a list, tuple or array of labels (one for each data</dt>
<dd>point) or a single label, in which case all input data is assigned
to the same class.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelFDANode.use_execute_fork">
<em class="property">static </em><code class="descname">use_execute_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFDANode.use_execute_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if node requires a fork / join even during execution.</p>
<p>The default output is False, overwrite this method if required.</p>
<p>Note that the same fork and join methods are used as during training,
so the distinction must be implemented in the custom _fork and _join
methods.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ParallelHistogramNode">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelHistogramNode</code><span class="sig-paren">(</span><em>hist_fraction=1.0</em>, <em>hist_filename=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.ParallelExtensionNode" title="mdp.parallel.ParallelExtensionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ParallelExtensionNode</span></code></a>, <a class="reference internal" href="../node_list.html#mdp.nodes.HistogramNode" title="mdp.nodes.HistogramNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.nodes.HistogramNode</span></code></a></p>
<p>Parallel version of the HistogramNode.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="mdp.html#mdp.ExtensionNodeMetaclass" title="mdp.ExtensionNodeMetaclass"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ExtensionNodeMetaclass</span></code></a></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Parallel version of the HistogramNode.', '_fork': &lt;function ParallelHistogramNode._fork&gt;, '_join': &lt;function ParallelHistogramNode._join&gt;})</em><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>hist_fraction=1.0</em>, <em>hist_filename=None</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the node.</p>
<dl class="docutils">
<dt>hist_fraction – Defines the fraction of the data that is stored</dt>
<dd>randomly.</dd>
<dt>hist_filename – Filename for the file to which the data history will</dt>
<dd>be pickled after training. The data is pickled when stop_training
is called and data_hist is then cleared (to free memory).
If filename is None (default value) then data_hist is not cleared
and can be directly used after training.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._default_fork">
<code class="descname">_default_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._default_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation of _fork.</p>
<p>It uses introspection to determine the init kwargs and tries to fill
them with attributes. These kwargs are then used to instanciate
self.__class__ to create the fork instance.</p>
<p>So you can use this method if all the required keys are also public
attributes or have a single underscore in front.</p>
<p>There are two reasons why this method does not simply replace _fork
of ParallelExtensionNode (plus removing Node from the
inheritance list):
- If a node is not parallelized _fork raises an exception, as do nodes</p>
<blockquote>
<div>which can not fork due to some other reasons. Without this bahavior
of _fork we would have to check with hasattr first if fork is
present, adding more complexity at other places (mostly in
container nodes).</div></blockquote>
<ul class="simple">
<li><dl class="first docutils">
<dt>This is a safeguard forcing users to think a little instead of</dt>
<dd>relying on the inherited (but possibly incompatible)
default implementation.</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._fork">
<code class="descname">_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelHistogramNode._fork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for forking with default implementation.</p>
<p>Overwrite this method for nodes that can be parallelized.
You can use _default_fork, if that is compatible with your node class,
typically the hard part is the joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id17"><span class="problematic" id="id18">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelnodes.html#ParallelHistogramNode._join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method for joining, to be overridden.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelHistogramNode._join_covariance">
<em class="property">static </em><code class="descname">_join_covariance</code><span class="sig-paren">(</span><em>cov</em>, <em>forked_cov</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._join_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to join two CovarianceMatrix instances.</p>
<dl class="docutils">
<dt>cov – Instance of CovarianceMatrix, to which the forked_cov instance</dt>
<dd>is aded in-place.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Pickle the histogram data to file and clear it if required.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the history data.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.extension_name">
<code class="descname">extension_name</code><em class="property"> = 'parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.extension_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of this node class for remote training.</p>
<p>This is a template method, the actual forking should be implemented in
_fork.</p>
<p>The forked node should be a ParallelNode of the same class as well,
thus allowing recursive forking and joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id19"><span class="problematic" id="id20">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>y</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelHistogramNode.is_invertible">
<em class="property">static </em><code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelHistogramNode.is_trainable">
<em class="property">static </em><code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Absorb the trained node from a fork into this parent node.</p>
<p>This is a template method, the actual joining should be implemented in
_join.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Pickle the histogram data to file and clear it if required.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelHistogramNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelHistogramNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the history data.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelHistogramNode.use_execute_fork">
<em class="property">static </em><code class="descname">use_execute_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelHistogramNode.use_execute_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if node requires a fork / join even during execution.</p>
<p>The default output is False, overwrite this method if required.</p>
<p>Note that the same fork and join methods are used as during training,
so the distinction must be implemented in the custom _fork and _join
methods.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.FlowTaskCallable">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">FlowTaskCallable</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.TaskCallable" title="mdp.parallel.TaskCallable"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.TaskCallable</span></code></a></p>
<p>Base class for all flow callables.</p>
<p>It deals activating the required extensions.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the computation and return the result.</p>
<p>Override this method with a concrete implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Base class for all flow callables.\n\n    It deals activating the required extensions.\n    ', '__init__': &lt;function FlowTaskCallable.__init__&gt;, 'setup_environment': &lt;function FlowTaskCallable.setup_environment&gt;})</em><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the currently active extensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTaskCallable.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fork of this callable, e.g. by making a copy.</p>
<p>This method is always called exactly once before a callable is called,
so instead of the original callable a fresh fork is called. This
ensures that the original callable is preserved when caching is used.
If the callable is not modified by the call then it can simply return
itself.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTaskCallable.setup_environment">
<code class="descname">setup_environment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTaskCallable.setup_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate the used extensions.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.FlowTrainCallable">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">FlowTrainCallable</code><span class="sig-paren">(</span><em>flownode</em>, <em>purge_nodes=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.FlowTaskCallable" title="mdp.parallel.FlowTaskCallable"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.FlowTaskCallable</span></code></a></p>
<p>Implements a single training phase in a flow for a data block.</p>
<p>A FlowNode is used to simplify the forking process and to
encapsulate the flow.</p>
<p>You can also derive from this class to define your own callable class.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Do the training and return only the trained node.</p>
<dl class="docutils">
<dt>data – training data block (array or list if additional arguments are</dt>
<dd>required)</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Implements a single training phase in a flow for a data block.\n\n    A FlowNode is used to simplify the forking process and to\n    encapsulate the flow.\n\n    You can also derive from this class to define your own callable class.\n    ', '__init__': &lt;function FlowTrainCallable.__init__&gt;, '__call__': &lt;function FlowTrainCallable.__call__&gt;, 'fork': &lt;function FlowTrainCallable.fork&gt;})</em><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>flownode</em>, <em>purge_nodes=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Store everything for the training.</p>
<p>keyword arguments:
flownode – FlowNode containing the flow to be trained.
purge_nodes – If True nodes not needed for the join will be replaced</p>
<blockquote>
<div>with dummy nodes to reduce the footprint.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowTrainCallable.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fork of this callable, e.g. by making a copy.</p>
<p>This method is always called exactly once before a callable is called,
so instead of the original callable a fresh fork is called. This
ensures that the original callable is preserved when caching is used.
If the callable is not modified by the call then it can simply return
itself.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowTrainCallable.setup_environment">
<code class="descname">setup_environment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowTrainCallable.setup_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate the used extensions.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.FlowExecuteCallable">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">FlowExecuteCallable</code><span class="sig-paren">(</span><em>flownode</em>, <em>nodenr=None</em>, <em>purge_nodes=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.FlowTaskCallable" title="mdp.parallel.FlowTaskCallable"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.FlowTaskCallable</span></code></a></p>
<p>Implements data execution through a Flow.</p>
<p>A FlowNode is used to simplify the forking process and to
encapsulate the flow.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the execution result.</p>
<p>x – data chunk</p>
<p>If use_fork_execute is True for the flownode then it is returned
in the result tuple.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Implements data execution through a Flow.\n    \n    A FlowNode is used to simplify the forking process and to\n    encapsulate the flow.\n    ', '__init__': &lt;function FlowExecuteCallable.__init__&gt;, '__call__': &lt;function FlowExecuteCallable.__call__&gt;, 'fork': &lt;function FlowExecuteCallable.fork&gt;})</em><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>flownode</em>, <em>nodenr=None</em>, <em>purge_nodes=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Store everything for the execution.</p>
<p>flownode – FlowNode for the execution
nodenr – optional nodenr argument for the flow execute method
purge_nodes – If True nodes not needed for the join will be replaced</p>
<blockquote>
<div>with dummy nodes to reduce the footprint.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.FlowExecuteCallable.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fork of this callable, e.g. by making a copy.</p>
<p>This method is always called exactly once before a callable is called,
so instead of the original callable a fresh fork is called. This
ensures that the original callable is preserved when caching is used.
If the callable is not modified by the call then it can simply return
itself.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.FlowExecuteCallable.setup_environment">
<code class="descname">setup_environment</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.FlowExecuteCallable.setup_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate the used extensions.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ExecuteResultContainer">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ExecuteResultContainer</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.OrderedResultContainer" title="mdp.parallel.OrderedResultContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.OrderedResultContainer</span></code></a></p>
<p>Default result container with automatic restoring of the result order.</p>
<p>This result container should be used together with BiFlowExecuteCallable.
Both the execute result (x and possibly msg) and the forked BiFlowNode
are stored.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Default result container with automatic restoring of the result order.\n\n    This result container should be used together with BiFlowExecuteCallable.\n    Both the execute result (x and possibly msg) and the forked BiFlowNode\n    are stored.\n    ', '__init__': &lt;function ExecuteResultContainer.__init__&gt;, 'add_result': &lt;function ExecuteResultContainer.add_result&gt;, 'get_results': &lt;function ExecuteResultContainer.get_results&gt;})</em><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize attributes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ExecuteResultContainer.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>result</em>, <em>task_index</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the forked BiFlowNode from the result and join it.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ExecuteResultContainer.get_results">
<code class="descname">get_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ExecuteResultContainer.get_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ordered results.</p>
<p>The joined BiFlowNode is returned in the first result list entry,
for the following result entries BiFlowNode is set to None.
This reduces memory consumption while staying transparent for the
ParallelBiFlow.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.TrainResultContainer">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">TrainResultContainer</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.ResultContainer" title="mdp.parallel.ResultContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ResultContainer</span></code></a></p>
<p>Container for parallel nodes.</p>
<p>Expects flownodes as results and joins them to save memory.
A list containing one flownode is returned, so this container can replace
the standard list container without any changes elsewhere.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Container for parallel nodes.\n\n    Expects flownodes as results and joins them to save memory.\n    A list containing one flownode is returned, so this container can replace\n    the standard list container without any changes elsewhere.\n    ', '__init__': &lt;function TrainResultContainer.__init__&gt;, 'add_result': &lt;function TrainResultContainer.add_result&gt;, 'get_results': &lt;function TrainResultContainer.get_results&gt;})</em><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.TrainResultContainer.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.TrainResultContainer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.add_result">
<code class="descname">add_result</code><span class="sig-paren">(</span><em>result</em>, <em>task_index</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a result in the container.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.TrainResultContainer.get_results">
<code class="descname">get_results</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.TrainResultContainer.get_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Return results and reset container.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="mdp.parallel.ParallelFlowException">
<em class="property">exception </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelFlowException</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.FlowException" title="mdp.FlowException"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.FlowException</span></code></a></p>
<p>Standard exception for problems with ParallelFlow.</p>
<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__cause__">
<code class="descname">__cause__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__context__">
<code class="descname">__context__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Standard exception for problems with ParallelFlow.'})</em><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowException.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowException.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowException.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowException.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowException.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowException.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowException.__setstate__">
<code class="descname">__setstate__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowException.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowException.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__suppress_context__">
<code class="descname">__suppress_context__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__traceback__">
<code class="descname">__traceback__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowException.args">
<code class="descname">args</code><a class="headerlink" href="#mdp.parallel.ParallelFlowException.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowException.with_traceback">
<code class="descname">with_traceback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowException.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="mdp.parallel.NoTaskException">
<em class="property">exception </em><code class="descclassname">mdp.parallel.</code><code class="descname">NoTaskException</code><a class="headerlink" href="#mdp.parallel.NoTaskException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.ParallelFlowException" title="mdp.parallel.ParallelFlowException"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ParallelFlowException</span></code></a></p>
<p>Exception for problems with the task creation.</p>
<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__cause__">
<code class="descname">__cause__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__cause__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception cause</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__context__">
<code class="descname">__context__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__context__" title="Permalink to this definition">¶</a></dt>
<dd><p>exception context</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Exception for problems with the task creation.'})</em><a class="headerlink" href="#mdp.parallel.NoTaskException.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.NoTaskException.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NoTaskException.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NoTaskException.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NoTaskException.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NoTaskException.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NoTaskException.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.NoTaskException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NoTaskException.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NoTaskException.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NoTaskException.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NoTaskException.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NoTaskException.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NoTaskException.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NoTaskException.__setstate__">
<code class="descname">__setstate__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NoTaskException.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.NoTaskException.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NoTaskException.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__str__">
<code class="descname">__str__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.NoTaskException.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NoTaskException.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__suppress_context__">
<code class="descname">__suppress_context__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__suppress_context__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__traceback__">
<code class="descname">__traceback__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__traceback__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.NoTaskException.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.NoTaskException.args">
<code class="descname">args</code><a class="headerlink" href="#mdp.parallel.NoTaskException.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.NoTaskException.with_traceback">
<code class="descname">with_traceback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.NoTaskException.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ParallelFlow">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelFlow</code><span class="sig-paren">(</span><em>flow</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.html#mdp.Flow" title="mdp.Flow"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.Flow</span></code></a></p>
<p>A parallel flow provides the methods for parallel training / execution.</p>
<p>Nodes in the flow which are not derived from ParallelNode are trained in
the normal way. The training is also done normally if fork() raises a
TrainingPhaseNotParallelException. This can be intentionally used by the
node to request local training without forking.
Parallel execution on the other hand should work for all nodes, since it
only relies on the copy method of nodes.
The stop_training method is always called locally, with no forking or
copying involved.</p>
<p>Both parallel training and execution can be done conveniently by providing
a scheduler instance to the train or execute method.
It is also possible to manage the tasks manually. This is done via the
methods setup_parallel_training (or execution), get_task and use_results.
The code of the train / execute method can serve as an example how to use
these methods and process the tasks by a scheduler.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>iterable</em>, <em>nodenr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance is equivalent to call its ‘execute’ method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__contains__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__delitem__">
<code class="descname">__delitem__</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__delitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'A parallel flow provides the methods for parallel training / execution.\n\n    Nodes in the flow which are not derived from ParallelNode are trained in\n    the normal way. The training is also done normally if fork() raises a\n    TrainingPhaseNotParallelException. This can be intentionally used by the\n    node to request local training without forking.\n    Parallel execution on the other hand should work for all nodes, since it\n    only relies on the copy method of nodes.\n    The stop_training method is always called locally, with no forking or\n    copying involved.\n\n    Both parallel training and execution can be done conveniently by providing\n    a scheduler instance to the train or execute method.\n    It is also possible to manage the tasks manually. This is done via the\n    methods setup_parallel_training (or execution), get_task and use_results.\n    The code of the train / execute method can serve as an example how to use\n    these methods and process the tasks by a scheduler.\n    ', '__init__': &lt;function ParallelFlow.__init__&gt;, 'train': &lt;function &lt;lambda&gt;&gt;, 'setup_parallel_training': &lt;function ParallelFlow.setup_parallel_training&gt;, '_next_train_phase': &lt;function ParallelFlow._next_train_phase&gt;, '_local_train_phase': &lt;function ParallelFlow._local_train_phase&gt;, '_post_stop_training_hook': &lt;function ParallelFlow._post_stop_training_hook&gt;, '_create_train_task': &lt;function ParallelFlow._create_train_task&gt;, 'execute': &lt;function &lt;lambda&gt;&gt;, 'setup_parallel_execution': &lt;function ParallelFlow.setup_parallel_execution&gt;, '_create_execute_task': &lt;function ParallelFlow._create_execute_task&gt;, 'get_task': &lt;function ParallelFlow.get_task&gt;, 'is_parallel_training': &lt;property object&gt;, 'is_parallel_executing': &lt;property object&gt;, 'task_available': &lt;property object&gt;, 'use_results': &lt;function ParallelFlow.use_results&gt;})</em><a class="headerlink" href="#mdp.parallel.ParallelFlow.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__iadd__">
<code class="descname">__iadd__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__iadd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>flow</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the internal variables.</p>
<p>Note that the crash_recovery flag is is not supported, so it is
disabled.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__iter__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelFlow.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__setitem__">
<code class="descname">__setitem__</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._check_dimension_consistency">
<code class="descname">_check_dimension_consistency</code><span class="sig-paren">(</span><em>out</em>, <em>inp</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._check_dimension_consistency" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise ValueError when both dimensions are set and different.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._check_nodes_consistency">
<code class="descname">_check_nodes_consistency</code><span class="sig-paren">(</span><em>flow=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._check_nodes_consistency" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the dimension consistency of a list of nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._check_value_type_isnode">
<code class="descname">_check_value_type_isnode</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._check_value_type_isnode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._close_last_node">
<code class="descname">_close_last_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._close_last_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._create_execute_task">
<code class="descname">_create_execute_task</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelflows.html#ParallelFlow._create_execute_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelFlow._create_execute_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a single execution task.</p>
<p>Returns None if data iterator end is reached.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._create_train_task">
<code class="descname">_create_train_task</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelflows.html#ParallelFlow._create_train_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelFlow._create_train_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a single training task without callable.</p>
<p>Returns None if data iterator end is reached.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._execute_seq">
<code class="descname">_execute_seq</code><span class="sig-paren">(</span><em>x</em>, <em>nodenr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._execute_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelFlow._get_required_train_args">
<em class="property">static </em><code class="descname">_get_required_train_args</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._get_required_train_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Return arguments in addition to self and x for node.train.</p>
<p>Argumentes that have a default value are ignored.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._inverse_seq">
<code class="descname">_inverse_seq</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._inverse_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._local_train_phase">
<code class="descname">_local_train_phase</code><span class="sig-paren">(</span><em>data_iterable</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelflows.html#ParallelFlow._local_train_phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelFlow._local_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single training phase locally.</p>
<p>The internal _train_callable_class is used for the training.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._next_train_phase">
<code class="descname">_next_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelflows.html#ParallelFlow._next_train_phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelFlow._next_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the next phase or node for parallel training.</p>
<p>When it is found the corresponding internal variables are set.
Nodes which are not derived from ParallelNode are trained locally.
If a fork() fails due to a TrainingPhaseNotParallelException
in a certain train phase, then the training is done locally as well
(but fork() is tested again for the next phase).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._post_stop_training_hook">
<code class="descname">_post_stop_training_hook</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelflows.html#ParallelFlow._post_stop_training_hook"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelFlow._post_stop_training_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method that is called after stop_training is called.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._propagate_exception">
<code class="descname">_propagate_exception</code><span class="sig-paren">(</span><em>except_</em>, <em>nodenr</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._propagate_exception" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._stop_training_hook">
<code class="descname">_stop_training_hook</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._stop_training_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method that is called before stop_training is called.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._train_check_iterables">
<code class="descname">_train_check_iterables</code><span class="sig-paren">(</span><em>data_iterables</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._train_check_iterables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the data iterables after some checks and sanitizing.</p>
<p>Note that this method does not distinguish between iterables and
iterators, so this must be taken care of later.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow._train_node">
<code class="descname">_train_node</code><span class="sig-paren">(</span><em>data_iterable</em>, <em>nodenr</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow._train_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a single node in the flow.</p>
<p>nodenr – index of the node in the flow</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.append" title="Permalink to this definition">¶</a></dt>
<dd><p>flow.append(node) – append node to flow end</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the flow.</p>
<p>The protocol parameter should not be used.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>iterable</em>, <em>nodenr=None</em>, <em>scheduler=None</em>, <em>execute_callable_class=None</em>, <em>overwrite_result_container=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Train all trainable nodes in the flow.</p>
<p>If a scheduler is provided the execution will be done in parallel on
the scheduler.</p>
<dl class="docutils">
<dt>iterable – An iterable or iterator that returns data arrays that are</dt>
<dd>used as input to the flow. Alternatively, one can specify one
data array as input.
If a custom execute_callable_class is used to preprocess the data
then other data types can be used as well.</dd>
<dt>nodenr – Same as in normal flow, the flow is only executed up to the</dt>
<dd>nodenr.</dd>
<dt>scheduler – Value can be either None for normal execution (default</dt>
<dd>value) or a Scheduler instance for parallel execution with the
scheduler.</dd>
<dt>execute_callable_class – Class used to create execution callables for</dt>
<dd>the scheduler. By specifying your own class you can implement data
transformations before the data is actually fed into the flow
(e.g. from 8 bit image to 64 bit double precision).
Note that the execute_callable_class is only used if a scheduler was
provided. If a scheduler is provided the default class used is
NodeResultContainer.</dd>
<dt>overwrite_result_container – If set to True (default value) then</dt>
<dd>the result container in the scheduler will be overwritten with an
instance of OrderedResultContainer (unless it is already an
instance of OrderedResultContainer). Otherwise the results might
have a different order than the data chunks, which could mess up
any subsequent analysis.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>flow.extend(iterable) – extend flow by appending
elements from the iterable</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.get_task">
<code class="descname">get_task</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.get_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a task either for either training or execution.</p>
<p>A a one task buffer is used to make task_available work.
tasks are available as long as need_result returns False or all the
training / execution is done. If no tasks are available a
NoTaskException is raised.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>i</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>flow.insert(index, node) – insert node before index</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data through all nodes in the flow backwards
(starting from the last node up to the first node) by calling the
inverse function of each node. Of course, all nodes in the
flow must be invertible.</p>
<p>‘iterable’ is an iterable or iterator  (note that a list is also an
iterable), which returns data arrays that are used as input to the flow.
Alternatively, one can specify one data array as input.</p>
<p>Note that this is _not_ equivalent to ‘flow[::-1](iterable)’,
which also executes the flow backwards but calls the ‘execute’
function of each node.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.is_parallel_executing">
<code class="descname">is_parallel_executing</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.is_parallel_executing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if parallel execution is underway.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.is_parallel_training">
<code class="descname">is_parallel_training</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.is_parallel_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if parallel training is underway.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="optional">[</span><em>index</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; node -- remove and return node at index<a class="headerlink" href="#mdp.parallel.ParallelFlow.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>(default last)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the flow to ‘filename’.
If ‘filename’ is None, return a string.</p>
<p>Note: the pickled Flow is not guaranteed to be upward or
backward compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.set_crash_recovery">
<code class="descname">set_crash_recovery</code><span class="sig-paren">(</span><em>state=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.set_crash_recovery" title="Permalink to this definition">¶</a></dt>
<dd><p>Set crash recovery capabilities.</p>
<p>When a node raises an Exception during training, execution, or
inverse execution that the flow is unable to handle, a FlowExceptionCR
is raised. If crash recovery is set, a crash dump of the flow
instance is saved for later inspection. The original exception
can be found as the ‘parent_exception’ attribute of the
FlowExceptionCR instance.</p>
<ul class="simple">
<li>If ‘state’ = False, disable crash recovery.</li>
<li>If ‘state’ is a string, the crash dump is saved on a file
with that name.</li>
<li>If ‘state’ = True, the crash dump is saved on a file created by
the tempfile module.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.setup_parallel_execution">
<code class="descname">setup_parallel_execution</code><span class="sig-paren">(</span><em>iterable</em>, <em>nodenr=None</em>, <em>execute_callable_class=&lt;class 'mdp.parallel.FlowExecuteCallable'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.setup_parallel_execution" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare the flow for handing out tasks to do the execution.</p>
<p>After calling setup_parallel_execution one has to pick up the
tasks with get_task, run them and finally return the results via
use_results. use_results will then return the result as if the flow was
executed in the normal way.</p>
<dl class="docutils">
<dt>iterable – An iterable or iterator that returns data arrays that are</dt>
<dd>used as input to the flow. Alternatively, one can specify one
data array as input.
If a custom execute_callable_class is used to preprocess the data
then other data types can be used as well.</dd>
<dt>nodenr – Same as in normal flow, the flow is only executed up to the</dt>
<dd>nodenr.</dd>
<dt>execute_callable_class – Class used to create execution callables for</dt>
<dd>the scheduler. By specifying your own class you can implement data
transformations before the data is actually fed into the flow
(e.g. from 8 bit image to 64 bit double precision).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.setup_parallel_training">
<code class="descname">setup_parallel_training</code><span class="sig-paren">(</span><em>data_iterables</em>, <em>train_callable_class=&lt;class 'mdp.parallel.FlowTrainCallable'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.setup_parallel_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare the flow for handing out tasks to do the training.</p>
<p>After calling setup_parallel_training one has to pick up the
tasks with get_task, run them and finally return the results via
use_results. tasks are available as long as task_available returns
True. Training may require multiple phases, which are each closed by
calling use_results.</p>
<dl class="docutils">
<dt>data_iterables – A list of iterables, one for each node in the flow.</dt>
<dd>The iterators returned by the iterables must
return data arrays that are then used for the node training.
See Flow.train for more details.
If a custom train_callable_class is used to preprocess the data
then other data types can be used as well.</dd>
<dt>train_callable_class – Class used to create training callables for the</dt>
<dd>scheduler. By specifying your own class you can implement data
transformations before the data is actually fed into the flow
(e.g. from 8 bit image to 64 bit double precision).</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlow.task_available">
<code class="descname">task_available</code><a class="headerlink" href="#mdp.parallel.ParallelFlow.task_available" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if tasks are available, otherwise False.</p>
<p>If False is returned this can indicate that results are needed to
continue training.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>data_iterables</em>, <em>scheduler=None</em>, <em>train_callable_class=None</em>, <em>overwrite_result_container=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train all trainable nodes in the flow.</p>
<p>If a scheduler is provided the training will be done in parallel on the
scheduler.</p>
<dl class="docutils">
<dt>data_iterables – A list of iterables, one for each node in the flow.</dt>
<dd>The iterators returned by the iterables must
return data arrays that are then used for the node training.
See Flow.train for more details.
If a custom train_callable_class is used to preprocess the data
then other data types can be used as well.</dd>
<dt>scheduler – Value can be either None for normal training (default</dt>
<dd>value) or a Scheduler instance for parallel training with the
scheduler.
If the scheduler value is an iterable or iterator then it is
assumed that it contains a scheduler for each training phase.
After a node has been trained the scheduler is shutdown. Note that
you can e.g. use a generator to create the schedulers just in time.
For nodes which are not trained the scheduler can be None.</dd>
<dt>train_callable_class – Class used to create training callables for the</dt>
<dd>scheduler. By specifying your own class you can implement data
transformations before the data is actually fed into the flow
(e.g. from 8 bit image to 64 bit double precision).
Note that the train_callable_class is only used if a scheduler was
provided. By default NodeResultContainer is used.</dd>
<dt>overwrite_result_container – If set to True (default value) then</dt>
<dd>the result container in the scheduler will be overwritten with an
instance of NodeResultContainer (unless it is already an instance
of NodeResultContainer). This improves the memory efficiency.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlow.use_results">
<code class="descname">use_results</code><span class="sig-paren">(</span><em>results</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlow.use_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the result from the scheduler.</p>
<p>During parallel training this will start the next training phase.
For parallel execution this will return the result, like a normal
execute would.</p>
<dl class="docutils">
<dt>results – Iterable containing the results, normally the return value</dt>
<dd>of scheduler.ResultContainer.get_results().
The individual results can be the return values of the tasks.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ParallelCheckpointFlow">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelCheckpointFlow</code><span class="sig-paren">(</span><em>flow</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#mdp.parallel.ParallelFlow" title="mdp.parallel.ParallelFlow"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ParallelFlow</span></code></a>, <a class="reference internal" href="mdp.html#mdp.CheckpointFlow" title="mdp.CheckpointFlow"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.CheckpointFlow</span></code></a></p>
<p>Parallel version of CheckpointFlow.</p>
<p>Note that train phases are always closed, so e.g. CheckpointSaveFunction
should not expect open train phases. This is necessary since otherwise
stop_training() would be called remotely.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>iterable</em>, <em>nodenr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance is equivalent to call its ‘execute’ method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__contains__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__delitem__">
<code class="descname">__delitem__</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__delitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Parallel version of CheckpointFlow.\n\n    Note that train phases are always closed, so e.g. CheckpointSaveFunction\n    should not expect open train phases. This is necessary since otherwise\n    stop_training() would be called remotely.\n    ', '__init__': &lt;function ParallelCheckpointFlow.__init__&gt;, 'train': &lt;function ParallelCheckpointFlow.train&gt;, 'setup_parallel_training': &lt;function ParallelCheckpointFlow.setup_parallel_training&gt;, '_post_stop_training_hook': &lt;function ParallelCheckpointFlow._post_stop_training_hook&gt;})</em><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__iadd__">
<code class="descname">__iadd__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__iadd__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>flow</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the internal variables.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__iter__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__setitem__">
<code class="descname">__setitem__</code><span class="sig-paren">(</span><em>key</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._check_dimension_consistency">
<code class="descname">_check_dimension_consistency</code><span class="sig-paren">(</span><em>out</em>, <em>inp</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._check_dimension_consistency" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise ValueError when both dimensions are set and different.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._check_nodes_consistency">
<code class="descname">_check_nodes_consistency</code><span class="sig-paren">(</span><em>flow=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._check_nodes_consistency" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the dimension consistency of a list of nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._check_value_type_isnode">
<code class="descname">_check_value_type_isnode</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._check_value_type_isnode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._close_last_node">
<code class="descname">_close_last_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._close_last_node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._create_execute_task">
<code class="descname">_create_execute_task</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._create_execute_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a single execution task.</p>
<p>Returns None if data iterator end is reached.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._create_train_task">
<code class="descname">_create_train_task</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._create_train_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a single training task without callable.</p>
<p>Returns None if data iterator end is reached.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._execute_seq">
<code class="descname">_execute_seq</code><span class="sig-paren">(</span><em>x</em>, <em>nodenr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._execute_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelCheckpointFlow._get_required_train_args">
<em class="property">static </em><code class="descname">_get_required_train_args</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._get_required_train_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Return arguments in addition to self and x for node.train.</p>
<p>Argumentes that have a default value are ignored.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._inverse_seq">
<code class="descname">_inverse_seq</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._inverse_seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._local_train_phase">
<code class="descname">_local_train_phase</code><span class="sig-paren">(</span><em>data_iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._local_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single training phase locally.</p>
<p>The internal _train_callable_class is used for the training.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._next_train_phase">
<code class="descname">_next_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._next_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the next phase or node for parallel training.</p>
<p>When it is found the corresponding internal variables are set.
Nodes which are not derived from ParallelNode are trained locally.
If a fork() fails due to a TrainingPhaseNotParallelException
in a certain train phase, then the training is done locally as well
(but fork() is tested again for the next phase).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._post_stop_training_hook">
<code class="descname">_post_stop_training_hook</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelflows.html#ParallelCheckpointFlow._post_stop_training_hook"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._post_stop_training_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if we reached a checkpoint.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._propagate_exception">
<code class="descname">_propagate_exception</code><span class="sig-paren">(</span><em>except_</em>, <em>nodenr</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._propagate_exception" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._stop_training_hook">
<code class="descname">_stop_training_hook</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._stop_training_hook" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook method that is called before stop_training is called.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._train_check_checkpoints">
<code class="descname">_train_check_checkpoints</code><span class="sig-paren">(</span><em>checkpoints</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._train_check_checkpoints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._train_check_iterables">
<code class="descname">_train_check_iterables</code><span class="sig-paren">(</span><em>data_iterables</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._train_check_iterables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the data iterables after some checks and sanitizing.</p>
<p>Note that this method does not distinguish between iterables and
iterators, so this must be taken care of later.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow._train_node">
<code class="descname">_train_node</code><span class="sig-paren">(</span><em>data_iterable</em>, <em>nodenr</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow._train_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a single node in the flow.</p>
<p>nodenr – index of the node in the flow</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.append" title="Permalink to this definition">¶</a></dt>
<dd><p>flow.append(node) – append node to flow end</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the flow.</p>
<p>The protocol parameter should not be used.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>iterable</em>, <em>nodenr=None</em>, <em>scheduler=None</em>, <em>execute_callable_class=None</em>, <em>overwrite_result_container=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Train all trainable nodes in the flow.</p>
<p>If a scheduler is provided the execution will be done in parallel on
the scheduler.</p>
<dl class="docutils">
<dt>iterable – An iterable or iterator that returns data arrays that are</dt>
<dd>used as input to the flow. Alternatively, one can specify one
data array as input.
If a custom execute_callable_class is used to preprocess the data
then other data types can be used as well.</dd>
<dt>nodenr – Same as in normal flow, the flow is only executed up to the</dt>
<dd>nodenr.</dd>
<dt>scheduler – Value can be either None for normal execution (default</dt>
<dd>value) or a Scheduler instance for parallel execution with the
scheduler.</dd>
<dt>execute_callable_class – Class used to create execution callables for</dt>
<dd>the scheduler. By specifying your own class you can implement data
transformations before the data is actually fed into the flow
(e.g. from 8 bit image to 64 bit double precision).
Note that the execute_callable_class is only used if a scheduler was
provided. If a scheduler is provided the default class used is
NodeResultContainer.</dd>
<dt>overwrite_result_container – If set to True (default value) then</dt>
<dd>the result container in the scheduler will be overwritten with an
instance of OrderedResultContainer (unless it is already an
instance of OrderedResultContainer). Otherwise the results might
have a different order than the data chunks, which could mess up
any subsequent analysis.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>flow.extend(iterable) – extend flow by appending
elements from the iterable</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.get_task">
<code class="descname">get_task</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.get_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a task either for either training or execution.</p>
<p>A a one task buffer is used to make task_available work.
tasks are available as long as need_result returns False or all the
training / execution is done. If no tasks are available a
NoTaskException is raised.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>i</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>flow.insert(index, node) – insert node before index</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>iterable</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data through all nodes in the flow backwards
(starting from the last node up to the first node) by calling the
inverse function of each node. Of course, all nodes in the
flow must be invertible.</p>
<p>‘iterable’ is an iterable or iterator  (note that a list is also an
iterable), which returns data arrays that are used as input to the flow.
Alternatively, one can specify one data array as input.</p>
<p>Note that this is _not_ equivalent to ‘flow[::-1](iterable)’,
which also executes the flow backwards but calls the ‘execute’
function of each node.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.is_parallel_executing">
<code class="descname">is_parallel_executing</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.is_parallel_executing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if parallel execution is underway.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.is_parallel_training">
<code class="descname">is_parallel_training</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.is_parallel_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if parallel training is underway.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="optional">[</span><em>index</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; node -- remove and return node at index<a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>(default last)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the flow to ‘filename’.
If ‘filename’ is None, return a string.</p>
<p>Note: the pickled Flow is not guaranteed to be upward or
backward compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.set_crash_recovery">
<code class="descname">set_crash_recovery</code><span class="sig-paren">(</span><em>state=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.set_crash_recovery" title="Permalink to this definition">¶</a></dt>
<dd><p>Set crash recovery capabilities.</p>
<p>When a node raises an Exception during training, execution, or
inverse execution that the flow is unable to handle, a FlowExceptionCR
is raised. If crash recovery is set, a crash dump of the flow
instance is saved for later inspection. The original exception
can be found as the ‘parent_exception’ attribute of the
FlowExceptionCR instance.</p>
<ul class="simple">
<li>If ‘state’ = False, disable crash recovery.</li>
<li>If ‘state’ is a string, the crash dump is saved on a file
with that name.</li>
<li>If ‘state’ = True, the crash dump is saved on a file created by
the tempfile module.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.setup_parallel_execution">
<code class="descname">setup_parallel_execution</code><span class="sig-paren">(</span><em>iterable</em>, <em>nodenr=None</em>, <em>execute_callable_class=&lt;class 'mdp.parallel.FlowExecuteCallable'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.setup_parallel_execution" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare the flow for handing out tasks to do the execution.</p>
<p>After calling setup_parallel_execution one has to pick up the
tasks with get_task, run them and finally return the results via
use_results. use_results will then return the result as if the flow was
executed in the normal way.</p>
<dl class="docutils">
<dt>iterable – An iterable or iterator that returns data arrays that are</dt>
<dd>used as input to the flow. Alternatively, one can specify one
data array as input.
If a custom execute_callable_class is used to preprocess the data
then other data types can be used as well.</dd>
<dt>nodenr – Same as in normal flow, the flow is only executed up to the</dt>
<dd>nodenr.</dd>
<dt>execute_callable_class – Class used to create execution callables for</dt>
<dd>the scheduler. By specifying your own class you can implement data
transformations before the data is actually fed into the flow
(e.g. from 8 bit image to 64 bit double precision).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.setup_parallel_training">
<code class="descname">setup_parallel_training</code><span class="sig-paren">(</span><em>data_iterables</em>, <em>checkpoints</em>, <em>train_callable_class=&lt;class 'mdp.parallel.FlowTrainCallable'&gt;</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.setup_parallel_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Checkpoint version of parallel training.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCheckpointFlow.task_available">
<code class="descname">task_available</code><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.task_available" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if tasks are available, otherwise False.</p>
<p>If False is returned this can indicate that results are needed to
continue training.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>data_iterables</em>, <em>checkpoints</em>, <em>scheduler=None</em>, <em>train_callable_class=&lt;class 'mdp.parallel.FlowTrainCallable'&gt;</em>, <em>overwrite_result_container=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train all trainable nodes in the flow.</p>
<p>Same as the train method in ParallelFlow, but with additional support
of checkpoint functions as in CheckpointFlow.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCheckpointFlow.use_results">
<code class="descname">use_results</code><span class="sig-paren">(</span><em>results</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCheckpointFlow.use_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the result from the scheduler.</p>
<p>During parallel training this will start the next training phase.
For parallel execution this will return the result, like a normal
execute would.</p>
<dl class="docutils">
<dt>results – Iterable containing the results, normally the return value</dt>
<dd>of scheduler.ResultContainer.get_results().
The individual results can be the return values of the tasks.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ParallelFlowNode">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelFlowNode</code><span class="sig-paren">(</span><em>flow</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.hinet.html#mdp.hinet.FlowNode" title="mdp.hinet.FlowNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.hinet.FlowNode</span></code></a>, <a class="reference internal" href="#mdp.parallel.ParallelExtensionNode" title="mdp.parallel.ParallelExtensionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ParallelExtensionNode</span></code></a></p>
<p>Parallel version of FlowNode.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="mdp.html#mdp.ExtensionNodeMetaclass" title="mdp.ExtensionNodeMetaclass"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ExtensionNodeMetaclass</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__contains__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Parallel version of FlowNode.', '_fork': &lt;function ParallelFlowNode._fork&gt;, '_join': &lt;function ParallelFlowNode._join&gt;, 'use_execute_fork': &lt;function ParallelFlowNode.use_execute_fork&gt;})</em><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>flow</em>, <em>input_dim=None</em>, <em>output_dim=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap the given flow into this node.</p>
<p>Pretrained nodes are allowed, but the internal flow should not
be modified after the FlowNode was created (this will cause problems
if the training phase structure of the internal nodes changes).</p>
<p>If the node dimensions and dtype are not specified, they will be
extracted from the internal nodes (late dimension setting is also
supported).</p>
<p>flow can have crash recovery enabled, but there is no special support
for it.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__iter__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._default_fork">
<code class="descname">_default_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._default_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation of _fork.</p>
<p>It uses introspection to determine the init kwargs and tries to fill
them with attributes. These kwargs are then used to instanciate
self.__class__ to create the fork instance.</p>
<p>So you can use this method if all the required keys are also public
attributes or have a single underscore in front.</p>
<p>There are two reasons why this method does not simply replace _fork
of ParallelExtensionNode (plus removing Node from the
inheritance list):
- If a node is not parallelized _fork raises an exception, as do nodes</p>
<blockquote>
<div>which can not fork due to some other reasons. Without this bahavior
of _fork we would have to check with hasattr first if fork is
present, adding more complexity at other places (mostly in
container nodes).</div></blockquote>
<ul class="simple">
<li><dl class="first docutils">
<dt>This is a safeguard forcing users to think a little instead of</dt>
<dd>relying on the inherited (but possibly incompatible)
default implementation.</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._fix_nodes_dimensions">
<code class="descname">_fix_nodes_dimensions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._fix_nodes_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to fix the dimensions of the internal nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._fork">
<code class="descname">_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelhinet.html#ParallelFlowNode._fork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Fork nodes that require it, reference all other nodes.</p>
<p>If a required fork() fails the exception is not caught here.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id21"><span class="problematic" id="id22">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a training sequence containing all training phases.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelhinet.html#ParallelFlowNode._join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join the required nodes from the forked node into this FlowNode.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelFlowNode._join_covariance">
<em class="property">static </em><code class="descname">_join_covariance</code><span class="sig-paren">(</span><em>cov</em>, <em>forked_cov</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._join_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to join two CovarianceMatrix instances.</p>
<dl class="docutils">
<dt>cov – Instance of CovarianceMatrix, to which the forked_cov instance</dt>
<dd>is aded in-place.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-execution checks.</p>
<p>It can be used when a subclass defines multiple execution methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this node.</p>
<p>The copy call is delegated to the internal node, which allows the use
of custom copy methods for special nodes.</p>
<p>The protocol parameter should not be used.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data contained in <cite>x</cite>.</p>
<p>If the object is still in the training phase, the function
<cite>stop_training</cite> will be called.
<cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_execute</cite> to implement
their execution phase. The docstring of the <cite>_execute</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.extension_name">
<code class="descname">extension_name</code><em class="property"> = 'parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.extension_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.flow">
<code class="descname">flow</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Read-only internal flow property.</p>
<p>In general the internal flow should not be modified (see __init__
for more details).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of this node class for remote training.</p>
<p>This is a template method, the actual forking should be implemented in
_fork.</p>
<p>The forked node should be a ParallelNode of the same class as well,
thus allowing recursive forking and joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id23"><span class="problematic" id="id24">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert <cite>y</cite>.</p>
<p>If the node is invertible, compute the input <code class="docutils literal notranslate"><span class="pre">x</span></code> such that
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">execute(x)</span></code>.</p>
<p>By default, subclasses should overwrite <cite>_inverse</cite> to implement
their <cite>inverse</cite> function. The docstring of the <cite>inverse</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.is_invertible">
<code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.is_trainable">
<code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Absorb the trained node from a fork into this parent node.</p>
<p>This is a template method, the actual joining should be implemented in
_join.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the training phase.</p>
<p>By default, subclasses should overwrite <cite>_stop_training</cite> to implement
this functionality. The docstring of the <cite>_stop_training</cite> method
overwrites this docstring.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelFlowNode.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the internal structures according to the input data <cite>x</cite>.</p>
<p><cite>x</cite> is a matrix having different variables on different columns
and observations on the rows.</p>
<p>By default, subclasses should overwrite <cite>_train</cite> to implement their
training phase. The docstring of the <cite>_train</cite> method overwrites this
docstring.</p>
<p>Note: a subclass supporting multiple training phases should implement
the <em>same</em> signature for all the training phases and document the
meaning of the arguments in the <cite>_train</cite> method doc-string. Having
consistent signatures is a requirement to use the node in a flow.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelFlowNode.use_execute_fork">
<code class="descname">use_execute_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelFlowNode.use_execute_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if node requires a fork / join even during execution.</p>
<p>The default output is False, overwrite this method if required.</p>
<p>Note that the same fork and join methods are used as during training,
so the distinction must be implemented in the custom _fork and _join
methods.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ParallelLayer">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelLayer</code><span class="sig-paren">(</span><em>nodes</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.hinet.html#mdp.hinet.Layer" title="mdp.hinet.Layer"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.hinet.Layer</span></code></a>, <a class="reference internal" href="#mdp.parallel.ParallelExtensionNode" title="mdp.parallel.ParallelExtensionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ParallelExtensionNode</span></code></a></p>
<p>Parallel version of a Layer.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="mdp.html#mdp.ExtensionNodeMetaclass" title="mdp.ExtensionNodeMetaclass"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ExtensionNodeMetaclass</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__contains__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Parallel version of a Layer.', '_fork': &lt;function ParallelLayer._fork&gt;, '_join': &lt;function ParallelLayer._join&gt;, 'use_execute_fork': &lt;function ParallelLayer.use_execute_fork&gt;})</em><a class="headerlink" href="#mdp.parallel.ParallelLayer.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>nodes</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the layer with the given list of nodes.</p>
<p>The input and output dimensions for the nodes must be already set
(the output dimensions for simplicity reasons). The training phases for
the nodes are allowed to differ.</p>
<p>Keyword arguments:
nodes – List of the nodes to be used.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__iter__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelLayer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._check_props">
<code class="descname">_check_props</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._check_props" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the compatibility of the properties of the internal nodes.</p>
<p>Return the found dtype and check the dimensions.</p>
<p>dtype – The specified layer dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._default_fork">
<code class="descname">_default_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._default_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation of _fork.</p>
<p>It uses introspection to determine the init kwargs and tries to fill
them with attributes. These kwargs are then used to instanciate
self.__class__ to create the fork instance.</p>
<p>So you can use this method if all the required keys are also public
attributes or have a single underscore in front.</p>
<p>There are two reasons why this method does not simply replace _fork
of ParallelExtensionNode (plus removing Node from the
inheritance list):
- If a node is not parallelized _fork raises an exception, as do nodes</p>
<blockquote>
<div>which can not fork due to some other reasons. Without this bahavior
of _fork we would have to check with hasattr first if fork is
present, adding more complexity at other places (mostly in
container nodes).</div></blockquote>
<ul class="simple">
<li><dl class="first docutils">
<dt>This is a safeguard forcing users to think a little instead of</dt>
<dd>relying on the inherited (but possibly incompatible)
default implementation.</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data through the internal nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._fork">
<code class="descname">_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelhinet.html#ParallelLayer._fork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelLayer._fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Fork or copy all the nodes in the layer to fork the layer.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._get_output_dim_from_nodes">
<code class="descname">_get_output_dim_from_nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._get_output_dim_from_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the output_dim from the nodes and return it.</p>
<p>If the output_dim of a node is not set the None is returned.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id25"><span class="problematic" id="id26">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the train sequence.</p>
<p>The length is set by the node with maximum length.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the inverse of all the internal nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelhinet.html#ParallelLayer._join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelLayer._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join the trained nodes from the forked layer.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelLayer._join_covariance">
<em class="property">static </em><code class="descname">_join_covariance</code><span class="sig-paren">(</span><em>cov</em>, <em>forked_cov</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._join_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to join two CovarianceMatrix instances.</p>
<dl class="docutils">
<dt>cov – Instance of CovarianceMatrix, to which the forked_cov instance</dt>
<dd>is aded in-place.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure that output_dim is set and then perform normal checks.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop training of the internal nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform single training step by training the internal nodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.parallel.ParallelLayer._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data through the internal nodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.extension_name">
<code class="descname">extension_name</code><em class="property"> = 'parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelLayer.extension_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of this node class for remote training.</p>
<p>This is a template method, the actual forking should be implemented in
_fork.</p>
<p>The forked node should be a ParallelNode of the same class as well,
thus allowing recursive forking and joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id27"><span class="problematic" id="id28">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the inverse of all the internal nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.is_invertible">
<code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.is_trainable">
<code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Absorb the trained node from a fork into this parent node.</p>
<p>This is a template method, the actual joining should be implemented in
_join.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop training of the internal nodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelLayer.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.parallel.ParallelLayer.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform single training step by training the internal nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelLayer.use_execute_fork">
<code class="descname">use_execute_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelLayer.use_execute_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if node requires a fork / join even during execution.</p>
<p>The default output is False, overwrite this method if required.</p>
<p>Note that the same fork and join methods are used as during training,
so the distinction must be implemented in the custom _fork and _join
methods.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mdp.parallel.ParallelCloneLayer">
<em class="property">class </em><code class="descclassname">mdp.parallel.</code><code class="descname">ParallelCloneLayer</code><span class="sig-paren">(</span><em>node</em>, <em>n_nodes=1</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="mdp.hinet.html#mdp.hinet.CloneLayer" title="mdp.hinet.CloneLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.hinet.CloneLayer</span></code></a>, <a class="reference internal" href="#mdp.parallel.ParallelExtensionNode" title="mdp.parallel.ParallelExtensionNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.parallel.ParallelExtensionNode</span></code></a></p>
<p>Parallel version of CloneLayer class.</p>
<p><strong>Standart attributes:</strong></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><strong>Methods:</strong></p>
<p><em>Non-inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<p><em>Inherited</em></p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__add__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calling an instance of <cite>Node</cite> is equivalent to calling
its <cite>execute</cite> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="mdp.html#mdp.ExtensionNodeMetaclass" title="mdp.ExtensionNodeMetaclass"><code class="xref py py-class docutils literal notranslate"><span class="pre">mdp.ExtensionNodeMetaclass</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__contains__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'mdp.parallel', '__doc__': 'Parallel version of CloneLayer class.', '_fork': &lt;function ParallelCloneLayer._fork&gt;, '_join': &lt;function ParallelCloneLayer._join&gt;, 'use_execute_fork': &lt;function ParallelCloneLayer.use_execute_fork&gt;})</em><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default object formatter.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__hash__">
<code class="descname">__hash__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>node</em>, <em>n_nodes=1</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup the layer with the given list of nodes.</p>
<p>Keyword arguments:
node – Node to be cloned.
n_nodes – Number of repetitions/clones of the given node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__init_subclass__">
<code class="descname">__init_subclass__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__init_subclass__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a class is subclassed.</p>
<p>The default implementation does nothing. It may be
overridden to extend subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__iter__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__module__">
<code class="descname">__module__</code><em class="property"> = 'mdp.parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper for pickle.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of object in memory, in bytes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._check_input">
<code class="descname">_check_input</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._check_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._check_output">
<code class="descname">_check_output</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._check_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._check_props">
<code class="descname">_check_props</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._check_props" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the compatibility of the properties of the internal nodes.</p>
<p>Return the found dtype and check the dimensions.</p>
<p>dtype – The specified layer dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._check_train_args">
<code class="descname">_check_train_args</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._check_train_args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._default_fork">
<code class="descname">_default_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._default_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation of _fork.</p>
<p>It uses introspection to determine the init kwargs and tries to fill
them with attributes. These kwargs are then used to instanciate
self.__class__ to create the fork instance.</p>
<p>So you can use this method if all the required keys are also public
attributes or have a single underscore in front.</p>
<p>There are two reasons why this method does not simply replace _fork
of ParallelExtensionNode (plus removing Node from the
inheritance list):
- If a node is not parallelized _fork raises an exception, as do nodes</p>
<blockquote>
<div>which can not fork due to some other reasons. Without this bahavior
of _fork we would have to check with hasattr first if fork is
present, adding more complexity at other places (mostly in
container nodes).</div></blockquote>
<ul class="simple">
<li><dl class="first docutils">
<dt>This is a safeguard forcing users to think a little instead of</dt>
<dd>relying on the inherited (but possibly incompatible)
default implementation.</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._execute">
<code class="descname">_execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data through the internal nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._fork">
<code class="descname">_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelhinet.html#ParallelCloneLayer._fork"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Fork the internal node in the clone layer.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._get_output_dim_from_nodes">
<code class="descname">_get_output_dim_from_nodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._get_output_dim_from_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the output_dim from the nodes and return it.</p>
<p>If the output_dim of a node is not set the None is returned.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._get_supported_dtypes">
<code class="descname">_get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of dtypes supported by this node.</p>
<p>The types can be specified in any format allowed by <a href="#id29"><span class="problematic" id="id30">:numpy:`dtype`</span></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._get_train_seq">
<code class="descname">_get_train_seq</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._get_train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the train sequence.</p>
<p>The length is set by the node with maximum length.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._if_training_stop_training">
<code class="descname">_if_training_stop_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._if_training_stop_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._inverse">
<code class="descname">_inverse</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the inverse of all the internal nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._join">
<code class="descname">_join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/mdp/parallel/parallelhinet.html#ParallelCloneLayer._join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join the internal node in the clone layer.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="mdp.parallel.ParallelCloneLayer._join_covariance">
<em class="property">static </em><code class="descname">_join_covariance</code><span class="sig-paren">(</span><em>cov</em>, <em>forked_cov</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._join_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to join two CovarianceMatrix instances.</p>
<dl class="docutils">
<dt>cov – Instance of CovarianceMatrix, to which the forked_cov instance</dt>
<dd>is aded in-place.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._pre_execution_checks">
<code class="descname">_pre_execution_checks</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._pre_execution_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure that output_dim is set and then perform normal checks.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._pre_inversion_checks">
<code class="descname">_pre_inversion_checks</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._pre_inversion_checks" title="Permalink to this definition">¶</a></dt>
<dd><p>This method contains all pre-inversion checks.</p>
<p>It can be used when a subclass defines multiple inversion methods.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._refcast">
<code class="descname">_refcast</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._refcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to cast arrays to the internal dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._set_dtype">
<code class="descname">_set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._set_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._set_input_dim">
<code class="descname">_set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._set_output_dim">
<code class="descname">_set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._stop_training">
<code class="descname">_stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop training of the internal node.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer._train">
<code class="descname">_train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._train" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform single training step by training the internal nodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer._train_seq">
<code class="descname">_train_seq</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer._train_seq" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tuples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">training</span><span class="o">-</span><span class="n">phase1</span><span class="p">),</span>
 <span class="p">(</span><span class="n">training</span><span class="o">-</span><span class="n">phase2</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">-</span><span class="n">phase2</span><span class="p">),</span>
 <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>By default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_train_seq</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_train</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>protocol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>protocol</strong> – the pickle protocol (deprecated).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data through the internal nodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.extension_name">
<code class="descname">extension_name</code><em class="property"> = 'parallel'</em><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.extension_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.fork">
<code class="descname">fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new instance of this node class for remote training.</p>
<p>This is a template method, the actual forking should be implemented in
_fork.</p>
<p>The forked node should be a ParallelNode of the same class as well,
thus allowing recursive forking and joining.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.get_current_train_phase">
<code class="descname">get_current_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.get_current_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the current training phase.</p>
<p>The training phases are defined in the list <cite>self._train_seq</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.get_dtype">
<code class="descname">get_dtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.get_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtype.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.get_input_dim">
<code class="descname">get_input_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.get_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return input dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.get_output_dim">
<code class="descname">get_output_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.get_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return output dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.get_remaining_train_phase">
<code class="descname">get_remaining_train_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.get_remaining_train_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of training phases still to accomplish.</p>
<p>If the node is not trainable then return 0.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.get_supported_dtypes">
<code class="descname">get_supported_dtypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.get_supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dtypes supported by the node as a list of <a href="#id31"><span class="problematic" id="id32">:numpy:`dtype`</span></a>
objects.</p>
<p>Note that subclasses should overwrite <cite>self._get_supported_dtypes</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.has_multiple_training_phases">
<code class="descname">has_multiple_training_phases</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.has_multiple_training_phases" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node has multiple training phases.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Input dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the inverse of all the internal nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.is_invertible">
<code class="descname">is_invertible</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.is_invertible" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be inverted, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.is_trainable">
<code class="descname">is_trainable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.is_trainable" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node can be trained, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.is_training">
<code class="descname">is_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.is_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the node is in the training phase,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>forked_node</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Absorb the trained node from a fork into this parent node.</p>
<p>This is a template method, the actual joining should be implemented in
_join.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Output dimensions</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename</em>, <em>protocol=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a pickled serialization of the node to <cite>filename</cite>.
If <cite>filename</cite> is None, return a string.</p>
<p>Note: the pickled <cite>Node</cite> is not guaranteed to be forwards or
backwards compatible.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.set_dtype">
<code class="descname">set_dtype</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.set_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Set internal structures’ dtype.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_dtype(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._dtype</span></code>.
Note that subclasses should overwrite <cite>self._set_dtype</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.set_input_dim">
<code class="descname">set_input_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.set_input_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set input dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_input_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._input_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_input_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.set_output_dim">
<code class="descname">set_output_dim</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.set_output_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Set output dimensions.</p>
<p>Perform sanity checks and then calls <code class="docutils literal notranslate"><span class="pre">self._set_output_dim(n)</span></code>, which
is responsible for setting the internal attribute <code class="docutils literal notranslate"><span class="pre">self._output_dim</span></code>.
Note that subclasses should overwrite <cite>self._set_output_dim</cite>
when needed.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.stop_training">
<code class="descname">stop_training</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.stop_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop training of the internal node.</p>
</dd></dl>

<dl class="attribute">
<dt id="mdp.parallel.ParallelCloneLayer.supported_dtypes">
<code class="descname">supported_dtypes</code><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.supported_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported dtypes</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform single training step by training the internal nodes.</p>
</dd></dl>

<dl class="method">
<dt id="mdp.parallel.ParallelCloneLayer.use_execute_fork">
<code class="descname">use_execute_fork</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mdp.parallel.ParallelCloneLayer.use_execute_fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if node requires a fork / join even during execution.</p>
<p>The default output is False, overwrite this method if required.</p>
<p>Note that the same fork and join methods are used as during training,
so the distinction must be implemented in the custom _fork and _join
methods.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mdp.parallel.parallelclassifiers.html" class="btn btn-neutral float-right" title="mdp.parallel.parallelclassifiers module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mdp.nodes.xsfa_nodes.html" class="btn btn-neutral" title="mdp.nodes.xsfa_nodes module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      Last updated on 2020-02-17 1:33:02 PM Coordinated Universal Time.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'3.5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   
<div class="footer">
    <hr />
    <table>
      <tr>
        <td class="footer-left">
           <a href="http://sourceforge.net/projects/mdp-toolkit">
 <img src="http://sflogo.sourceforge.net/sflogo.php?group_id=116959&amp;type=12"
      width="120" height="30" border="0" alt="MDP@SF.NET"/> </a>
        </td>
        <td class="footer-center">
          Last updated on
             2020-02-17 1:33:02 PM Coordinated Universal Time
        </td>
        <td class="footer-right">
         <form class="search" action="../search.html" method="get">
          <input type="submit" value="Search" />
          <input type="text" name="q" size="18" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
         </form>
        </td>
    </table>  
    <!-- Piwik -->
    <script type="text/javascript">
	var pkBaseURL = (("https:" == document.location.protocol) ? "https://sourceforge.net/apps/piwik/mdp-toolkit/" : "http://sourceforge.net/apps/piwik/mdp-toolkit/");
	document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
	piwik_action_name = '';
	piwik_idsite = 1;
	piwik_url = pkBaseURL + "piwik.php";
	piwik_log(piwik_action_name, piwik_idsite, piwik_url);
    </script>
    <object><noscript>
	    <p>
		<img src="http://sourceforge.net/apps/piwik/mdp-toolkit/piwik.php?idsite=1"
		     alt="piwik" />
	    </p>
    </noscript></object>
    <!-- End Piwik Tag -->
</div>   


</body>
</html>