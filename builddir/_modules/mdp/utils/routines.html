

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mdp.utils.routines &mdash; Modular toolkit for Data Processing (MDP)</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="Modular toolkit for Data Processing (MDP)" href="../../../index.html"/>
        <link rel="up" title="mdp.utils" href="../utils.html"/> 
<meta name="viewport" content="width=740" />


  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/logo_animation.gif" class="logo" />
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../how_to_cite_mdp.html">How to cite MDP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MDP</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../mdp.html">mdp</a> &raquo;</li>
        
          <li><a href="../utils.html">mdp.utils</a> &raquo;</li>
        
      <li>mdp.utils.routines</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mdp.utils.routines</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">map</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">next</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">past.utils</span> <span class="k">import</span> <span class="n">old_div</span>
<span class="kn">import</span> <span class="nn">mdp</span>

<span class="c1"># import numeric module (scipy, Numeric or numarray)</span>
<span class="n">numx</span><span class="p">,</span> <span class="n">numx_rand</span><span class="p">,</span> <span class="n">numx_linalg</span>  <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx</span><span class="p">,</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx_rand</span><span class="p">,</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx_linalg</span>
<span class="n">numx_description</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx_description</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="k">def</span> <span class="nf">timediff</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the array of the time differences of data.&quot;&quot;&quot;</span>
    <span class="c1"># this is the fastest way we found so far</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">refcast</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cast the array to dtype only if necessary, otherwise return a reference.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">scast</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a scalar in a 0D array of the given dtype.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numx</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;radians&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate in-place data matrix (NxM) in the plane defined by the columns=[i,j]</span>
<span class="sd">    when observation are stored on rows. Observations are rotated</span>
<span class="sd">    counterclockwise. This corresponds to the following matrix-multiplication</span>
<span class="sd">    for each data-point (unchanged elements omitted):</span>

<span class="sd">     [  cos(angle) -sin(angle)     [ x_i ]</span>
<span class="sd">        sin(angle)  cos(angle) ] * [ x_j ]</span>

<span class="sd">    If M=2, columns=[0,1].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="s1">&#39;degrees&#39;</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">angle</span><span class="o">/</span><span class="mf">180.</span><span class="o">*</span><span class="n">numx</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">cos_</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">sin_</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">columns</span>
    <span class="n">col_i</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.</span>
    <span class="n">col_j</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
    <span class="n">mat</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos_</span><span class="o">*</span><span class="n">col_i</span> <span class="o">-</span> <span class="n">sin_</span><span class="o">*</span><span class="n">col_j</span>
    <span class="n">mat</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin_</span><span class="o">*</span><span class="n">col_i</span> <span class="o">+</span> <span class="n">cos_</span><span class="o">*</span><span class="n">col_j</span>

<span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">rows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Swap two columns and (or) two rows of &#39;x&#39;, whose indices are specified</span>
<span class="sd">    in indices=[i,j].</span>
<span class="sd">    Note: permutations are done in-place. You&#39;ll lose your original matrix&quot;&quot;&quot;</span>
    <span class="c1">## the nicer option:</span>
    <span class="c1">## x[i,:],x[j,:] = x[j,:],x[i,:]</span>
    <span class="c1">## does not work because array-slices are references.</span>
    <span class="c1">## The following would work:</span>
    <span class="c1">## x[i,:],x[j,:] = x[j,:].tolist(),x[i,:].tolist()</span>
    <span class="c1">## because list-slices are copies, but you get 2</span>
    <span class="c1">## copies instead of the one you need with our method.</span>
    <span class="c1">## This would also work:</span>
    <span class="c1">## tmp = x[i,:].copy()</span>
    <span class="c1">## x[i,:],x[j,:] = x[j,:],tmp</span>
    <span class="c1">## but it is slower (for larger matrices) than the one we use.</span>
    <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
    <span class="k">if</span> <span class="n">rows</span><span class="p">:</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">cols</span><span class="p">:</span>
        <span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">hermitian</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the Hermitian, i.e. conjugate transpose, of x.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">symrand</span><span class="p">(</span><span class="n">dim_or_eigv</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;d&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a random symmetric (Hermitian) matrix.</span>

<span class="sd">    If &#39;dim_or_eigv&#39; is an integer N, return a NxN matrix, with eigenvalues</span>
<span class="sd">        uniformly distributed on (-1,1).</span>

<span class="sd">    If &#39;dim_or_eigv&#39; is  1-D real array &#39;a&#39;, return a matrix whose</span>
<span class="sd">                      eigenvalues are &#39;a&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_or_eigv</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">dim_or_eigv</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">numx_rand</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_or_eigv</span><span class="p">,</span>
                    <span class="n">numx</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_or_eigv</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">dim_or_eigv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dim_or_eigv</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">mdp</span><span class="o">.</span><span class="n">MDPException</span><span class="p">(</span><span class="s2">&quot;input type not supported.&quot;</span><span class="p">)</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">random_rot</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="c1">#h = mdp.utils.mult(mdp.utils.mult(hermitian(v), mdp.numx.diag(d)), v)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mult</span><span class="p">(</span><span class="n">mult_diag</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">hermitian</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span>
    <span class="c1"># to avoid roundoff errors, symmetrize the matrix (again)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">h</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">):</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="n">symrand</span><span class="p">(</span><span class="n">dim_or_eigv</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">numx</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">h2</span><span class="p">)</span><span class="o">-</span><span class="n">numx</span><span class="o">.</span><span class="n">tril</span><span class="p">(</span><span class="n">h2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">refcast</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">random_rot</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a random rotation matrix, drawn from the Haar distribution</span>
<span class="sd">    (the only uniform distribution on SO(n)).</span>
<span class="sd">    The algorithm is described in the paper</span>
<span class="sd">    Stewart, G.W., &quot;The efficient generation of random orthogonal</span>
<span class="sd">    matrices with an application to condition estimators&quot;, SIAM Journal</span>
<span class="sd">    on Numerical Analysis, 17(3), pp. 403-409, 1980.</span>
<span class="sd">    For more information see</span>
<span class="sd">    http://en.wikipedia.org/wiki/Orthogonal_matrix#Randomization&quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">dim</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx_rand</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">dim</span><span class="o">-</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">mdp</span><span class="o">.</span><span class="n">numx</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="c1"># Householder transformation</span>
        <span class="n">Hx</span> <span class="o">=</span> <span class="p">(</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="o">-</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
               <span class="o">-</span> <span class="mf">2.</span><span class="o">*</span><span class="n">mdp</span><span class="o">.</span><span class="n">numx</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">numx</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Hx</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mult</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span>
    <span class="c1"># Fix the last sign such that the determinant is 1</span>
    <span class="n">D</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dim</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">D</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
    <span class="c1"># Equivalent to mult(numx.diag(D), H) but faster</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">H</span>

<span class="k">def</span> <span class="nf">norm2</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the 2-norm for 1D arrays.</span>
<span class="sd">    norm2(v) = sqrt(sum(v_i^2))&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">numx</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">v</span><span class="o">*</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">cov2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the covariance between 2D matrices x and y.</span>
<span class="sd">    Complies with the old scipy.cov function: different variables</span>
<span class="sd">    are on different columns.&quot;&quot;&quot;</span>

    <span class="n">mnx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mny</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">tlen</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">old_div</span><span class="p">(</span><span class="n">mdp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mult</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">),(</span><span class="n">tlen</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="n">numx</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">mnx</span><span class="p">,</span> <span class="n">mny</span><span class="p">)</span>

<div class="viewcode-block" id="cov_maxima"><a class="viewcode-back" href="../../../mdp/mdp.utils.routines.html#mdp.utils.routines.cov_maxima">[docs]</a><span class="k">def</span> <span class="nf">cov_maxima</span><span class="p">(</span><span class="n">cov</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract the maxima of a covariance matrix.&quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">maxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">cov</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
        <span class="n">glob_max_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">cov</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span><span class="o">//</span><span class="n">dim</span><span class="p">,</span> <span class="n">cov</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span><span class="o">%</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">maxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="n">glob_max_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">glob_max_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">cov_reduce</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cov_reduce</span> <span class="o">=</span> <span class="n">cov_reduce</span><span class="p">[</span><span class="n">numx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="n">glob_max_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">cov_reduce</span> <span class="o">=</span> <span class="n">cov_reduce</span><span class="p">[:,</span> <span class="n">numx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="n">glob_max_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">maxs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cov_maxima</span><span class="p">(</span><span class="n">cov_reduce</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">maxs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span></div>


<span class="k">def</span> <span class="nf">mult_diag</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mtx</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multiply a full matrix by a diagonal matrix.</span>
<span class="sd">    This function should always be faster than dot.</span>

<span class="sd">    Input:</span>
<span class="sd">      d -- 1D (N,) array (contains the diagonal elements)</span>
<span class="sd">      mtx -- 2D (N,N) array</span>

<span class="sd">    Output:</span>
<span class="sd">      mult_diag(d, mts, left=True) == dot(diag(d), mtx)</span>
<span class="sd">      mult_diag(d, mts, left=False) == dot(mtx, diag(d))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">left</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="n">mtx</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">*</span><span class="n">mtx</span>

<span class="k">def</span> <span class="nf">comb</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return number of combinations of k objects from a set of N objects</span>
<span class="sd">    without repetitions, a.k.a. the binomial coefficient of N and k.&quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">mlt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">*=</span> <span class="n">mlt</span>
    <span class="k">for</span> <span class="n">dv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">//=</span> <span class="n">dv</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="c1"># WARNING numpy.linalg.eigh does not support float sizes larger than 64 bits,</span>
<span class="c1"># and complex numbers of size larger than 128 bits.</span>
<span class="c1"># Also float16 is not supported either.</span>
<span class="c1"># This is not a problem for MDP, as long as scipy.linalg.eigh is available.</span>
<span class="k">def</span> <span class="nf">get_dtypes</span><span class="p">(</span><span class="n">typecodes_key</span><span class="p">,</span> <span class="n">_safe</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the list of dtypes corresponding to the set of</span>
<span class="sd">    typecodes defined in numpy.typecodes[typecodes_key].</span>
<span class="sd">    E.g., get_dtypes(&#39;Float&#39;) = [dtype(&#39;f&#39;), dtype(&#39;d&#39;), dtype(&#39;g&#39;)].</span>

<span class="sd">    If _safe is True (default), we remove large floating point types</span>
<span class="sd">    if the numerical backend does not support them.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">numx</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="n">typecodes_key</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_safe</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mdp</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">has_symeig</span> <span class="o">==</span> <span class="s1">&#39;scipy.linalg.eigh&#39;</span>
                <span class="ow">and</span> <span class="n">type_</span> <span class="ow">in</span> <span class="n">_UNSAFE_DTYPES</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="n">types</span>

<span class="n">_UNSAFE_DTYPES</span> <span class="o">=</span> <span class="p">[</span><span class="n">numx</span><span class="o">.</span><span class="n">typeDict</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span>
                  <span class="p">[</span><span class="s1">&#39;float16&#39;</span><span class="p">,</span> <span class="s1">&#39;float96&#39;</span><span class="p">,</span> <span class="s1">&#39;float128&#39;</span><span class="p">,</span> <span class="s1">&#39;complex192&#39;</span><span class="p">,</span> <span class="s1">&#39;complex256&#39;</span><span class="p">]</span>
                  <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">numx</span><span class="o">.</span><span class="n">typeDict</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">nongeneral_svd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;SVD routine for simple eigenvalue problem, API is compatible with</span>
<span class="sd">    symeig.&quot;&quot;&quot;</span>
    <span class="n">Z2</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="c1"># sort eigenvalues and corresponding eigenvectors</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="nb">range</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[:,</span> <span class="n">lo</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">hi</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">lo</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">hi</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">Z</span>

<span class="k">def</span> <span class="nf">sqrtm</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is a symmetric definite positive matrix sqrt function&quot;&quot;&quot;</span>
    <span class="n">d</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">mdp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">symeig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mdp</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">mult</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">mult_diag</span><span class="p">(</span><span class="n">numx</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

<span class="c1"># replication functions</span>
<span class="k">def</span> <span class="nf">lrep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replicate x n-times on a new first dimension&quot;&quot;&quot;</span>
    <span class="n">shp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">shp</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rrep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replicate x n-times on a new last dimension&quot;&quot;&quot;</span>
    <span class="n">shp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">irep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replicate x n-times on a new dimension dim-th dimension&quot;&quot;&quot;</span>
    <span class="n">x_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">shp</span> <span class="o">=</span> <span class="n">x_shape</span><span class="p">[:</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
<span class="c1"># /replication functions</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># product exists only in itertools &gt;= 2.6</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cartesian product of input iterables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># taken from python docs 2.6</span>
        <span class="c1"># product(&#39;ABCD&#39;, &#39;xy&#39;) --&gt; Ax Ay Bx By Cx Cy Dx Dy</span>
        <span class="c1"># product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111</span>
        <span class="n">pools</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span> <span class="o">*</span> <span class="n">kwds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;repeat&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[[]]</span>
        <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="n">pools</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">orthogonal_permutations</span><span class="p">(</span><span class="n">a_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a dictionary with lists as keys and returns all permutations</span>
<span class="sd">    of these list elements in new dicts.</span>

<span class="sd">    This function is useful, when a method with several arguments</span>
<span class="sd">    shall be tested and all of the arguments can take several values.</span>

<span class="sd">    The order is not defined, therefore the elements should be</span>
<span class="sd">    orthogonal to each other.</span>

<span class="sd">    &gt;&gt;&gt; for i in orthogonal_permutations({&#39;a&#39;: [1,2,3], &#39;b&#39;: [4,5]}):</span>
<span class="sd">            print i</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: 4}</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: 5}</span>
<span class="sd">    {&#39;a&#39;: 2, &#39;b&#39;: 4}</span>
<span class="sd">    {&#39;a&#39;: 2, &#39;b&#39;: 5}</span>
<span class="sd">    {&#39;a&#39;: 3, &#39;b&#39;: 4}</span>
<span class="sd">    {&#39;a&#39;: 3, &#39;b&#39;: 5}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a_dict</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">all_args</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="c1"># check the size of the list in the second item of the tuple</span>
        <span class="n">args_with_fun</span> <span class="o">=</span> <span class="p">[(</span><span class="n">func</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">all_args</span><span class="p">]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args_with_fun</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">izip_stretched</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Same as izip, except that for convenience non-iterables are repeated ad infinitum.</span>

<span class="sd">    This is useful when trying to zip input data with respective labels</span>
<span class="sd">    and allows for having a single label for all data, as well as for</span>
<span class="sd">    havning a list of labels for each data vector.</span>
<span class="sd">    Note that this will take strings as an iterable (of course), so</span>
<span class="sd">    strings acting as a single value need to be wrapped in a repeat</span>
<span class="sd">    statement of their own.</span>

<span class="sd">    Thus,</span>
<span class="sd">    &gt;&gt;&gt; for zipped in izip_stretched([1, 2, 3], -1):</span>
<span class="sd">            print zipped</span>
<span class="sd">    (1, -1)</span>
<span class="sd">    (2, -1)</span>
<span class="sd">    (3, -1)</span>

<span class="sd">    is equivalent to</span>
<span class="sd">    &gt;&gt;&gt; for zipped in izip([1, 2, 3], [-1] * 3):</span>
<span class="sd">            print zipped</span>
<span class="sd">    (1, -1)</span>
<span class="sd">    (2, -1)</span>
<span class="sd">    (3, -1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">iter_or_repeat</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="n">iterables</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">iter_or_repeat</span><span class="p">,</span> <span class="n">iterables</span><span class="p">))</span>
    <span class="k">while</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="c1"># need to care about python &lt; 2.6</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">weighted_choice</span><span class="p">(</span><span class="n">a_dict</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a key from a dictionary based on the weight that the value suggests.</span>
<span class="sd">    If &#39;normalize&#39; is False, it is assumed the weights sum up to unity. Otherwise,</span>
<span class="sd">    the algorithm will take care of normalising.</span>

<span class="sd">    Example:</span>
<span class="sd">    &gt;&gt;&gt; d = {&#39;a&#39;: 0.1, &#39;b&#39;: 0.5, &#39;c&#39;: 0.4}</span>
<span class="sd">    &gt;&gt;&gt; weighted_choice(d)</span>
<span class="sd">    # draws &#39;b&#39;:&#39;c&#39;:&#39;a&#39; with 5:4:1 probability</span>

<span class="sd">    TODO: It might be good to either shuffle the order or explicitely specify it,</span>
<span class="sd">    before walking through the items, to minimise possible degeneration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">a_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_div</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">a_dict</span>
    <span class="n">rand_num</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
    <span class="n">total_rand</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">total_rand</span> <span class="o">+=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">total_rand</span> <span class="o">&gt;</span> <span class="n">rand_num</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span>
    <span class="k">return</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">bool_to_sign</span><span class="p">(</span><span class="n">an_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return -1 for each False; +1 for each True&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numx</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">an_array</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sign_to_bool</span><span class="p">(</span><span class="n">an_array</span><span class="p">,</span> <span class="n">zero</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return False for each negative value, else True.</span>

<span class="sd">    The value for 0 is specified with &#39;zero&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">zero</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">numx</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">an_array</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">numx</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">an_array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">gabor</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">sgm</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ampl</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a 2D array containing a Gabor wavelet.</span>

<span class="sd">    Input arguments:</span>
<span class="sd">    size -- (height, width) (pixels)</span>
<span class="sd">    alpha -- orientation (rad)</span>
<span class="sd">    phi -- phase (rad)</span>
<span class="sd">    freq -- frequency (cycles/deg)</span>
<span class="sd">    sgm -- (sigma_x, sigma_y) standard deviation along the axis</span>
<span class="sd">           of the gaussian ellipse (pixel)</span>
<span class="sd">    x0 -- (x,y) coordinates of the center of the wavelet (pixel)</span>
<span class="sd">          Default: None, meaning the center of the array</span>
<span class="sd">    res -- spatial resolution (deg/pixel)</span>
<span class="sd">           Default: 1, so that &#39;freq&#39; is measured in cycles/pixel</span>
<span class="sd">    ampl -- constant multiplying the result</span>
<span class="sd">            Default: 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># init</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span>

    <span class="c1"># some useful quantities</span>
    <span class="n">freq</span> <span class="o">*=</span> <span class="n">res</span>
    <span class="n">sinalpha</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">cosalpha</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">v0</span><span class="p">,</span> <span class="n">u0</span> <span class="o">=</span> <span class="n">freq</span><span class="o">*</span><span class="n">cosalpha</span><span class="p">,</span> <span class="n">freq</span><span class="o">*</span><span class="n">sinalpha</span>

    <span class="c1"># coordinates</span>
    <span class="c1">#x = numx.mgrid[-x0:w-x0, -y0:h-y0]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">numx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">-</span><span class="n">x0</span><span class="p">,</span> <span class="n">numx</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">xr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">cosalpha</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sinalpha</span>
    <span class="n">yr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sinalpha</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">cosalpha</span>

    <span class="c1"># gabor</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">ampl</span><span class="o">*</span><span class="n">numx</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">xr</span><span class="o">*</span><span class="n">xr</span><span class="o">/</span><span class="p">(</span><span class="n">sgm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sgm</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">yr</span><span class="o">*</span><span class="n">yr</span><span class="o">/</span><span class="p">(</span><span class="n">sgm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sgm</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span> \
             <span class="o">*</span><span class="n">numx</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="o">*</span><span class="n">numx</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">u0</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">v0</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">phi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">im</span>

<div class="viewcode-block" id="residuals"><a class="viewcode-back" href="../../../mdp/mdp.utils.routines.html#mdp.utils.routines.residuals">[docs]</a><span class="k">def</span> <span class="nf">residuals</span><span class="p">(</span><span class="n">app_x</span><span class="p">,</span> <span class="n">y_noisy</span><span class="p">,</span> <span class="n">exp_funcs</span><span class="p">,</span> <span class="n">x_orig</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function used internally by invert_exp_funcs2 to approximate</span>
<span class="sd">    inverses in GeneralExpansionNode. &quot;&quot;&quot;</span>
    <span class="n">app_x</span> <span class="o">=</span> <span class="n">app_x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">app_exp_x</span> <span class="o">=</span>  <span class="n">numx</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">func</span><span class="p">(</span><span class="n">app_x</span><span class="p">)</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">exp_funcs</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">div_y</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_noisy</span><span class="p">))</span>
    <span class="n">div_x</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_orig</span><span class="p">))</span>  
    <span class="k">return</span> <span class="n">numx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span><span class="p">(</span><span class="n">y_noisy</span><span class="o">-</span><span class="n">app_exp_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">div_y</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_orig</span> <span class="o">-</span> <span class="n">app_x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">div_x</span> <span class="p">)</span></div>

<div class="viewcode-block" id="invert_exp_funcs2"><a class="viewcode-back" href="../../../mdp/mdp.utils.routines.html#mdp.utils.routines.invert_exp_funcs2">[docs]</a><span class="k">def</span> <span class="nf">invert_exp_funcs2</span><span class="p">(</span><span class="n">exp_x_noisy</span><span class="p">,</span> <span class="n">dim_x</span><span class="p">,</span> <span class="n">exp_funcs</span><span class="p">,</span> <span class="n">use_hint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Approximates a preimage app_x of exp_x_noisy.</span>

<span class="sd">    Returns an array app_x, such that each row of exp_funcs(app_x) is close</span>
<span class="sd">    to each row of exp_x_noisy.</span>

<span class="sd">    use_hint: determines the starting point for the approximation of the</span>
<span class="sd">    preimage. There are three possibilities.</span>
<span class="sd">    if it equals False: starting point is generated with a normal distribution</span>
<span class="sd">    if it equals True: starting point is the first dim_x elements of exp_x_noisy</span>
<span class="sd">    otherwise: use the parameter use_hint itself as the first approximation</span>

<span class="sd">    k: weighting factor in [0, 1] to balance between approximation error and</span>
<span class="sd">       closeness to the starting point. For instance:</span>
<span class="sd">       objective function is to minimize:</span>
<span class="sd">           (1-k) * ||exp_funcs(app_x) - exp_x_noisy||**2/output_dim +</span>
<span class="sd">               k * ||app_x - starting point||**2/input_dim</span>

<span class="sd">    Note: this function requires scipy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">numx_description</span> <span class="o">!=</span> <span class="s1">&#39;scipy&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;This function requires scipy.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">scipy.optimize</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="n">exp_x_noisy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_hint</span><span class="p">,</span> <span class="n">numx</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">app_x</span> <span class="o">=</span> <span class="n">use_hint</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">use_hint</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">app_x</span> <span class="o">=</span> <span class="n">exp_x_noisy</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">dim_x</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">app_x</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span><span class="n">dim_x</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">):</span>
        <span class="n">plsq</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="n">app_x</span><span class="p">[</span><span class="n">row</span><span class="p">],</span>
                                      <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">exp_x_noisy</span><span class="p">[</span><span class="n">row</span><span class="p">],</span> <span class="n">exp_funcs</span><span class="p">,</span>
                                            <span class="n">app_x</span><span class="p">[</span><span class="n">row</span><span class="p">],</span> <span class="n">k</span><span class="p">),</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">50</span><span class="o">*</span><span class="n">dim_x</span><span class="p">)</span>
        <span class="n">app_x</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">plsq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">app_exp_x</span> <span class="o">=</span> <span class="n">numx</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">func</span><span class="p">(</span><span class="n">app_x</span><span class="p">)</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">exp_funcs</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">app_x</span><span class="p">,</span> <span class="n">app_exp_x</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
      Last updated on 2020-02-17 1:33:02 PM Coordinated Universal Time.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'3.5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   
<div class="footer">
    <hr />
    <table>
      <tr>
        <td class="footer-left">
           <a href="http://sourceforge.net/projects/mdp-toolkit">
 <img src="http://sflogo.sourceforge.net/sflogo.php?group_id=116959&amp;type=12"
      width="120" height="30" border="0" alt="MDP@SF.NET"/> </a>
        </td>
        <td class="footer-center">
          Last updated on
             2020-02-17 1:33:02 PM Coordinated Universal Time
        </td>
        <td class="footer-right">
         <form class="search" action="../../../search.html" method="get">
          <input type="submit" value="Search" />
          <input type="text" name="q" size="18" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
         </form>
        </td>
    </table>  
    <!-- Piwik -->
    <script type="text/javascript">
	var pkBaseURL = (("https:" == document.location.protocol) ? "https://sourceforge.net/apps/piwik/mdp-toolkit/" : "http://sourceforge.net/apps/piwik/mdp-toolkit/");
	document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
	piwik_action_name = '';
	piwik_idsite = 1;
	piwik_url = pkBaseURL + "piwik.php";
	piwik_log(piwik_action_name, piwik_idsite, piwik_url);
    </script>
    <object><noscript>
	    <p>
		<img src="http://sourceforge.net/apps/piwik/mdp-toolkit/piwik.php?idsite=1"
		     alt="piwik" />
	    </p>
    </noscript></object>
    <!-- End Piwik Tag -->
</div>   


</body>
</html>