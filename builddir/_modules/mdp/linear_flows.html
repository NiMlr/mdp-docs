

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mdp.linear_flows &mdash; Modular toolkit for Data Processing (MDP)</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="Modular toolkit for Data Processing (MDP)" href="../../index.html"/>
        <link rel="up" title="mdp" href="../mdp.html"/> 
<meta name="viewport" content="width=740" />


  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html">
          

          
            
            <img src="../../_static/logo_animation.gif" class="logo" />
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how_to_cite_mdp.html">How to cite MDP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">MDP</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../mdp.html">mdp</a> &raquo;</li>
        
      <li>mdp.linear_flows</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mdp.linear_flows</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">future</span> <span class="k">import</span> <span class="n">standard_library</span>
<span class="n">standard_library</span><span class="o">.</span><span class="n">install_aliases</span><span class="p">()</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">str</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">object</span>
<span class="kn">import</span> <span class="nn">mdp</span>
<span class="kn">import</span> <span class="nn">sys</span> <span class="k">as</span> <span class="nn">_sys</span>
<span class="kn">import</span> <span class="nn">os</span> <span class="k">as</span> <span class="nn">_os</span>
<span class="kn">import</span> <span class="nn">inspect</span> <span class="k">as</span> <span class="nn">_inspect</span>
<span class="kn">import</span> <span class="nn">warnings</span> <span class="k">as</span> <span class="nn">_warnings</span>
<span class="kn">import</span> <span class="nn">traceback</span> <span class="k">as</span> <span class="nn">_traceback</span>
<span class="kn">import</span> <span class="nn">pickle</span> <span class="k">as</span> <span class="nn">_cPickle</span>
<span class="kn">import</span> <span class="nn">tempfile</span> <span class="k">as</span> <span class="nn">_tempfile</span>
<span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">_copy</span>

<span class="kn">from</span> <span class="nn">mdp</span> <span class="k">import</span> <span class="n">numx</span>

<span class="k">class</span> <span class="nc">CrashRecoveryException</span><span class="p">(</span><span class="n">mdp</span><span class="o">.</span><span class="n">MDPException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to handle crash recovery &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow crash recovery.</span>
<span class="sd">        Arguments: (error_string, crashing_obj, parent_exception)</span>
<span class="sd">        The crashing object is kept in self.crashing_obj</span>
<span class="sd">        The triggering parent exception is kept in self.parent_exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crashing_obj</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_exception</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># ?? python 2.5: super(CrashRecoveryException, self).__init__(errstr)</span>
        <span class="n">mdp</span><span class="o">.</span><span class="n">MDPException</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errstr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a pickle dump of the crashing object on filename.</span>
<span class="sd">        If filename is None, the crash dump is saved on a file created by</span>
<span class="sd">        the tempfile module.</span>
<span class="sd">        Return the filename.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This &#39;temporary file&#39; should actually stay &#39;forever&#39;, i.e. until</span>
            <span class="c1"># deleted by the user.</span>
            <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span><span class="o">=</span><span class="n">_tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;.pic&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;MDPcrash_&quot;</span><span class="p">)</span>
            <span class="n">fl</span> <span class="o">=</span> <span class="n">_os</span><span class="o">.</span><span class="n">fdopen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s1">&#39;w+b&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fl</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w+b&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">_cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crashing_obj</span><span class="p">,</span> <span class="n">fl</span><span class="p">)</span>
        <span class="n">fl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">filename</span>

<span class="k">class</span> <span class="nc">FlowException</span><span class="p">(</span><span class="n">mdp</span><span class="o">.</span><span class="n">MDPException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for exceptions in Flow subclasses.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">FlowExceptionCR</span><span class="p">(</span><span class="n">CrashRecoveryException</span><span class="p">,</span> <span class="n">FlowException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to handle flow-crash recovery &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allow crash recovery.</span>

<span class="sd">        Arguments: (error_string, flow_instance, parent_exception)</span>
<span class="sd">        The triggering parent exception is kept in self.parent_exception.</span>
<span class="sd">        If flow_instance._crash_recovery is set, save a crash dump of</span>
<span class="sd">        flow_instance on the file self.filename&quot;&quot;&quot;</span>
        <span class="n">CrashRecoveryException</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">rec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crashing_obj</span><span class="o">.</span><span class="n">_crash_recovery</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">rec</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">CrashRecoveryException</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">dumpinfo</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">A crash dump is available on: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="n">errstr</span><span class="o">+</span><span class="n">dumpinfo</span>

        <span class="ne">Exception</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errstr</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Flow</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A &#39;Flow&#39; is a sequence of nodes that are trained and executed</span>
<span class="sd">    together to form a more complex algorithm.  Input data is sent to the</span>
<span class="sd">    first node and is successively processed by the subsequent nodes along</span>
<span class="sd">    the sequence.</span>

<span class="sd">    Using a flow as opposed to handling manually a set of nodes has a</span>
<span class="sd">    clear advantage: The general flow implementation automatizes the</span>
<span class="sd">    training (including supervised training and multiple training phases),</span>
<span class="sd">    execution, and inverse execution (if defined) of the whole sequence.</span>

<span class="sd">    Crash recovery is optionally available: in case of failure the current</span>
<span class="sd">    state of the flow is saved for later inspection. A subclass of the</span>
<span class="sd">    basic flow class (&#39;CheckpointFlow&#39;) allows user-supplied checkpoint</span>
<span class="sd">    functions to be executed at the end of each phase, for example to save</span>
<span class="sd">    the internal structures of a node for later analysis.</span>
<span class="sd">    Flow objects are Python containers. Most of the builtin &#39;list&#39;</span>
<span class="sd">    methods are available. A &#39;Flow&#39; can be saved or copied using the</span>
<span class="sd">    corresponding &#39;save&#39; and &#39;copy&#39; methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">crash_recovery</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keyword arguments:</span>

<span class="sd">        flow -- a list of Nodes</span>
<span class="sd">        crash_recovery -- set (or not) Crash Recovery Mode (save node</span>
<span class="sd">                          in case a failure)</span>
<span class="sd">        verbose -- if True, print some basic progress information</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">flow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_crash_recovery</span><span class="p">(</span><span class="n">crash_recovery</span><span class="p">)</span>

<div class="viewcode-block" id="Flow._propagate_exception"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._propagate_exception">[docs]</a>    <span class="k">def</span> <span class="nf">_propagate_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">except_</span><span class="p">,</span> <span class="n">nodenr</span><span class="p">):</span>
        <span class="c1"># capture exception. the traceback of the error is printed and a</span>
        <span class="c1"># new exception, containing the identity of the node in the flow</span>
        <span class="c1"># is raised. Allow crash recovery.</span>
        <span class="p">(</span><span class="n">etype</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_traceback</span><span class="o">.</span><span class="n">format_exception</span><span class="p">(</span><span class="n">except_</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                                                   <span class="n">except_</span><span class="p">,</span><span class="n">tb</span><span class="p">))</span>
        <span class="n">act</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">! Exception in node #</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">):</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nodenr</span><span class="p">,</span>
                                                     <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">nodenr</span><span class="p">]))</span>
        <span class="n">errstr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">40</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">act</span><span class="p">,</span> <span class="s1">&#39;Node Traceback:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="mi">40</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="p">))</span>
        <span class="k">raise</span> <span class="n">FlowExceptionCR</span><span class="p">(</span><span class="n">errstr</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">except_</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow._train_node"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._train_node">[docs]</a>    <span class="k">def</span> <span class="nf">_train_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_iterable</span><span class="p">,</span> <span class="n">nodenr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Train a single node in the flow.</span>

<span class="sd">        nodenr -- index of the node in the flow</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">nodenr</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data_iterable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">()):</span>
            <span class="c1"># attempted to train a node although it is not trainable.</span>
            <span class="c1"># raise a warning and continue with the next node.</span>
            <span class="c1"># wrnstr = &quot;\n! Node %d is not trainable&quot; % nodenr + \</span>
            <span class="c1">#        &quot;\nYou probably need a &#39;None&#39; iterable for&quot;+\</span>
            <span class="c1">#         &quot; this node. Continuing anyway.&quot;</span>
            <span class="c1">#_warnings.warn(wrnstr, mdp.MDPWarning)</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">data_iterable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">is_training</span><span class="p">():</span>
            <span class="c1"># None instead of iterable is passed to a training node</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">! Node </span><span class="si">%d</span><span class="s2"> is training&quot;</span>
                       <span class="s2">&quot; but instead of iterable received &#39;None&#39;.&quot;</span> <span class="o">%</span> <span class="n">nodenr</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">data_iterable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_trainable</span><span class="p">()):</span>
            <span class="c1"># skip training if node is not trainable</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">train_arg_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_required_train_args</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">train_args_needed</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_arg_keys</span><span class="p">))</span>
            <span class="c1">## We leave the last training phase open for the</span>
            <span class="c1">## CheckpointFlow class.</span>
            <span class="c1">## Checkpoint functions must close it explicitly if needed!</span>
            <span class="c1">## Note that the last training_phase is closed</span>
            <span class="c1">## automatically when the node is executed.</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">empty_iterator</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data_iterable</span><span class="p">:</span>
                    <span class="n">empty_iterator</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1"># the arguments following the first are passed only to the</span>
                    <span class="c1"># currently trained node, allowing the implementation of</span>
                    <span class="c1"># supervised nodes</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">arg</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">arg</span> <span class="o">=</span> <span class="p">()</span>
                    <span class="c1"># check if the required number of arguments was given</span>
                    <span class="k">if</span> <span class="n">train_args_needed</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_arg_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Wrong number of arguments provided by &quot;</span> <span class="o">+</span>
                                   <span class="s2">&quot;the iterable for node #</span><span class="si">%d</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">nodenr</span> <span class="o">+</span>
                                   <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2"> needed, </span><span class="si">%d</span><span class="s2"> given).</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_arg_keys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span> <span class="o">+</span>
                                   <span class="s2">&quot;List of required argument keys: &quot;</span> <span class="o">+</span>
                                   <span class="nb">str</span><span class="p">(</span><span class="n">train_arg_keys</span><span class="p">))</span>
                            <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                    <span class="c1"># filter x through the previous nodes</span>
                    <span class="k">if</span> <span class="n">nodenr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_seq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nodenr</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># train current node</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">empty_iterator</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">get_current_train_phase</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The training data iteration for node &quot;</span>
                                   <span class="s2">&quot;no. </span><span class="si">%d</span><span class="s2"> could not be repeated for the &quot;</span>
                                   <span class="s2">&quot;second training phase, you probably &quot;</span>
                                   <span class="s2">&quot;provided an iterator instead of an &quot;</span>
                                   <span class="s2">&quot;iterable.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nodenr</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                        <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The training data iterator for node &quot;</span>
                                   <span class="s2">&quot;no. </span><span class="si">%d</span><span class="s2"> is empty.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nodenr</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                        <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_stop_training_hook</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">get_remaining_train_phase</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># close the previous training phase</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">stop_training</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">except</span> <span class="n">mdp</span><span class="o">.</span><span class="n">TrainingFinishedException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># attempted to train a node although its training phase is already</span>
            <span class="c1"># finished. raise a warning and continue with the next node.</span>
            <span class="n">wrnstr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">! Node </span><span class="si">%d</span><span class="s2"> training phase already finished&quot;</span>
                      <span class="s2">&quot; Continuing anyway.&quot;</span> <span class="o">%</span> <span class="n">nodenr</span><span class="p">)</span>
            <span class="n">_warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">wrnstr</span><span class="p">,</span> <span class="n">mdp</span><span class="o">.</span><span class="n">MDPWarning</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">FlowExceptionCR</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># this exception was already propagated,</span>
            <span class="c1"># probably during the execution  of a node upstream in the flow</span>
            <span class="p">(</span><span class="n">exc_type</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_traceback</span><span class="o">.</span><span class="n">format_exception_only</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">[</span><span class="n">prev</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">act</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">While training node #</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">):</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nodenr</span><span class="p">,</span>
                                                         <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">nodenr</span><span class="p">]))</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">40</span><span class="o">*</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">act</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="mi">40</span><span class="o">*</span><span class="s1">&#39;=&#39;</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># capture any other exception occured during training.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">nodenr</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow._stop_training_hook"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._stop_training_hook">[docs]</a>    <span class="k">def</span> <span class="nf">_stop_training_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hook method that is called before stop_training is called.&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Flow._get_required_train_args"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._get_required_train_args">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_required_train_args</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return arguments in addition to self and x for node.train.</span>

<span class="sd">        Argumentes that have a default value are ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">train_arg_spec</span> <span class="o">=</span> <span class="n">_inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">_train</span><span class="p">)</span>
        <span class="n">train_arg_keys</span> <span class="o">=</span> <span class="n">train_arg_spec</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># ignore self, x</span>
        <span class="k">if</span> <span class="n">train_arg_spec</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="c1"># subtract arguments with a default value</span>
            <span class="n">train_arg_keys</span> <span class="o">=</span> <span class="n">train_arg_keys</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">train_arg_spec</span><span class="p">[</span><span class="mi">3</span><span class="p">])]</span>
        <span class="k">return</span> <span class="n">train_arg_keys</span></div>

<div class="viewcode-block" id="Flow._train_check_iterables"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._train_check_iterables">[docs]</a>    <span class="k">def</span> <span class="nf">_train_check_iterables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_iterables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data iterables after some checks and sanitizing.</span>

<span class="sd">        Note that this method does not distinguish between iterables and</span>
<span class="sd">        iterators, so this must be taken care of later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># verifies that the number of iterables matches that of</span>
        <span class="c1"># the signal nodes and multiplies them if needed.</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span>

        <span class="c1"># if a single array is given wrap it in a list of lists,</span>
        <span class="c1"># note that a list of 2d arrays is not valid</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">,</span> <span class="n">numx</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">data_iterables</span> <span class="o">=</span> <span class="p">[[</span><span class="n">data_iterables</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;data_iterables&#39; must be either a list of &quot;</span>
                       <span class="s2">&quot;iterables or an array, and not </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                       <span class="nb">type</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>

        <span class="c1"># check that all elements are iterable</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">iterable</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iterable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)):</span>
                <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Element number </span><span class="si">%d</span><span class="s2"> in the data_iterables&quot;</span>
                       <span class="s2">&quot; list is not an iterable.&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

        <span class="c1"># check that the number of data_iterables is correct</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow</span><span class="p">):</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> data iterables specified,&quot;</span>
                       <span class="s2">&quot; </span><span class="si">%d</span><span class="s2"> needed&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_iterables</span></div>

<div class="viewcode-block" id="Flow._close_last_node"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._close_last_node">[docs]</a>    <span class="k">def</span> <span class="nf">_close_last_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Close the training phase of the last node&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stop_training</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">mdp</span><span class="o">.</span><span class="n">TrainingFinishedException</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">set_crash_recovery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set crash recovery capabilities.</span>

<span class="sd">        When a node raises an Exception during training, execution, or</span>
<span class="sd">        inverse execution that the flow is unable to handle, a FlowExceptionCR</span>
<span class="sd">        is raised. If crash recovery is set, a crash dump of the flow</span>
<span class="sd">        instance is saved for later inspection. The original exception</span>
<span class="sd">        can be found as the &#39;parent_exception&#39; attribute of the</span>
<span class="sd">        FlowExceptionCR instance.</span>

<span class="sd">        - If &#39;state&#39; = False, disable crash recovery.</span>
<span class="sd">        - If &#39;state&#39; is a string, the crash dump is saved on a file</span>
<span class="sd">          with that name.</span>
<span class="sd">        - If &#39;state&#39; = True, the crash dump is saved on a file created by</span>
<span class="sd">          the tempfile module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_crash_recovery</span> <span class="o">=</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_iterables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Train all trainable nodes in the flow.</span>

<span class="sd">        &#39;data_iterables&#39; is a list of iterables, one for each node in the flow.</span>
<span class="sd">        The iterators returned by the iterables must return data arrays that</span>
<span class="sd">        are then used for the node training (so the data arrays are the &#39;x&#39; for</span>
<span class="sd">        the nodes). Note that the data arrays are processed by the nodes</span>
<span class="sd">        which are in front of the node that gets trained, so the data dimension</span>
<span class="sd">        must match the input dimension of the first node.</span>

<span class="sd">        If a node has only a single training phase then instead of an iterable</span>
<span class="sd">        you can alternatively provide an iterator (including generator-type</span>
<span class="sd">        iterators). For nodes with multiple training phases this is not</span>
<span class="sd">        possible, since the iterator cannot be restarted after the first</span>
<span class="sd">        iteration. For more information on iterators and iterables see</span>
<span class="sd">        http://docs.python.org/library/stdtypes.html#iterator-types .</span>

<span class="sd">        In the special case that &#39;data_iterables&#39; is one single array,</span>
<span class="sd">        it is used as the data array &#39;x&#39; for all nodes and training phases.</span>

<span class="sd">        Instead of a data array &#39;x&#39; the iterators can also return a list or</span>
<span class="sd">        tuple, where the first entry is &#39;x&#39; and the following are args for the</span>
<span class="sd">        training of the node (e.g. for supervised training).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data_iterables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_check_iterables</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">)</span>

        <span class="c1"># train each Node successively</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Training node #</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_train_node</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Training finished&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_close_last_node</span><span class="p">()</span>

<div class="viewcode-block" id="Flow._execute_seq"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._execute_seq">[docs]</a>    <span class="k">def</span> <span class="nf">_execute_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nodenr</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Filters input data &#39;x&#39; through the nodes 0..&#39;node_nr&#39; included</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span>
        <span class="k">if</span> <span class="n">nodenr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodenr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nodenr</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">nodenr</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process the data through all nodes in the flow.</span>

<span class="sd">        &#39;iterable&#39; is an iterable or iterator (note that a list is also an</span>
<span class="sd">        iterable), which returns data arrays that are used as input to the flow.</span>
<span class="sd">        Alternatively, one can specify one data array as input.</span>

<span class="sd">        If &#39;nodenr&#39; is specified, the flow is executed only up to</span>
<span class="sd">        node nr. &#39;nodenr&#39;. This is equivalent to &#39;flow[:nodenr+1](iterable)&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">numx</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_seq</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">nodenr</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">empty_iterator</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">empty_iterator</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_execute_seq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nodenr</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">empty_iterator</span><span class="p">:</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The execute data iterator is empty.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numx</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

<div class="viewcode-block" id="Flow._inverse_seq"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._inverse_seq">[docs]</a>    <span class="k">def</span> <span class="nf">_inverse_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1">#Successively invert input data &#39;x&#39; through all nodes backwards</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_propagate_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process the data through all nodes in the flow backwards</span>
<span class="sd">        (starting from the last node up to the first node) by calling the</span>
<span class="sd">        inverse function of each node. Of course, all nodes in the</span>
<span class="sd">        flow must be invertible.</span>

<span class="sd">        &#39;iterable&#39; is an iterable or iterator  (note that a list is also an</span>
<span class="sd">        iterable), which returns data arrays that are used as input to the flow.</span>
<span class="sd">        Alternatively, one can specify one data array as input.</span>

<span class="sd">        Note that this is _not_ equivalent to &#39;flow[::-1](iterable)&#39;,</span>
<span class="sd">        which also executes the flow backwards but calls the &#39;execute&#39;</span>
<span class="sd">        function of each node.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">numx</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse_seq</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">empty_iterator</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">empty_iterator</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inverse_seq</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">empty_iterator</span><span class="p">:</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The inverse data iterator is empty.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numx</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep copy of the flow.</span>

<span class="sd">        The protocol parameter should not be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">protocol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;protocol parameter to copy() is ignored&quot;</span><span class="p">,</span>
                           <span class="n">mdp</span><span class="o">.</span><span class="n">MDPDeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save a pickled serialization of the flow to &#39;filename&#39;.</span>
<span class="sd">        If &#39;filename&#39; is None, return a string.</span>

<span class="sd">        Note: the pickled Flow is not guaranteed to be upward or</span>
<span class="sd">        backward compatible.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if protocol != 0 open the file in binary mode</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span> <span class="k">if</span> <span class="n">protocol</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;wb&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">flh</span><span class="p">:</span>
                <span class="n">_cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flh</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">nodenr</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calling an instance is equivalent to call its &#39;execute&#39; method.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">nodenr</span><span class="o">=</span><span class="n">nodenr</span><span class="p">)</span>

    <span class="c1">###### string representation</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">])</span>
        <span class="k">return</span> <span class="s1">&#39;[&#39;</span><span class="o">+</span><span class="n">nodes</span><span class="o">+</span><span class="s1">&#39;]&#39;</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># this should look like a valid Python expression that</span>
        <span class="c1"># could be used to recreate an object with the same value</span>
        <span class="c1"># eval(repr(object)) == object</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">*</span><span class="n">pad</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">])</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">([</span><span class="si">%s</span><span class="s1">])&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="c1">###### private container methods</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>

<div class="viewcode-block" id="Flow._check_dimension_consistency"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._check_dimension_consistency">[docs]</a>    <span class="k">def</span> <span class="nf">_check_dimension_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise ValueError when both dimensions are set and different.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">out</span> <span class="ow">and</span> <span class="n">inp</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">out</span> <span class="o">!=</span> <span class="n">inp</span><span class="p">:</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="s2">&quot;dimensions mismatch: </span><span class="si">%d</span><span class="s2"> != </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow._check_nodes_consistency"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._check_nodes_consistency">[docs]</a>    <span class="k">def</span> <span class="nf">_check_nodes_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check the dimension consistency of a list of nodes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">flow</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span>
        <span class="n">len_flow</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flow</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">len_flow</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">output_dim</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">flow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">input_dim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_dimension_consistency</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span></div>

<div class="viewcode-block" id="Flow._check_value_type_isnode"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.Flow._check_value_type_isnode">[docs]</a>    <span class="k">def</span> <span class="nf">_check_value_type_isnode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">mdp</span><span class="o">.</span><span class="n">Node</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;flow item must be Node instance&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">flow_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow_slice</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">flow_slice</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_value_type_isnode</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_value_type_isnode</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># make a copy of list</span>
        <span class="n">flow_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
        <span class="n">flow_copy</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1"># check dimension consistency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
        <span class="c1"># if no exception was raised, accept the new sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">flow_copy</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># make a copy of list</span>
        <span class="n">flow_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">flow_copy</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># check dimension consistency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
        <span class="c1"># if no exception was raised, accept the new sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">flow_copy</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># append other to self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Flow</span><span class="p">):</span>
            <span class="n">flow_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
            <span class="c1"># check dimension consistency</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
            <span class="c1"># if no exception was raised, accept the new sequence</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">mdp</span><span class="o">.</span><span class="n">Node</span><span class="p">):</span>
            <span class="n">flow_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
            <span class="n">flow_copy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="c1"># check dimension consistency</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
            <span class="c1"># if no exception was raised, accept the new sequence</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">flow_copy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;can only concatenate flow or node&#39;</span>
                       <span class="s1">&#39; (not </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">) to flow&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># append other to self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Flow</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">flow</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">mdp</span><span class="o">.</span><span class="n">Node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;can only concatenate flow or node&#39;</span>
                       <span class="s1">&#39; (not </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">) to flow&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nodes_consistency</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1">###### public container methods</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;flow.append(node) -- append node to flow end&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;flow.extend(iterable) -- extend flow by appending</span>
<span class="sd">        elements from the iterable&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Flow</span><span class="p">):</span>
            <span class="n">err_str</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;can only concatenate flow&#39;</span>
                       <span class="s1">&#39; (not </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">) to flow&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_str</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;flow.insert(index, node) -- insert node before index&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;flow.pop([index]) -&gt; node -- remove and return node at index</span>
<span class="sd">        (default last)&quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="k">class</span> <span class="nc">CheckpointFlow</span><span class="p">(</span><span class="n">Flow</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Subclass of Flow class that allows user-supplied checkpoint functions</span>
<span class="sd">    to be executed at the end of each phase, for example to</span>
<span class="sd">    save the internal structures of a node for later analysis.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="CheckpointFlow._train_check_checkpoints"><a class="viewcode-back" href="../../mdp/mdp.html#mdp.CheckpointFlow._train_check_checkpoints">[docs]</a>    <span class="k">def</span> <span class="nf">_train_check_checkpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">checkpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">checkpoints</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">):</span>
            <span class="n">error_str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> checkpoints specified,&quot;</span>
                         <span class="s2">&quot; </span><span class="si">%d</span><span class="s2"> needed&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="n">FlowException</span><span class="p">(</span><span class="n">error_str</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">checkpoints</span></div>


    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_iterables</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Train all trainable nodes in the flow.</span>

<span class="sd">        In addition to the basic behavior (see &#39;Node.train&#39;), calls the</span>
<span class="sd">        checkpoint function &#39;checkpoint[i]&#39; when the training phase of node #i</span>
<span class="sd">        is over.</span>

<span class="sd">        A checkpoint function takes as its only argument the trained node.</span>
<span class="sd">        If the checkpoint function returns a dictionary, its content is</span>
<span class="sd">        added to the instance dictionary.</span>

<span class="sd">        The class CheckpointFunction can be used to define user-supplied</span>
<span class="sd">        checkpoint functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data_iterables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_check_iterables</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">)</span>
        <span class="n">checkpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_check_checkpoints</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">)</span>

        <span class="c1"># train each Node successively</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">)):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Training node #</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_train_node</span><span class="p">(</span><span class="n">data_iterables</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">checkpoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">dic</span> <span class="o">=</span> <span class="n">checkpoints</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dic</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dic</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Training finished&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_close_last_node</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">CheckpointFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for checkpoint functions.</span>

<span class="sd">    This class can be subclassed to build objects to be used as a checkpoint</span>
<span class="sd">    function in a CheckpointFlow. Such objects would allow to define parameters</span>
<span class="sd">    for the function and save informations for later use.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute the checkpoint function.</span>

<span class="sd">        This is the method that is going to be called at the checkpoint.</span>
<span class="sd">        Overwrite it to match your needs.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">CheckpointSaveFunction</span><span class="p">(</span><span class="n">CheckpointFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This checkpoint function saves the node in pickle format.</span>
<span class="sd">    The pickle dump can be done either before the training phase is finished or</span>
<span class="sd">    right after that.</span>
<span class="sd">    In this way, it is for example possible to reload it in successive sessions</span>
<span class="sd">    and continue the training.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">stop_training</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;CheckpointSaveFunction constructor.</span>

<span class="sd">        &#39;filename&#39;      -- the name of the pickle dump file.</span>
<span class="sd">        &#39;stop_training&#39; -- if set to 0 the pickle dump is done before</span>
<span class="sd">                           closing the training phase</span>
<span class="sd">                           if set to 1 the training phase is closed and then</span>
<span class="sd">                           the node is dumped</span>
<span class="sd">        &#39;binary&#39;        -- sets binary mode for opening the file.</span>
<span class="sd">                           When using a protocol higher than 0, make sure</span>
<span class="sd">                           the file is opened in binary mode.</span>
<span class="sd">        &#39;protocol&#39;      -- is the &#39;protocol&#39; argument for the pickle dump</span>
<span class="sd">                           (see Pickle documentation for details)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proto</span> <span class="o">=</span> <span class="n">protocol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop_training</span> <span class="o">=</span> <span class="n">stop_training</span>
        <span class="k">if</span> <span class="n">binary</span> <span class="ow">or</span> <span class="n">protocol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;wb&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop_training</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">stop_training</span><span class="p">()</span>
            <span class="n">_cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proto</span><span class="p">)</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
      Last updated on 2020-02-17 1:33:02 PM Coordinated Universal Time.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'3.5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   
<div class="footer">
    <hr />
    <table>
      <tr>
        <td class="footer-left">
           <a href="http://sourceforge.net/projects/mdp-toolkit">
 <img src="http://sflogo.sourceforge.net/sflogo.php?group_id=116959&amp;type=12"
      width="120" height="30" border="0" alt="MDP@SF.NET"/> </a>
        </td>
        <td class="footer-center">
          Last updated on
             2020-02-17 1:33:02 PM Coordinated Universal Time
        </td>
        <td class="footer-right">
         <form class="search" action="../../search.html" method="get">
          <input type="submit" value="Search" />
          <input type="text" name="q" size="18" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
         </form>
        </td>
    </table>  
    <!-- Piwik -->
    <script type="text/javascript">
	var pkBaseURL = (("https:" == document.location.protocol) ? "https://sourceforge.net/apps/piwik/mdp-toolkit/" : "http://sourceforge.net/apps/piwik/mdp-toolkit/");
	document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
	piwik_action_name = '';
	piwik_idsite = 1;
	piwik_url = pkBaseURL + "piwik.php";
	piwik_log(piwik_action_name, piwik_idsite, piwik_url);
    </script>
    <object><noscript>
	    <p>
		<img src="http://sourceforge.net/apps/piwik/mdp-toolkit/piwik.php?idsite=1"
		     alt="piwik" />
	    </p>
    </noscript></object>
    <!-- End Piwik Tag -->
</div>   


</body>
</html>